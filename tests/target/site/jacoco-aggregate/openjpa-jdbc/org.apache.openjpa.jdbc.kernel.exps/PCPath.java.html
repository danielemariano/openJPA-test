<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PCPath.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-jdbc</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.jdbc.kernel.exps</a> &gt; <span class="el_source">PCPath.java</span></div><h1>PCPath.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.jdbc.kernel.exps;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Objects;

import org.apache.openjpa.jdbc.kernel.EagerFetchModes;
import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;
import org.apache.openjpa.jdbc.meta.ClassMapping;
import org.apache.openjpa.jdbc.meta.Discriminator;
import org.apache.openjpa.jdbc.meta.FieldMapping;
import org.apache.openjpa.jdbc.meta.Strategy;
import org.apache.openjpa.jdbc.meta.ValueMapping;
import org.apache.openjpa.jdbc.meta.strats.HandlerCollectionTableFieldStrategy;
import org.apache.openjpa.jdbc.meta.strats.HandlerHandlerMapTableFieldStrategy;
import org.apache.openjpa.jdbc.meta.strats.LRSMapFieldStrategy;
import org.apache.openjpa.jdbc.schema.Column;
import org.apache.openjpa.jdbc.schema.ForeignKey;
import org.apache.openjpa.jdbc.schema.Schemas;
import org.apache.openjpa.jdbc.sql.Joins;
import org.apache.openjpa.jdbc.sql.Result;
import org.apache.openjpa.jdbc.sql.SQLBuffer;
import org.apache.openjpa.jdbc.sql.Select;
import org.apache.openjpa.kernel.Broker;
import org.apache.openjpa.kernel.Filters;
import org.apache.openjpa.kernel.OpenJPAStateManager;
import org.apache.openjpa.kernel.StoreContext;
import org.apache.openjpa.kernel.exps.CandidatePath;
import org.apache.openjpa.kernel.exps.Context;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.meta.ClassMetaData;
import org.apache.openjpa.meta.FieldMetaData;
import org.apache.openjpa.meta.JavaTypes;
import org.apache.openjpa.meta.XMLMetaData;
import org.apache.openjpa.util.ImplHelper;
import org.apache.openjpa.util.UserException;

/**
 * A path represents a traversal into fields of a candidate object.
 *
 * @author Abe White
 */
public class PCPath extends CandidatePath implements JDBCPath {

    
    private static final long serialVersionUID = 1L;
    protected static final String TRUE = &quot;1 = 1&quot;;
    protected static final String FALSE = &quot;1 &lt;&gt; 1&quot;;

    private static final int PATH = 0;
    private static final int BOUND_VAR = 1;
    private static final int UNBOUND_VAR = 2;
    private static final int UNACCESSED_VAR = 3;
    private static final int XPATH = 4;
    private static final int OBJECT_PATH = 5;

<span class="nc" id="L78">    private static final Localizer _loc = Localizer.forPackage(PCPath.class);</span>

    private final ClassMapping _candidate;
<span class="nc" id="L81">    private ClassMapping _class = null;</span>
<span class="nc" id="L82">    private boolean _key = false;</span>
<span class="nc" id="L83">    private int _type = PATH;</span>
<span class="nc" id="L84">    private String _varName = null;</span>
<span class="nc" id="L85">    private Class _cast = null;</span>
<span class="nc" id="L86">    private boolean _cid = false;</span>
<span class="nc" id="L87">    private FieldMetaData _xmlfield = null;</span>
<span class="nc" id="L88">    private boolean _keyPath = false;</span>
<span class="nc" id="L89">    private String _schemaAlias = null;</span>

    /**
     * Return a path starting with the 'this' ptr.
     */
<span class="nc" id="L94">    public PCPath(ClassMapping type) {</span>
<span class="nc" id="L95">        _candidate = type;</span>
<span class="nc" id="L96">    }</span>

    /**
     * Return a path starting from the given variable.
     */
<span class="nc" id="L101">    public PCPath(ClassMapping candidate, Variable var) {</span>
<span class="nc" id="L102">        _candidate = candidate;</span>
<span class="nc" id="L103">        _actions = new LinkedList();</span>

<span class="nc" id="L105">        PCPath other = var.getPCPath();</span>
<span class="nc" id="L106">        Action action = new Action();</span>
<span class="nc" id="L107">        action.var = var.getName();</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (other == null) {</span>
<span class="nc" id="L109">            _type = UNBOUND_VAR;</span>
<span class="nc" id="L110">            action.op = Action.UNBOUND_VAR;</span>
<span class="nc" id="L111">            action.data = var;</span>
<span class="nc" id="L112">            _schemaAlias = var.getName();</span>
        } else {
            // bound variable; copy path
<span class="nc" id="L115">            _type = UNACCESSED_VAR;</span>
<span class="nc" id="L116">            _actions.addAll(other._actions);</span>
<span class="nc" id="L117">            _key = other._key;</span>

<span class="nc" id="L119">            action.op = Action.VAR;</span>
<span class="nc" id="L120">            action.data = var.getName();</span>
<span class="nc" id="L121">            _schemaAlias = other._schemaAlias;</span>
<span class="nc" id="L122">            _correlationVar = other._correlationVar;</span>
        }
<span class="nc" id="L124">        _actions.add(action);</span>
<span class="nc" id="L125">        _cast = var.getType(); // initial type is var type</span>
<span class="nc" id="L126">    }</span>

    /**
     * Return a path starting from the given subquery.
     */
<span class="nc" id="L131">    public PCPath(SubQ sub) {</span>
<span class="nc" id="L132">        _candidate = sub.getCandidate();</span>
<span class="nc" id="L133">        _actions = new LinkedList();</span>

<span class="nc" id="L135">        Action action = new Action();</span>
<span class="nc" id="L136">        action.op = Action.SUBQUERY;</span>
<span class="nc" id="L137">        action.data = sub.getCandidateAlias();</span>
<span class="nc" id="L138">        _actions.add(action);</span>
<span class="nc" id="L139">        _cast = sub.getType(); // initial type is subquery type</span>
<span class="nc" id="L140">        _varName = sub.getCandidateAlias();</span>
<span class="nc" id="L141">    }</span>

    @Override
    public void setSchemaAlias(String schemaAlias) {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (_schemaAlias == null)</span>
<span class="nc" id="L146">            _schemaAlias = schemaAlias;</span>
<span class="nc" id="L147">    }</span>

    @Override
    public String getSchemaAlias() {
<span class="nc" id="L151">        return _schemaAlias;</span>
    }

    @Override
    public void setSubqueryContext(Context context, String correlationVar) {
<span class="nc" id="L156">        Action action = lastFieldAction();</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (action == null)</span>
<span class="nc" id="L158">            return;</span>
<span class="nc" id="L159">        action.context = context;</span>
<span class="nc" id="L160">        _correlationVar = correlationVar;</span>
<span class="nc" id="L161">    }</span>

    /**
     * Set the path as a binding of the given variable.
     */
    public void addVariableAction(Variable var) {
<span class="nc" id="L167">        _varName = var.getName();</span>
<span class="nc" id="L168">    }</span>

    /**
     * Return true if this is a bound variable that has not been accessed
     * after binding. Useful for filters like
     * &quot;coll.contains (var) &amp;amp;&amp;amp; var == null&quot;, which should really
     * just act like &quot;coll.contains (null)&quot;.
     */
    public boolean isUnaccessedVariable() {
<span class="nc bnc" id="L177" title="All 2 branches missed.">        return _type == UNACCESSED_VAR;</span>
    }

    /**
     * Return whether this is a path involving a variable.
     */
    public boolean isVariablePath() {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        return _type != PATH;</span>
    }

    /**
     * If this path is part of a contains clause, then alias it to the
     * proper contains id before initialization.
     */
    public synchronized void setContainsId(String id) {
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (_cid)</span>
<span class="nc" id="L193">            return;</span>

<span class="nc bnc" id="L195" title="All 2 branches missed.">        Action last = _actions == null ? null : (Action) _actions.getLast();</span>
<span class="nc bnc" id="L196" title="All 6 branches missed.">        if (last != null &amp;&amp; last.op == Action.VAR &amp;&amp; ((String)last.data).equals(last.var)) {</span>
<span class="nc" id="L197">            _cid = true;</span>
<span class="nc" id="L198">            return;</span>
        }

        // treat it just like a unique variable
<span class="nc" id="L202">        Action action = new Action();</span>
<span class="nc" id="L203">        action.op = Action.VAR;</span>
<span class="nc" id="L204">        action.data = id;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (_actions == null)</span>
<span class="nc" id="L206">            _actions = new LinkedList();</span>
<span class="nc" id="L207">        _actions.add(action);</span>
<span class="nc" id="L208">        _cid = true;</span>
<span class="nc" id="L209">    }</span>

    @Override
    public ClassMetaData getMetaData() {
<span class="nc" id="L213">        return _class;</span>
    }

    @Override
    public void setMetaData(ClassMetaData meta) {
<span class="nc" id="L218">        _class = (ClassMapping) meta;</span>
<span class="nc" id="L219">    }</span>

    public boolean isKey() {
<span class="nc" id="L222">        return _key;</span>
    }

    @Override
    public boolean isXPath() {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        return _type == XPATH;</span>
    }

    public String getXPath() {
<span class="nc" id="L231">        StringBuilder xpath = new StringBuilder();</span>
        Action action;
<span class="nc" id="L233">        Iterator itr = _actions.iterator();</span>

        // Skip variable actions since they are not part of the xpath
        // until we reach the first xpath action.
        // The first xpath action maps to the root of an xml document.
        do
<span class="nc" id="L239">            action = (Action) itr.next();</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        while (action.op != Action.GET_XPATH);</span>

        // Skip XmlRootElement:
        // We can't rely on the accuracy of the name of the root element,
        // because it could be set to some default by JAXB XML Binding.
        // The caller(DBDictionary) should start with &quot;/*&quot; or &quot;/*/&quot;,
        // we build the remaining xpath that follows the root element.
<span class="nc bnc" id="L247" title="All 2 branches missed.">        while (itr.hasNext()) {</span>
<span class="nc" id="L248">            action = (Action) itr.next();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (((XMLMetaData) action.data).getXmlname() != null)</span>
<span class="nc" id="L250">                xpath.append(((XMLMetaData) action.data).getXmlname());</span>
            else
<span class="nc" id="L252">                xpath.append(&quot;*&quot;);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (itr.hasNext())</span>
<span class="nc" id="L254">                xpath.append(&quot;/&quot;);</span>
        }
<span class="nc" id="L256">        return xpath.toString();</span>
    }

    public String getPCPathString() {
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (_actions == null)</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            return (_varName == null) ? &quot;&quot; : _varName + &quot;.&quot;;</span>

<span class="nc" id="L263">        StringBuilder path = new StringBuilder();</span>
        Action action;
<span class="nc bnc" id="L265" title="All 2 branches missed.">        for (Iterator itr = _actions.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L266">            action = (Action) itr.next();</span>
<span class="nc bnc" id="L267" title="All 4 branches missed.">            if (action.op == Action.VAR || action.op == Action.SUBQUERY)</span>
<span class="nc" id="L268">                path.append(action.data);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            else if (action.op == Action.UNBOUND_VAR)</span>
<span class="nc" id="L270">                path.append(((Variable) action.data).getName());</span>
            else
<span class="nc" id="L272">                path.append(((FieldMapping) action.data).getName());</span>
<span class="nc" id="L273">            path.append('.');</span>
        }
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (_varName != null)</span>
<span class="nc" id="L276">            path.append(_varName).append('.');</span>
<span class="nc" id="L277">        return path.toString();</span>
    }

    public ClassMapping getClassMapping(ExpState state) {
<span class="nc" id="L281">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (pstate.field == null)</span>
<span class="nc" id="L283">            return _class;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (_key) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (pstate.field.getKey().getTypeCode() == JavaTypes.PC)</span>
<span class="nc" id="L286">                return pstate.field.getKeyMapping().getTypeMapping();</span>
<span class="nc" id="L287">            return null;</span>
        }
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (pstate.field.getElement().getTypeCode() == JavaTypes.PC) {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (pstate.field.isElementCollection() &amp;&amp;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                pstate.field.getElement().isEmbedded())</span>
<span class="nc" id="L292">                pstate.isEmbedElementColl = true;</span>
<span class="nc" id="L293">            return pstate.field.getElementMapping().getTypeMapping();</span>
        }
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (pstate.field.getTypeCode() == JavaTypes.PC)</span>
<span class="nc" id="L296">            return pstate.field.getTypeMapping();</span>
<span class="nc" id="L297">        return null;</span>
    }

    public FieldMapping getFieldMapping(ExpState state) {
<span class="nc" id="L301">        return ((PathExpState) state).field;</span>
    }

    public Column[] getColumns(ExpState state) {
<span class="nc" id="L305">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (pstate.cols == null)</span>
<span class="nc" id="L307">            pstate.cols = calculateColumns(pstate);</span>
<span class="nc" id="L308">        return pstate.cols;</span>
    }

    /**
     * The columns used by this path.
     */
    private Column[] calculateColumns(PathExpState pstate) {
<span class="nc bnc" id="L315" title="All 4 branches missed.">        if (_key ||</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            (_keyPath &amp;&amp; pstate.field.getKey() != null &amp;&amp;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                !pstate.field.getKey().isEmbedded())) {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            if (!pstate.joinedRel</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">                &amp;&amp; pstate.field.getKey().getValueMappedBy() != null)</span>
<span class="nc" id="L320">                joinRelation(pstate, _key, false, false);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            else if (pstate.joinedRel</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">                &amp;&amp; pstate.field.getKey().getTypeCode() == JavaTypes.PC)</span>
<span class="nc" id="L323">                return pstate.field.getKeyMapping().getTypeMapping().</span>
<span class="nc" id="L324">                    getPrimaryKeyColumns();</span>
<span class="nc" id="L325">            return pstate.field.getKeyMapping().getColumns();</span>
        }
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (pstate.field != null) {</span>
<span class="nc bnc" id="L328" title="All 3 branches missed.">            switch (pstate.field.getTypeCode()) {</span>
                case JavaTypes.MAP:
                case JavaTypes.ARRAY:
                case JavaTypes.COLLECTION:
<span class="nc" id="L332">                    ValueMapping elem = pstate.field.getElementMapping();</span>
<span class="nc bnc" id="L333" title="All 4 branches missed.">                    if (pstate.field.isElementCollection() &amp;&amp; pstate.field.getElement().isEmbedded()) {</span>
<span class="nc" id="L334">                        Strategy strategy = pstate.field.getStrategy();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                        if (strategy instanceof HandlerCollectionTableFieldStrategy) {</span>
<span class="nc" id="L336">                            return ((HandlerCollectionTableFieldStrategy) strategy).</span>
<span class="nc" id="L337">                                getElementColumns(elem.getTypeMapping());</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                        } else if (strategy instanceof HandlerHandlerMapTableFieldStrategy) {</span>
<span class="nc" id="L339">                            return ((HandlerHandlerMapTableFieldStrategy) strategy).</span>
<span class="nc" id="L340">                            getValueColumns(elem.getTypeMapping());</span>
                        }
                    }
<span class="nc bnc" id="L343" title="All 4 branches missed.">                    if (pstate.joinedRel &amp;&amp; elem.getTypeCode() == JavaTypes.PC)</span>
<span class="nc" id="L344">                        return elem.getTypeMapping().getPrimaryKeyColumns();</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                    if (elem.getColumns().length &gt; 0)</span>
<span class="nc" id="L346">                        return elem.getColumns();</span>
<span class="nc" id="L347">                    return pstate.field.getColumns();</span>
                case JavaTypes.PC:
<span class="nc bnc" id="L349" title="All 2 branches missed.">                    if (pstate.joinedRel)</span>
<span class="nc" id="L350">                        return pstate.field.getTypeMapping().</span>
<span class="nc" id="L351">                            getPrimaryKeyColumns();</span>
<span class="nc" id="L352">                    return pstate.field.getColumns();</span>
                default:
<span class="nc" id="L354">                    return pstate.field.getColumns();</span>
            }
        }
<span class="nc bnc" id="L357" title="All 2 branches missed.">        return (_class == null) ? Schemas.EMPTY_COLUMNS</span>
<span class="nc" id="L358">            : _class.getPrimaryKeyColumns();</span>
    }

    @Override
    public boolean isVariable() {
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (_actions == null)</span>
<span class="nc" id="L364">            return false;</span>
<span class="nc" id="L365">        Action action = (Action) _actions.getLast();</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">        return action.op == Action.UNBOUND_VAR || action.op == Action.VAR;</span>
    }

    @Override
    public void get(FieldMetaData field, boolean nullTraversal) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (_actions == null)</span>
<span class="nc" id="L372">            _actions = new LinkedList();</span>
<span class="nc" id="L373">        Action action = new Action();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        action.op = (nullTraversal) ? Action.GET_OUTER : Action.GET;</span>
<span class="nc" id="L375">        action.data = field;</span>
<span class="nc" id="L376">        _actions.add(action);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (_type == UNACCESSED_VAR)</span>
<span class="nc" id="L378">            _type = BOUND_VAR;</span>
<span class="nc" id="L379">        _cast = null;</span>
<span class="nc" id="L380">        _key = false;</span>
<span class="nc" id="L381">    }</span>

    @Override
    public void get(FieldMetaData fmd, XMLMetaData meta) {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (_actions == null)</span>
<span class="nc" id="L386">            _actions = new LinkedList();</span>
<span class="nc" id="L387">        Action action = new Action();</span>
<span class="nc" id="L388">        action.op = Action.GET_XPATH;</span>
<span class="nc" id="L389">        action.data = meta;</span>
<span class="nc" id="L390">        _actions.add(action);</span>
<span class="nc" id="L391">        _cast = null;</span>
<span class="nc" id="L392">        _key = false;</span>
<span class="nc" id="L393">        _type = XPATH;</span>
<span class="nc" id="L394">        _xmlfield = fmd;</span>
<span class="nc" id="L395">    }</span>

    @Override
    public void get(XMLMetaData meta, String name) {
<span class="nc" id="L399">        Action action = new Action();</span>
<span class="nc" id="L400">        action.op = Action.GET_XPATH;</span>
<span class="nc" id="L401">        action.data = meta.getFieldMapping(name);</span>
<span class="nc" id="L402">        _actions.add(action);</span>
<span class="nc" id="L403">        _cast = null;</span>
<span class="nc" id="L404">        _key = false;</span>
<span class="nc" id="L405">        _type = XPATH;</span>
<span class="nc" id="L406">    }</span>

    @Override
    public XMLMetaData getXmlMapping() {
<span class="nc" id="L410">        Action act = (Action) _actions.getLast();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (act != null)</span>
<span class="nc" id="L412">            return (XMLMetaData) act.data;</span>
<span class="nc" id="L413">        return null;</span>
    }

    @Override
    public synchronized void getKey() {
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (_cid)</span>
<span class="nc" id="L419">            return;</span>

        // replace the last field action to a get key
<span class="nc" id="L422">        Action action = lastFieldAction();</span>
<span class="nc" id="L423">        Action key = new Action();</span>
<span class="nc" id="L424">        key.op = Action.GET_KEY;</span>
<span class="nc" id="L425">        key.data = action.data;</span>
<span class="nc" id="L426">        int pos = _actions.indexOf(action);</span>
<span class="nc" id="L427">        _actions.remove(action);</span>
<span class="nc" id="L428">        _actions.add(pos, key);</span>
<span class="nc" id="L429">        _cast = null;</span>
<span class="nc" id="L430">        _key = true;</span>
<span class="nc" id="L431">        _type = PATH;</span>
<span class="nc" id="L432">    }</span>

    private void checkObjectPathInheritanceTypeJoined(PathExpState pstate) {
        // if this mapping is in InheritanceType.JOINED,
        // then add joins
<span class="nc" id="L437">         ClassMapping base = _class;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">         while (base.getJoinablePCSuperclassMapping() != null)</span>
<span class="nc" id="L439">             base = base.getJoinablePCSuperclassMapping();</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">         if (base != _class) {</span>
<span class="nc" id="L441">             ClassMapping from = _class;</span>
<span class="nc" id="L442">             ClassMapping to = base;</span>
<span class="nc" id="L443">             _type = OBJECT_PATH;</span>
<span class="nc bnc" id="L444" title="All 4 branches missed.">             for (; from != null &amp;&amp; from != to; from = from.getJoinablePCSuperclassMapping()) {</span>
<span class="nc" id="L445">                 pstate.joins = from.joinSuperclass(pstate.joins, false);</span>
             }
         }
<span class="nc" id="L448">    }</span>

    @Override
    public FieldMetaData last() {
<span class="nc" id="L452">        Action act = lastFieldAction();</span>
<span class="nc bnc" id="L453" title="All 4 branches missed.">        return (act == null) ? null : isXPath() ?</span>
<span class="nc" id="L454">            _xmlfield : (FieldMetaData) act.data;</span>
    }

    /**
     * Return the last action that gets a field.
     */
    private Action lastFieldAction() {
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (_actions == null)</span>
<span class="nc" id="L462">            return null;</span>

<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (isXPath())</span>
<span class="nc" id="L465">            return (Action) _actions.getLast();</span>

<span class="nc" id="L467">        ListIterator itr = _actions.listIterator(_actions.size());</span>
        Action prev;
<span class="nc bnc" id="L469" title="All 2 branches missed.">        while (itr.hasPrevious()) {</span>
<span class="nc" id="L470">            prev = (Action) itr.previous();</span>
<span class="nc bnc" id="L471" title="All 6 branches missed.">            if (prev.op == Action.GET || prev.op == Action.GET_OUTER</span>
                || prev.op == Action.GET_KEY)
<span class="nc" id="L473">                return prev;</span>
        }
<span class="nc" id="L475">        return null;</span>
    }

    @Override
    public Class getType() {
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (_cast != null)</span>
<span class="nc" id="L481">            return _cast;</span>
<span class="nc" id="L482">        Action act = lastFieldAction();</span>
<span class="nc bnc" id="L483" title="All 4 branches missed.">        if (act != null &amp;&amp; act.op == Action.GET_XPATH)</span>
<span class="nc" id="L484">            return ((XMLMetaData) act.data).getType();</span>

<span class="nc bnc" id="L486" title="All 2 branches missed.">        FieldMetaData fld = (act == null) ? null : (FieldMetaData) act.data;</span>
<span class="nc bnc" id="L487" title="All 4 branches missed.">        boolean key = act != null &amp;&amp; act.op == Action.GET_KEY;</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (fld != null) {</span>
<span class="nc bnc" id="L489" title="All 4 branches missed.">            switch (fld.getDeclaredTypeCode()) {</span>
                case JavaTypes.ARRAY:
<span class="nc bnc" id="L491" title="All 2 branches missed.">                    if (fld.getDeclaredType() == byte[].class</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                        || fld.getDeclaredType() == Byte[].class</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                        || fld.getDeclaredType() == char[].class</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                        || fld.getDeclaredType() == Character[].class)</span>
<span class="nc" id="L495">                        return fld.getDeclaredType();</span>
<span class="nc" id="L496">                    return fld.getElement().getDeclaredType();</span>
                case JavaTypes.MAP:
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    if (key)</span>
<span class="nc" id="L499">                        return fld.getKey().getDeclaredType();</span>
<span class="nc" id="L500">                    return fld.getElement().getDeclaredType();</span>
                case JavaTypes.COLLECTION:
<span class="nc" id="L502">                    return fld.getElement().getDeclaredType();</span>
                default:
<span class="nc" id="L504">                    return fld.getDeclaredType();</span>
            }
        }
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (_class != null)</span>
<span class="nc" id="L508">            return _class.getDescribedType();</span>
<span class="nc" id="L509">        return Object.class;</span>
    }

    @Override
    public void setImplicitType(Class type) {
<span class="nc" id="L514">        _cast = type;</span>
<span class="nc" id="L515">    }</span>

    @Override
    public ExpState initialize(Select sel, ExpContext ctx, int flags) {
<span class="nc" id="L519">        PathExpState pstate = new PathExpState(sel.newJoins());</span>
<span class="nc" id="L520">        boolean key = false;</span>
<span class="nc" id="L521">        boolean forceOuter = false;</span>
<span class="nc" id="L522">        ClassMapping rel = _candidate;</span>

<span class="nc" id="L524">        sel.setSchemaAlias(_schemaAlias);</span>

        // iterate to the final field
        ClassMapping owner;
        ClassMapping from, to;
        Action action;
        Variable var;
<span class="nc bnc" id="L531" title="All 2 branches missed.">        Iterator itr = (_actions == null) ? null : _actions.iterator();</span>
<span class="nc" id="L532">        FieldMapping field = null;</span>
<span class="nc" id="L533">        Action prevaction = null;</span>
<span class="nc" id="L534">        boolean isCorrelatedPath = false;</span>
<span class="nc" id="L535">        boolean fromParentRootInSubselect = navigateFromParentRootInSubselect(sel);</span>

<span class="nc bnc" id="L537" title="All 4 branches missed.">        while (itr != null &amp;&amp; itr.hasNext()) {</span>
<span class="nc" id="L538">            action = (Action) itr.next();</span>

            // treat subqueries like variables for alias generation purposes
<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (action.op == Action.VAR) {</span>
<span class="nc bnc" id="L542" title="All 8 branches missed.">                if (sel.getParent() != null &amp;&amp; action.var != null &amp;&amp;</span>
                    prevaction != null &amp;&amp; prevaction.data != null &amp;&amp;
<span class="nc bnc" id="L544" title="All 2 branches missed.">                    sel.ctx().getVariable(action.var) == null) {</span>
<span class="nc" id="L545">                    isCorrelatedPath = true;</span>
<span class="nc" id="L546">                    pstate.joins = pstate.joins.setCorrelatedVariable(action.var);</span>
                } else
<span class="nc" id="L548">                    pstate.joins = pstate.joins.setVariable((String) action.data);</span>
            }
<span class="nc bnc" id="L550" title="All 2 branches missed.">            else if (action.op == Action.SUBQUERY) {</span>
<span class="nc" id="L551">                pstate.joins = pstate.joins.setSubselect((String) action.data);</span>
            }
<span class="nc bnc" id="L553" title="All 2 branches missed.">            else if (action.op == Action.UNBOUND_VAR) {</span>
                // unbound vars are cross-joined to the candidate table
<span class="nc" id="L555">                var = (Variable) action.data;</span>
<span class="nc" id="L556">                rel = (ClassMapping) var.getMetaData();</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                if (rel == null)</span>
<span class="nc" id="L558">                	throw new IllegalArgumentException(_loc.get(</span>
<span class="nc" id="L559">                	    &quot;invalid-unbound-var&quot;, var.getName()).toString());</span>

<span class="nc bnc" id="L561" title="All 4 branches missed.">                if (sel.getParent() != null &amp;&amp; action.var != null &amp;&amp;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                    sel.ctx().getVariable(action.var) == null) {</span>
                    //System.out.println(&quot;Correlated action var=&quot;+action.var);
<span class="nc" id="L564">                    isCorrelatedPath = true;</span>
<span class="nc" id="L565">                    pstate.joins = pstate.joins.setCorrelatedVariable(var.getName());</span>
                } else
<span class="nc" id="L567">                    pstate.joins = pstate.joins.setVariable(var.getName());</span>

<span class="nc" id="L569">                pstate.joins = pstate.joins.crossJoin(_candidate.getTable(),</span>
<span class="nc" id="L570">                    rel.getTable());</span>
<span class="nc bnc" id="L571" title="All 4 branches missed.">                if (!itr.hasNext() &amp;&amp; isVariable()) {</span>
<span class="nc" id="L572">                    checkObjectPathInheritanceTypeJoined(pstate);</span>
                }
            } else {
                // move past the previous field, if any
<span class="nc bnc" id="L576" title="All 2 branches missed.">                field = (FieldMapping) ((action.op == Action.GET_XPATH) ?</span>
<span class="nc" id="L577">                    _xmlfield : action.data);</span>

<span class="nc bnc" id="L579" title="All 2 branches missed.">                if (pstate.field != null) {</span>
                    // if this is the second-to-last field and the last is
                    // the related field this field joins to, no need to
                    // traverse: just use this field's fk columns
<span class="nc bnc" id="L583" title="All 4 branches missed.">                    if (!itr.hasNext() &amp;&amp; (flags &amp; JOIN_REL) == 0</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                        &amp;&amp; isJoinedField(pstate.field, key, field)) {</span>
<span class="nc" id="L585">                        pstate.cmpfield = field;</span>
<span class="nc" id="L586">                        break;</span>
                    }

<span class="nc bnc" id="L589" title="All 2 branches missed.">                    if (fromParentRootInSubselect) {</span>
<span class="nc" id="L590">                        isCorrelatedPath = true;</span>
<span class="nc" id="L591">                        pstate.joins = pstate.joins.setCorrelatedVariable(_schemaAlias);</span>
<span class="nc" id="L592">                        pstate.joins.setJoinContext(null);</span>
                    }

<span class="nc bnc" id="L595" title="All 2 branches missed.">                    rel = traverseField(pstate, key, forceOuter ||</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                              ctx.store.getDBDictionary().fullResultCollectionInOrderByRelation, false);</span>
                }

                // mark if the next traversal should go through
                // the key rather than value
<span class="nc bnc" id="L601" title="All 2 branches missed.">                key = action.op == Action.GET_KEY;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">                forceOuter |= action.op == Action.GET_OUTER;</span>

<span class="nc bnc" id="L604" title="All 4 branches missed.">                if (key &amp;&amp; itr.hasNext())</span>
<span class="nc" id="L605">                    _keyPath = true;</span>

                // get mapping for the current field
<span class="nc" id="L608">                pstate.field = field;</span>

<span class="nc" id="L610">                owner = pstate.field.getDefiningMapping();</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                if (pstate.field.getManagement()</span>
                    != FieldMetaData.MANAGE_PERSISTENT)
<span class="nc" id="L613">                    throw new UserException(_loc.get(&quot;non-pers-field&quot;,</span>
                        pstate.field));

                // find the most-derived type between the declared relation
                // type and the field's owner, and join from that type to
                // the lesser derived type
<span class="nc bnc" id="L619" title="All 4 branches missed.">                if (rel != owner &amp;&amp; rel != null) {</span>
<span class="nc" id="L620">                    if (rel.getDescribedType().isAssignableFrom</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                        (owner.getDescribedType())) {</span>
<span class="nc" id="L622">                        from = owner;</span>
<span class="nc" id="L623">                        to = rel;</span>
                    } else {
<span class="nc" id="L625">                        from = rel;</span>
<span class="nc" id="L626">                        to = owner;</span>
                    }

<span class="nc bnc" id="L629" title="All 4 branches missed.">                    for (; from != null &amp;&amp; from != to;</span>
<span class="nc" id="L630">                        from = from.getJoinablePCSuperclassMapping()) {</span>
<span class="nc" id="L631">                    	FieldMapping cast = from.getFieldMapping(pstate.field</span>
<span class="nc" id="L632">                    			.getName());</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                    	if (cast != null)</span>
<span class="nc" id="L634">                    		pstate.field = cast;</span>
<span class="nc" id="L635">                        pstate.joins = from.joinSuperclass(pstate.joins, false);</span>
                    }
                }
                // nothing more to do from here on as we encountered an xpath
                // action
<span class="nc bnc" id="L640" title="All 2 branches missed.">                if (action.op == Action.GET_XPATH)</span>
<span class="nc" id="L641">                    break;</span>
            }
<span class="nc" id="L643">            prevaction = action;</span>
<span class="nc bnc" id="L644" title="All 4 branches missed.">            if (prevaction != null &amp;&amp; prevaction.context != null) {</span>
<span class="nc" id="L645">                Context jCtx = JDBCStoreQuery.getThreadLocalContext(prevaction.context);</span>
<span class="nc" id="L646">                pstate.joins = pstate.joins.setJoinContext(jCtx);</span>
<span class="nc" id="L647">            }</span>
        }
<span class="nc bnc" id="L649" title="All 2 branches missed.">        if (_varName != null)</span>
<span class="nc" id="L650">            pstate.joins = pstate.joins.setVariable(_varName);</span>

        // if we're not comparing to null or doing an isEmpty, then
        // join into the data on the final field; obviously we can't do these
        // joins when comparing to null b/c the whole purpose is to see
        // whether the joins even exist
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if ((flags &amp; NULL_CMP) == 0)</span>
<span class="nc" id="L657">            traverseField(pstate, key, forceOuter, true);</span>
<span class="nc" id="L658">        pstate.joinedRel = false;</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if ((flags &amp; JOIN_REL) != 0)</span>
<span class="nc bnc" id="L660" title="All 4 branches missed.">            joinRelation(pstate, key, forceOuter || (flags &amp; FORCE_OUTER) != 0,</span>
                false);
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (isCorrelatedPath) {</span>
            // check if there are joins that belong to parent
<span class="nc" id="L664">            pstate.joins.moveJoinsToParent();</span>
        }
<span class="nc" id="L666">        pstate.joins.setJoinContext(null);</span>

<span class="nc bnc" id="L668" title="All 2 branches missed.">        if (_actions == null) {</span>
<span class="nc" id="L669">            String subqAlias = findSubqAlias(sel);</span>
<span class="nc" id="L670">            pstate.joins = pstate.joins.setSubselect(subqAlias);</span>
<span class="nc" id="L671">            pstate.joins.setCorrelatedVariable(_schemaAlias);</span>
<span class="nc" id="L672">            checkObjectPathInheritanceTypeJoined(pstate);</span>
        }

<span class="nc" id="L675">        return pstate;</span>
    }

    private String findSubqAlias(Select sel) {
<span class="nc" id="L679">        Select pSel = sel.getParent();</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (pSel == null)</span>
<span class="nc" id="L681">            return null;</span>
<span class="nc" id="L682">        Context pCtx = pSel.ctx();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (pCtx.subquery == null)</span>
<span class="nc" id="L684">            return null;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">        if (pCtx.getSchema(_schemaAlias) != null)</span>
<span class="nc" id="L686">            return ((SubQ)pCtx.subquery).getCandidateAlias();</span>
<span class="nc" id="L687">        return findSubqAlias(pSel);</span>
    }

    /**
     * When a PCPath is in subselect, and it is simply a navigation
     * from the parent root, the joins involved in this PCPath
     * must happen in the main select.
     */
    private boolean navigateFromParentRootInSubselect(Select sel) {
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (sel.getParent() == null)</span>
<span class="nc" id="L697">            return false;</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        Iterator itr = (_actions == null) ? null : _actions.iterator();</span>

<span class="nc" id="L700">        boolean hasVar = false;</span>
<span class="nc" id="L701">        boolean startsWithSubquery = false;</span>
<span class="nc bnc" id="L702" title="All 4 branches missed.">        while (itr != null &amp;&amp; itr.hasNext()) {</span>
<span class="nc" id="L703">            Action action = (Action) itr.next();</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (action.op == Action.VAR)</span>
<span class="nc" id="L705">                hasVar = true;</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            else if (action.op == Action.SUBQUERY)</span>
<span class="nc" id="L707">                startsWithSubquery = true;</span>
<span class="nc" id="L708">        }</span>
<span class="nc bnc" id="L709" title="All 6 branches missed.">        return !hasVar &amp;&amp; !startsWithSubquery &amp;&amp; sel.ctx().getSchema(_schemaAlias) == null;</span>
    }

    /**
     * Return whether the given source field joins to the given target field.
     */
    private static boolean isJoinedField(FieldMapping src, boolean key,
        FieldMapping target) {
        ValueMapping vm;
<span class="nc bnc" id="L718" title="All 3 branches missed.">        switch (src.getTypeCode()) {</span>
            case JavaTypes.ARRAY:
            case JavaTypes.COLLECTION:
<span class="nc" id="L721">                vm = src.getElementMapping();</span>
<span class="nc" id="L722">                break;</span>
            case JavaTypes.MAP:
<span class="nc bnc" id="L724" title="All 2 branches missed.">                vm = (key) ? src.getKeyMapping() : src.getElementMapping();</span>
<span class="nc" id="L725">                break;</span>
            default:
<span class="nc" id="L727">                vm = src;</span>
        }
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (vm.getJoinDirection() != ValueMapping.JOIN_FORWARD)</span>
<span class="nc" id="L730">            return false;</span>
<span class="nc" id="L731">        ForeignKey fk = vm.getForeignKey();</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">        if (fk == null)</span>
<span class="nc" id="L733">            return false;</span>

        // foreign key must join to target columns
<span class="nc" id="L736">        Column[] rels = fk.getColumns();</span>
<span class="nc" id="L737">        Column[] pks = target.getColumns();</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (rels.length != pks.length)</span>
<span class="nc" id="L739">            return false;</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">        for (int i = 0; i &lt; rels.length; i++)</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">            if (fk.getPrimaryKeyColumn(rels[i]) != pks[i])</span>
<span class="nc" id="L742">                return false;</span>
<span class="nc" id="L743">        return true;</span>
    }

    @Override
    protected Object eval(Object candidate, Object orig,
        StoreContext ctx, Object[] params) {
<span class="nc bnc" id="L749" title="All 2 branches missed.">        if (_actions == null)</span>
<span class="nc" id="L750">            return candidate;</span>

        Action action;
        OpenJPAStateManager sm;
        Broker tmpBroker;
<span class="nc bnc" id="L755" title="All 2 branches missed.">        for (Iterator itr = _actions.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L756">            action = (Action)itr.next();</span>
<span class="nc" id="L757">            sm = null;</span>
<span class="nc" id="L758">            tmpBroker = null;</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">            if (ImplHelper.isManageable(candidate))</span>
<span class="nc" id="L760">                sm = (OpenJPAStateManager) (ImplHelper.toPersistenceCapable(</span>
<span class="nc" id="L761">                    candidate, ctx.getConfiguration())).</span>
<span class="nc" id="L762">                    pcGetStateManager();</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            if (sm == null) {</span>
<span class="nc" id="L764">                tmpBroker = ctx.getBroker();</span>
<span class="nc" id="L765">                tmpBroker.transactional(candidate, false, null);</span>
<span class="nc" id="L766">                sm = tmpBroker.getStateManager(candidate);</span>
            }
<span class="nc bnc" id="L768" title="All 4 branches missed.">            if (action.op != Action.GET &amp;&amp; action.op != Action.GET_OUTER)</span>
<span class="nc" id="L769">                continue;</span>
            try {
<span class="nc" id="L771">                candidate = sm.fetchField(</span>
<span class="nc" id="L772">                        ((FieldMapping)action.data).getIndex(), true);</span>
<span class="nc" id="L773">            } catch (ClassCastException cce) {</span>
<span class="nc" id="L774">                throw new RuntimeException(action.data + &quot; not a field path&quot;);</span>
            } finally {
                // transactional does not clear the state, which is
                // important since tmpCandidate might be also managed by
                // another broker if it's a proxied non-pc instance
<span class="nc bnc" id="L779" title="All 2 branches missed.">                if (tmpBroker != null)</span>
<span class="nc" id="L780">                    tmpBroker.nontransactional(sm.getManagedInstance(), null);</span>
<span class="nc" id="L781">            }</span>
        }
<span class="nc" id="L783">        return candidate;</span>
    }

    /**
     * Expression state.
     */
    public static class PathExpState
        extends ExpState {

<span class="nc" id="L792">        public FieldMapping field = null;</span>
<span class="nc" id="L793">        public FieldMapping cmpfield = null;</span>
<span class="nc" id="L794">        public Column[] cols = null;</span>
<span class="nc" id="L795">        public boolean joinedRel = false;</span>
<span class="nc" id="L796">        public boolean isEmbedElementColl = false;</span>

        public PathExpState(Joins joins) {
<span class="nc" id="L799">            super(joins);</span>
<span class="nc" id="L800">        }</span>
    }

    /**
     * Traverse into the previous field of a relation path.
     *
     * @param last whether this is the last field in the path
     * @return the mapping of the related type, or null
     */
    private ClassMapping traverseField(PathExpState pstate, boolean key,
        boolean forceOuter, boolean last) {
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (pstate.field == null)</span>
<span class="nc" id="L812">            return null;</span>

        // traverse into field value
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if (key)</span>
<span class="nc" id="L816">            pstate.joins = pstate.field.joinKey(pstate.joins, forceOuter);</span>
        else
<span class="nc" id="L818">            pstate.joins = pstate.field.join(pstate.joins, forceOuter);</span>

        // if this isn't the last field, traverse into the relation
<span class="nc bnc" id="L821" title="All 2 branches missed.">        if (!last)</span>
<span class="nc" id="L822">            joinRelation(pstate, key, forceOuter, true);</span>

        // return the maping of the related type, if any
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (key)</span>
<span class="nc" id="L826">            return pstate.field.getKeyMapping().getTypeMapping();</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (pstate.field.getElement().getTypeCode() == JavaTypes.PC)</span>
<span class="nc" id="L828">            return pstate.field.getElementMapping().getTypeMapping();</span>
<span class="nc" id="L829">        return pstate.field.getTypeMapping();</span>
    }

    /**
     * Join into the relation represented by the current field, if any.
     */
    private void joinRelation(PathExpState pstate, boolean key,
        boolean forceOuter, boolean traverse) {
<span class="nc bnc" id="L837" title="All 2 branches missed.">        if (pstate.field == null)</span>
<span class="nc" id="L838">            return;</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">        if (key)</span>
<span class="nc" id="L840">            pstate.joins = pstate.field.joinKeyRelation(pstate.joins,</span>
                forceOuter, traverse);
        else
<span class="nc" id="L843">            pstate.joins = pstate.field.joinRelation(pstate.joins, forceOuter,</span>
                traverse);
<span class="nc" id="L845">        pstate.joinedRel = true;</span>
<span class="nc" id="L846">    }</span>

    @Override
    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state,
        Object val) {
<span class="nc" id="L851">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">        FieldMapping field = (pstate.cmpfield != null) ? pstate.cmpfield</span>
<span class="nc" id="L853">            : pstate.field;</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">        if (isXPath())</span>
<span class="nc" id="L855">            return val;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">        if (field != null) {</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            if (_key)</span>
<span class="nc" id="L858">                return field.toKeyDataStoreValue(val, ctx.store);</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (field.getElement().getDeclaredTypeCode() != JavaTypes.OBJECT)</span>
<span class="nc" id="L860">                return field.toDataStoreValue(val, ctx.store);</span>

<span class="nc" id="L862">            val = field.getExternalValue(val, ctx.store.getContext());</span>
<span class="nc" id="L863">            return field.toDataStoreValue(val, ctx.store);</span>
        }
<span class="nc" id="L865">        return _class.toDataStoreValue(val, _class.getPrimaryKeyColumns(),</span>
            ctx.store);
    }

    @Override
    public void select(Select sel, ExpContext ctx, ExpState state,
        boolean pks) {
<span class="nc" id="L872">        selectColumns(sel, ctx, state, pks);</span>
<span class="nc" id="L873">    }</span>

    @Override
    public void selectColumns(Select sel, ExpContext ctx, ExpState state,
        boolean pks) {
<span class="nc" id="L878">        sel.setSchemaAlias(_schemaAlias);</span>
<span class="nc" id="L879">        ClassMapping mapping = getClassMapping(state);</span>
<span class="nc" id="L880">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L881" title="All 8 branches missed.">        if (_type != OBJECT_PATH &amp;&amp; (mapping == null || !pstate.joinedRel ||</span>
            pstate.isEmbedElementColl))
<span class="nc" id="L883">            sel.select(getColumns(state), pstate.joins);</span>
<span class="nc bnc" id="L884" title="All 4 branches missed.">        else if (_key &amp;&amp; pstate.field.getKey().isEmbedded())</span>
<span class="nc" id="L885">            selectEmbeddedMapKey(sel, ctx, state);</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">        else if (pks)</span>
<span class="nc" id="L887">            sel.select(mapping.getPrimaryKeyColumns(), pstate.joins);</span>
        else {
            // select the mapping; allow any subs because we know this must
            // be either a relation, in which case it will already be
            // constrained by the joins, or 'this', in which case the
            // JDBCExpressionFactory takes care of adding class conditions for
            // the candidate class on the select
<span class="nc bnc" id="L894" title="All 2 branches missed.">            int subs = (_type == UNBOUND_VAR) ? Select.SUBS_JOINABLE</span>
<span class="nc" id="L895">                : Select.SUBS_ANY_JOINABLE;</span>
<span class="nc" id="L896">            sel.select(mapping, subs, ctx.store, ctx.fetch,</span>
<span class="nc" id="L897">                EagerFetchModes.EAGER_NONE, sel.outer(pstate.joins));</span>
        }
<span class="nc" id="L899">    }</span>

    @Override
    public void groupBy(Select sel, ExpContext ctx, ExpState state) {
<span class="nc" id="L903">        ClassMapping mapping = getClassMapping(state);</span>
<span class="nc" id="L904">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L905" title="All 4 branches missed.">        if (mapping == null || !pstate.joinedRel)</span>
<span class="nc" id="L906">            sel.groupBy(getColumns(state), sel.outer(pstate.joins));</span>
        else {
<span class="nc bnc" id="L908" title="All 2 branches missed.">            int subs = (_type == UNBOUND_VAR) ? Select.SUBS_JOINABLE</span>
<span class="nc" id="L909">                : Select.SUBS_ANY_JOINABLE;</span>
<span class="nc" id="L910">            sel.groupBy(mapping, subs, ctx.store, ctx.fetch,</span>
<span class="nc" id="L911">                sel.outer(pstate.joins));</span>
        }
<span class="nc" id="L913">    }</span>

    @Override
    public void orderBy(Select sel, ExpContext ctx, ExpState state,
        boolean asc) {
<span class="nc" id="L918">        sel.orderBy(getColumns(state), asc, sel.outer(state.joins), false);</span>
<span class="nc" id="L919">    }</span>

    @Override
    public Object load(ExpContext ctx, ExpState state, Result res)
        throws SQLException {
<span class="nc" id="L924">        return load(ctx, state, res, false);</span>
    }

    Object load(ExpContext ctx, ExpState state, Result res, boolean pks)
        throws SQLException {
<span class="nc" id="L929">        ClassMapping mapping = getClassMapping(state);</span>
<span class="nc" id="L930">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L931" title="All 4 branches missed.">        if (mapping != null &amp;&amp; (pstate.field == null</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            || !pstate.field.isEmbedded())) {</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">            if (pks)</span>
<span class="nc" id="L934">                return mapping.getObjectId(ctx.store, res, null, true,</span>
                    pstate.joins);
<span class="nc bnc" id="L936" title="All 4 branches missed.">            if (_key &amp;&amp; pstate.field.getKey().isEmbedded())</span>
<span class="nc" id="L937">                return loadEmbeddedMapKey(ctx, state, res);</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">            if (pstate.isEmbedElementColl)</span>
<span class="nc" id="L939">                return pstate.field.loadProjection(ctx.store, ctx.fetch, res,</span>
                    pstate.joins);
<span class="nc" id="L941">            return res.load(mapping, ctx.store, ctx.fetch, pstate.joins);</span>
        }

        Object ret;
<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (_key) {</span>
            // Map key is a java primitive type
            // example: Map&lt;Integer, Employee&gt; emps
<span class="nc" id="L948">            ret = res.getObject(pstate.cols[0], null, pstate.joins);</span>
        } else {
<span class="nc" id="L950">            ret = pstate.field.loadProjection(ctx.store, ctx.fetch, res, pstate.joins);</span>
        }

<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (pstate.field.isExternalized()) {</span>
<span class="nc" id="L954">            ret = pstate.field.getFieldValue(ret, ctx.store.getContext());</span>
        }

<span class="nc bnc" id="L957" title="All 2 branches missed.">        if (_cast != null)</span>
<span class="nc" id="L958">            ret = Filters.convert(ret, _cast);</span>
<span class="nc" id="L959">        return ret;</span>
    }

    private void validateMapStrategy(Strategy strategy) {
<span class="nc bnc" id="L963" title="All 4 branches missed.">        if (strategy == null ||</span>
            !(strategy instanceof LRSMapFieldStrategy))
<span class="nc" id="L965">            throw new RuntimeException(&quot;Invalid map field strategy:&quot;+strategy);</span>
<span class="nc" id="L966">    }</span>

    private void selectEmbeddedMapKey(Select sel, ExpContext ctx,
        ExpState state) {
<span class="nc" id="L970">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc" id="L971">        validateMapStrategy(pstate.field.getStrategy());</span>
<span class="nc" id="L972">        LRSMapFieldStrategy strategy = (LRSMapFieldStrategy)</span>
<span class="nc" id="L973">            pstate.field.getStrategy();</span>
<span class="nc" id="L974">        ClassMapping mapping = pstate.field.getKeyMapping().getTypeMapping();</span>
<span class="nc" id="L975">        strategy.selectKey(sel, mapping, null, ctx.store, ctx.fetch,</span>
            pstate.joins);
<span class="nc" id="L977">    }</span>

    private Object loadEmbeddedMapKey(ExpContext ctx, ExpState state,
        Result res) throws SQLException {
<span class="nc" id="L981">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc" id="L982">        validateMapStrategy(pstate.field.getStrategy());</span>
<span class="nc" id="L983">        LRSMapFieldStrategy strategy =</span>
<span class="nc" id="L984">            (LRSMapFieldStrategy) pstate.field.getStrategy();</span>
<span class="nc" id="L985">        return strategy.loadKey(null, ctx.store, ctx.fetch, res,</span>
            pstate.joins);
    }

    @Override
    public void calculateValue(Select sel, ExpContext ctx, ExpState state,
        Val other, ExpState otherState) {
        // we don't create the SQL b/c it forces the Select to cache aliases
        // for the tables we use, and these aliases might not ever be used if
        // we eventually call appendIsEmpty or appendIsNull rather than appendTo
<span class="nc" id="L995">    }</span>

    public void verifyIndexedField() {
<span class="nc" id="L998">        Action lastAction = (Action) lastFieldAction();</span>
<span class="nc" id="L999">        FieldMapping fm = (FieldMapping) lastAction.data;</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">        if (fm.getOrderColumn() == null)</span>
<span class="nc" id="L1001">            throw new UserException(_loc.get(&quot;no-order-column&quot;, fm.getName()));</span>
<span class="nc" id="L1002">    }</span>

    @Override
    public int length(Select sel, ExpContext ctx, ExpState state) {
<span class="nc" id="L1006">        return getColumns(state).length;</span>
    }

    public void appendTo(Select sel, ExpContext ctx, ExpState state,
        SQLBuffer sql) {
<span class="nc" id="L1011">        Column[] cols = getColumns(state);</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">        for (int i = 0; i &lt; cols.length; i++) {</span>
<span class="nc" id="L1013">            appendTo(sel, state, sql, cols[i]);</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            if (i &lt; cols.length -1)</span>
<span class="nc" id="L1015">            sql.append(&quot;, &quot;);</span>
        }
<span class="nc" id="L1017">    }</span>

    @Override
    public void appendTo(Select sel, ExpContext ctx, ExpState state,
        SQLBuffer sql, int index) {
<span class="nc" id="L1022">        Column col = getColumns(state)[index];</span>
<span class="nc" id="L1023">        appendTo(sel, state, sql, col);</span>
<span class="nc" id="L1024">    }</span>

    public void appendTo(Select sel, ExpState state, SQLBuffer sql, Column col) {
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        if (sel != null)</span>
<span class="nc" id="L1028">            sel.setSchemaAlias(_schemaAlias);</span>

        // if select is null, it means we are not aliasing columns
        // (e.g., during a bulk update)
<span class="nc bnc" id="L1032" title="All 2 branches missed.">        if (sel == null)</span>
<span class="nc" id="L1033">            sql.append(col.getIdentifier());</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">        else if (_type == XPATH)</span>
            // if this is an xpath, append xpath string
<span class="nc" id="L1036">            sql.append(getXPath());</span>
        else
<span class="nc" id="L1038">            sql.append(sel.getColumnAlias(col, state.joins));</span>
<span class="nc" id="L1039">    }</span>

    @Override
    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state,
        SQLBuffer sql) {
<span class="nc" id="L1044">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">        if (pstate.field == null)</span>
<span class="nc" id="L1046">            sql.append(FALSE);</span>
        else
<span class="nc" id="L1048">            pstate.field.appendIsEmpty(sql, sel, pstate.joins);</span>
<span class="nc" id="L1049">    }</span>

    @Override
    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state,
        SQLBuffer sql) {
<span class="nc" id="L1054">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">        if (pstate.field == null)</span>
<span class="nc" id="L1056">            sql.append(FALSE);</span>
        else
<span class="nc" id="L1058">            pstate.field.appendIsNotEmpty(sql, sel, pstate.joins);</span>
<span class="nc" id="L1059">    }</span>

    @Override
    public void appendIndex(Select sel, ExpContext ctx, ExpState state,
        SQLBuffer sql) {
<span class="nc" id="L1064">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if (pstate.field == null)</span>
<span class="nc" id="L1066">            sql.append(&quot;1&quot;);</span>
        else
<span class="nc" id="L1068">            pstate.field.appendIndex(sql, sel, pstate.joins);</span>
<span class="nc" id="L1069">    }</span>

    @Override
    public void appendType(Select sel, ExpContext ctx, ExpState state,
        SQLBuffer sql) {
<span class="nc" id="L1074">        Discriminator disc = null;</span>
<span class="nc" id="L1075">        ClassMapping sup = _class;</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        while (sup.getMappedPCSuperclassMapping() != null)</span>
<span class="nc" id="L1077">            sup = sup.getMappedPCSuperclassMapping();</span>

<span class="nc" id="L1079">        disc = sup.getDiscriminator();</span>

<span class="nc" id="L1081">        Column[] cols = null;</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">        if (disc != null)</span>
<span class="nc" id="L1083">            cols = disc.getColumns();</span>
        else
<span class="nc" id="L1085">            cols = getColumns(state);</span>

<span class="nc bnc" id="L1087" title="All 4 branches missed.">        if (cols == null || cols.length == 0) {</span>
<span class="nc" id="L1088">            sql.append(&quot;1&quot;);</span>
<span class="nc" id="L1089">            return;</span>
        }

<span class="nc bnc" id="L1092" title="All 2 branches missed.">        for (int i = 0; i &lt; cols.length; i++) {</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">            if (i &gt; 0)</span>
<span class="nc" id="L1094">                sql.append(&quot;, &quot;);</span>
<span class="nc" id="L1095">            sql.append(sel.getColumnAlias(cols[i], state.joins));</span>
        }
<span class="nc" id="L1097">    }</span>

    @Override
    public void appendSize(Select sel, ExpContext ctx, ExpState state,
        SQLBuffer sql) {
<span class="nc" id="L1102">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (pstate.field == null)</span>
<span class="nc" id="L1104">            sql.append(&quot;1&quot;);</span>
        else
<span class="nc" id="L1106">            pstate.field.appendSize(sql, sel, pstate.joins);</span>
<span class="nc" id="L1107">    }</span>

    @Override
    public void appendIsNull(Select sel, ExpContext ctx, ExpState state,
        SQLBuffer sql) {
<span class="nc" id="L1112">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">        if (pstate.field == null)</span>
<span class="nc" id="L1114">            sql.append(FALSE);</span>
        else
<span class="nc" id="L1116">            pstate.field.appendIsNull(sql, sel, pstate.joins);</span>
<span class="nc" id="L1117">    }</span>

    @Override
    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state,
        SQLBuffer sql) {
<span class="nc" id="L1122">        PathExpState pstate = (PathExpState) state;</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (pstate.field == null)</span>
<span class="nc" id="L1124">            sql.append(TRUE);</span>
        else
<span class="nc" id="L1126">            pstate.field.appendIsNotNull(sql, sel, pstate.joins);</span>
<span class="nc" id="L1127">    }</span>

    public boolean isSubqueryPath() {
<span class="nc bnc" id="L1130" title="All 4 branches missed.">        if (_actions != null &amp;&amp; _actions.size() == 1 &amp;&amp;</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">           ((Action)_actions.get(0)).op == Action.SUBQUERY)</span>
<span class="nc" id="L1132">            return true;</span>
<span class="nc" id="L1133">        return false;</span>
    }

    @Override
    public int hashCode() {
<span class="nc bnc" id="L1138" title="All 2 branches missed.">        if (_actions == null)</span>
<span class="nc" id="L1139">            return _candidate.hashCode();</span>
<span class="nc" id="L1140">        return _candidate.hashCode() ^ _actions.hashCode();</span>
    }

    @Override
    public boolean equals(Object other) {
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        if (other == this)</span>
<span class="nc" id="L1146">            return true;</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if (!(other instanceof PCPath))</span>
<span class="nc" id="L1148">            return false;</span>
<span class="nc" id="L1149">        PCPath path = (PCPath) other;</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        return Objects.equals(_candidate, path._candidate)</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">            &amp;&amp; Objects.equals(_actions, path._actions);</span>
    }

    @Override
    public int getId() {
<span class="nc" id="L1156">        return Val.VAL;</span>
    }


    /**
     * Helper class representing an action.
     */
<span class="nc" id="L1163">    private static class Action</span>
        implements Serializable {

        
        private static final long serialVersionUID = 1L;
        public static final int GET = 0;
        public static final int GET_OUTER = 1;
        public static final int GET_KEY = 2;
        public static final int VAR = 3;
        public static final int SUBQUERY = 4;
        public static final int UNBOUND_VAR = 5;
        public static final int CAST = 6;
        public static final int GET_XPATH = 7;

<span class="nc" id="L1177">        public int op = -1;</span>
<span class="nc" id="L1178">        public Object data = null;</span>
<span class="nc" id="L1179">        public String var = null;</span>
<span class="nc" id="L1180">        public Context context = null;</span>

        @Override
        public String toString() {
<span class="nc" id="L1184">            return op + &quot;|&quot; + data;</span>
        }

        @Override
        public int hashCode() {
<span class="nc bnc" id="L1189" title="All 2 branches missed.">            if (data == null)</span>
<span class="nc" id="L1190">                return op;</span>
<span class="nc" id="L1191">            return op ^ data.hashCode();</span>
        }

        @Override
        public boolean equals(Object other) {
<span class="nc bnc" id="L1196" title="All 2 branches missed.">            if (other == null)</span>
<span class="nc" id="L1197">                return false;</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">            if (other == this)</span>
<span class="nc" id="L1199">                return true;</span>
<span class="nc" id="L1200">            Action a = (Action) other;</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">            return op == a.op</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">                &amp;&amp; Objects.equals(data, a.data);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>