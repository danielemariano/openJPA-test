<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DBDictionary.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-jdbc</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.jdbc.sql</a> &gt; <span class="el_source">DBDictionary.java</span></div><h1>DBDictionary.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.jdbc.sql;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.CharArrayReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.Writer;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.text.MessageFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import javax.sql.DataSource;

import org.apache.openjpa.jdbc.conf.JDBCConfiguration;
import org.apache.openjpa.jdbc.identifier.ColumnDefIdentifierRule;
import org.apache.openjpa.jdbc.identifier.DBIdentifier;
import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;
import org.apache.openjpa.jdbc.identifier.DBIdentifierRule;
import org.apache.openjpa.jdbc.identifier.DBIdentifierUtil;
import org.apache.openjpa.jdbc.identifier.Normalizer;
import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;
import org.apache.openjpa.jdbc.kernel.JDBCStore;
import org.apache.openjpa.jdbc.kernel.exps.ExpContext;
import org.apache.openjpa.jdbc.kernel.exps.ExpState;
import org.apache.openjpa.jdbc.kernel.exps.FilterValue;
import org.apache.openjpa.jdbc.kernel.exps.Null;
import org.apache.openjpa.jdbc.kernel.exps.Val;
import org.apache.openjpa.jdbc.meta.ClassMapping;
import org.apache.openjpa.jdbc.meta.FieldMapping;
import org.apache.openjpa.jdbc.meta.JavaSQLTypes;
import org.apache.openjpa.jdbc.schema.Column;
import org.apache.openjpa.jdbc.schema.DataSourceFactory;
import org.apache.openjpa.jdbc.schema.ForeignKey;
import org.apache.openjpa.jdbc.schema.ForeignKey.FKMapKey;
import org.apache.openjpa.jdbc.schema.Index;
import org.apache.openjpa.jdbc.schema.NameSet;
import org.apache.openjpa.jdbc.schema.PrimaryKey;
import org.apache.openjpa.jdbc.schema.Schema;
import org.apache.openjpa.jdbc.schema.SchemaGroup;
import org.apache.openjpa.jdbc.schema.Sequence;
import org.apache.openjpa.jdbc.schema.Table;
import org.apache.openjpa.jdbc.schema.Unique;
import org.apache.openjpa.kernel.Filters;
import org.apache.openjpa.kernel.OpenJPAStateManager;
import org.apache.openjpa.kernel.Seq;
import org.apache.openjpa.kernel.StateManagerImpl;
import org.apache.openjpa.kernel.exps.Path;
import org.apache.openjpa.lib.conf.Configurable;
import org.apache.openjpa.lib.conf.Configuration;
import org.apache.openjpa.lib.identifier.IdentifierConfiguration;
import org.apache.openjpa.lib.identifier.IdentifierRule;
import org.apache.openjpa.lib.identifier.IdentifierUtil;
import org.apache.openjpa.lib.jdbc.ConnectionDecorator;
import org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator;
import org.apache.openjpa.lib.log.Log;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.Localizer.Message;
import org.apache.openjpa.lib.util.StringUtil;
import org.apache.openjpa.meta.FieldMetaData;
import org.apache.openjpa.meta.JavaTypes;
import org.apache.openjpa.meta.ValueStrategies;
import org.apache.openjpa.util.ExceptionInfo;
import org.apache.openjpa.util.GeneralException;
import org.apache.openjpa.util.InternalException;
import org.apache.openjpa.util.InvalidStateException;
import org.apache.openjpa.util.LockException;
import org.apache.openjpa.util.ObjectExistsException;
import org.apache.openjpa.util.ObjectNotFoundException;
import org.apache.openjpa.util.OpenJPAException;
import org.apache.openjpa.util.OptimisticException;
import org.apache.openjpa.util.ProxyManager;
import org.apache.openjpa.util.QueryException;
import org.apache.openjpa.util.ReferentialIntegrityException;
import org.apache.openjpa.util.Serialization;
import org.apache.openjpa.util.StoreException;
import org.apache.openjpa.util.UnsupportedException;
import org.apache.openjpa.util.UserException;

import static java.util.Locale.ROOT;


/**
 * Class which allows the creation of SQL dynamically, in a
 * database agnostic fashion. Subclass for the nuances of different data stores.
 */
public class DBDictionary
    implements Configurable, ConnectionDecorator, JoinSyntaxes,
    LoggingConnectionDecorator.SQLWarningHandler, IdentifierConfiguration {

    public static final String VENDOR_OTHER      = &quot;other&quot;;
    public static final String VENDOR_DATADIRECT = &quot;datadirect&quot;;

    public static final String SCHEMA_CASE_UPPER     = IdentifierUtil.CASE_UPPER;
    public static final String SCHEMA_CASE_LOWER     = IdentifierUtil.CASE_LOWER;
    public static final String SCHEMA_CASE_PRESERVE  = IdentifierUtil.CASE_PRESERVE;

    public static final String CONS_NAME_BEFORE = &quot;before&quot;;
    public static final String CONS_NAME_MID    = &quot;mid&quot;;
    public static final String CONS_NAME_AFTER  = &quot;after&quot;;

<span class="nc" id="L160">    public int blobBufferSize = 50000;</span>
<span class="nc" id="L161">    public int clobBufferSize = 50000;</span>

    protected static final int RANGE_POST_SELECT   = 0;
    protected static final int RANGE_PRE_DISTINCT  = 1;
    protected static final int RANGE_POST_DISTINCT = 2;
    protected static final int RANGE_POST_LOCK     = 3;

    protected static final int NANO  = 1;
    protected static final int MICRO = NANO * 1000;
    protected static final int MILLI = MICRO * 1000;
    protected static final int CENTI = MILLI * 10;
    protected static final int DECI  = MILLI * 100;
    protected static final int SEC   = MILLI * 1000;

    protected static final int NAME_ANY      = DBIdentifierUtil.ANY;
    protected static final int NAME_TABLE    = DBIdentifierUtil.TABLE;
    protected static final int NAME_SEQUENCE = DBIdentifierUtil.SEQUENCE;

    protected static final int UNLIMITED = -1;
    protected static final int NO_BATCH = 0;

<span class="nc" id="L182">    private static final String ZERO_DATE_STR      = &quot;'&quot; + new java.sql.Date(0) + &quot;'&quot;;</span>
<span class="nc" id="L183">    private static final String ZERO_TIME_STR      = &quot;'&quot; + new Time(0) + &quot;'&quot;;</span>
<span class="nc" id="L184">    private static final String ZERO_TIMESTAMP_STR = &quot;'&quot; + new Timestamp(0) + &quot;'&quot;;</span>

<span class="nc" id="L186">    private static final Localizer _loc = Localizer.forPackage(DBDictionary.class);</span>

    // Database version info preferably set from Connection metadata
    private int major;
    private int minor;

    // schema data
<span class="nc" id="L193">    public String platform = &quot;Generic&quot;;</span>
<span class="nc" id="L194">    public String databaseProductName = &quot;&quot;;</span>
<span class="nc" id="L195">    public String databaseProductVersion = &quot;&quot;;</span>
<span class="nc" id="L196">    public String driverVendor = null;</span>
<span class="nc" id="L197">    public boolean createPrimaryKeys = true;</span>
<span class="nc" id="L198">    public String constraintNameMode = CONS_NAME_BEFORE;</span>
<span class="nc" id="L199">    public int maxTableNameLength = 128;</span>
<span class="nc" id="L200">    public int maxColumnNameLength = 128;</span>
<span class="nc" id="L201">    public int maxConstraintNameLength = 128;</span>
<span class="nc" id="L202">    public int maxIndexNameLength = 128;</span>
<span class="nc" id="L203">    public int maxIndexesPerTable = Integer.MAX_VALUE;</span>
<span class="nc" id="L204">    public boolean supportsForeignKeys = true;</span>
<span class="nc" id="L205">    public boolean supportsParameterInSelect = true;</span>
<span class="nc" id="L206">    public boolean supportsForeignKeysComposite = true;</span>
<span class="nc" id="L207">    public boolean supportsUniqueConstraints = true;</span>
<span class="nc" id="L208">    public boolean supportsDeferredConstraints = true;</span>
<span class="nc" id="L209">    public boolean supportsRestrictDeleteAction = true;</span>
<span class="nc" id="L210">    public boolean supportsCascadeDeleteAction = true;</span>
<span class="nc" id="L211">    public boolean supportsNullDeleteAction = true;</span>
<span class="nc" id="L212">    public boolean supportsNullUniqueColumn = true;</span>
<span class="nc" id="L213">    public boolean supportsDefaultDeleteAction = true;</span>
<span class="nc" id="L214">    public boolean supportsRestrictUpdateAction = true;</span>
<span class="nc" id="L215">    public boolean supportsCascadeUpdateAction = true;</span>
<span class="nc" id="L216">    public boolean supportsNullUpdateAction = true;</span>
<span class="nc" id="L217">    public boolean supportsDefaultUpdateAction = true;</span>
<span class="nc" id="L218">    public boolean supportsAlterTableWithAddColumn = true;</span>
<span class="nc" id="L219">    public boolean supportsAlterTableWithDropColumn = true;</span>
<span class="nc" id="L220">    public boolean supportsComments = false;</span>
<span class="nc" id="L221">    public Boolean supportsGetGeneratedKeys = null;</span>
<span class="nc" id="L222">    public String reservedWords = null;</span>
<span class="nc" id="L223">    public String systemSchemas = null;</span>
<span class="nc" id="L224">    public String systemTables = null;</span>
<span class="nc" id="L225">    public String selectWords = null;</span>
<span class="nc" id="L226">    public String fixedSizeTypeNames = null;</span>
<span class="nc" id="L227">    public String schemaCase = SCHEMA_CASE_UPPER;</span>
    public String javaToDbColumnNameProcessing;
<span class="nc" id="L229">    public boolean setStringRightTruncationOn = true;</span>
<span class="nc" id="L230">    public boolean fullResultCollectionInOrderByRelation = false;</span>
<span class="nc" id="L231">    public boolean disableSchemaFactoryColumnTypeErrors = false; //OPENJPA-2627</span>

    // sql
<span class="nc" id="L234">    public boolean disableAlterSeqenceIncrementBy=false;</span>
<span class="nc" id="L235">    public String validationSQL = null;</span>
<span class="nc" id="L236">    public String closePoolSQL = null;</span>
<span class="nc" id="L237">    public String initializationSQL = null;</span>
<span class="nc" id="L238">    public int joinSyntax = SYNTAX_SQL92;</span>
<span class="nc" id="L239">    public String outerJoinClause = &quot;LEFT OUTER JOIN&quot;;</span>
<span class="nc" id="L240">    public String innerJoinClause = &quot;INNER JOIN&quot;;</span>
<span class="nc" id="L241">    public String crossJoinClause = &quot;CROSS JOIN&quot;;</span>
<span class="nc" id="L242">    public boolean requiresConditionForCrossJoin = false;</span>
<span class="nc" id="L243">    public String forUpdateClause = &quot;FOR UPDATE&quot;;</span>
<span class="nc" id="L244">    public String tableForUpdateClause = null;</span>
<span class="nc" id="L245">    public String distinctCountColumnSeparator = null;</span>
<span class="nc" id="L246">    public boolean supportsSelectForUpdate = true;</span>
<span class="nc" id="L247">    public boolean supportsLockingWithDistinctClause = true;</span>
<span class="nc" id="L248">    public boolean supportsLockingWithMultipleTables = true;</span>
<span class="nc" id="L249">    public boolean supportsLockingWithOrderClause = true;</span>
<span class="nc" id="L250">    public boolean supportsLockingWithOuterJoin = true;</span>
<span class="nc" id="L251">    public boolean supportsLockingWithInnerJoin = true;</span>
<span class="nc" id="L252">    public boolean supportsLockingWithSelectRange = true;</span>
<span class="nc" id="L253">    public boolean supportsQueryTimeout = true;</span>
<span class="nc" id="L254">    public boolean allowQueryTimeoutOnFindUpdate = false; //OPENJPA-2517</span>
<span class="nc" id="L255">    public boolean simulateLocking = false;</span>
<span class="nc" id="L256">    public boolean supportsSubselect = true;</span>
<span class="nc" id="L257">    public boolean supportsCorrelatedSubselect = true;</span>
<span class="nc" id="L258">    public boolean supportsHaving = true;</span>
<span class="nc" id="L259">    public boolean supportsSelectStartIndex = false;</span>
<span class="nc" id="L260">    public boolean supportsSelectEndIndex = false;</span>
<span class="nc" id="L261">    public int rangePosition = RANGE_POST_SELECT;</span>
<span class="nc" id="L262">    public boolean requiresAliasForSubselect = false;</span>
<span class="nc" id="L263">    public boolean requiresTargetForDelete = false;</span>
<span class="nc" id="L264">    public boolean allowsAliasInBulkClause = true;</span>
<span class="nc" id="L265">    public boolean supportsMultipleNontransactionalResultSets = true;</span>
<span class="nc" id="L266">    public boolean requiresSearchStringEscapeForLike = false;</span>
<span class="nc" id="L267">    public String searchStringEscape = &quot;\\&quot;;</span>
<span class="nc" id="L268">    public boolean requiresCastForMathFunctions = false;</span>
<span class="nc" id="L269">    public boolean requiresCastForComparisons = false;</span>
<span class="nc" id="L270">    public boolean supportsModOperator = false;</span>
<span class="nc" id="L271">    public boolean supportsXMLColumn = false;</span>
<span class="nc" id="L272">    public boolean supportsCaseConversionForLob = false;</span>
<span class="nc" id="L273">    public boolean reportsSuccessNoInfoOnBatchUpdates = false;</span>
<span class="nc" id="L274">    public boolean supportsSelectFromFinalTable = false;</span>
<span class="nc" id="L275">    public boolean supportsSimpleCaseExpression = true;</span>
<span class="nc" id="L276">    public boolean supportsGeneralCaseExpression = true;</span>
<span class="nc" id="L277">    public boolean useWildCardForCount = false;</span>

    /**
     * Some Databases append whitespace after the schema name
     */
<span class="nc" id="L282">    public boolean trimSchemaName = false;</span>

    // functions
<span class="nc" id="L285">    public String castFunction = &quot;CAST({0} AS {1})&quot;;</span>
<span class="nc" id="L286">    public String toLowerCaseFunction = &quot;LOWER({0})&quot;;</span>
<span class="nc" id="L287">    public String toUpperCaseFunction = &quot;UPPER({0})&quot;;</span>
<span class="nc" id="L288">    public String stringLengthFunction = &quot;CHAR_LENGTH({0})&quot;;</span>
<span class="nc" id="L289">    public String bitLengthFunction = &quot;(OCTET_LENGTH({0}) * 8)&quot;;</span>
<span class="nc" id="L290">    public String trimLeadingFunction = &quot;TRIM(LEADING {1} FROM {0})&quot;;</span>
<span class="nc" id="L291">    public String trimTrailingFunction = &quot;TRIM(TRAILING {1} FROM {0})&quot;;</span>
<span class="nc" id="L292">    public String trimBothFunction = &quot;TRIM(BOTH {1} FROM {0})&quot;;</span>
<span class="nc" id="L293">    public String concatenateFunction = &quot;({0}||{1})&quot;;</span>
<span class="nc" id="L294">    public String concatenateDelimiter = &quot;'OPENJPATOKEN'&quot;;</span>
<span class="nc" id="L295">    public String substringFunctionName = &quot;SUBSTRING&quot;;</span>
<span class="nc" id="L296">    public String currentDateFunction = &quot;CURRENT_DATE&quot;;</span>
<span class="nc" id="L297">    public String currentTimeFunction = &quot;CURRENT_TIME&quot;;</span>
<span class="nc" id="L298">    public String currentTimestampFunction = &quot;CURRENT_TIMESTAMP&quot;;</span>
<span class="nc" id="L299">    public String dropTableSQL = &quot;DROP TABLE {0}&quot;;</span>

    // types
<span class="nc" id="L302">    public boolean storageLimitationsFatal = false;</span>
<span class="nc" id="L303">    public boolean storeLargeNumbersAsStrings = false;</span>
<span class="nc" id="L304">    public boolean storeCharsAsNumbers = true;</span>
<span class="nc" id="L305">    public boolean trimStringColumns = false;</span>
<span class="nc" id="L306">    public boolean useGetBytesForBlobs = false;</span>
<span class="nc" id="L307">    public boolean useSetBytesForBlobs = false;</span>
<span class="nc" id="L308">    public boolean useGetObjectForBlobs = false;</span>
<span class="nc" id="L309">    public boolean useGetStringForClobs = false;</span>
<span class="nc" id="L310">    public boolean useSetStringForClobs = false;</span>
<span class="nc" id="L311">    public boolean useJDBC4SetBinaryStream = true;//OPENJPA-2067</span>
<span class="nc" id="L312">    public int maxEmbeddedBlobSize = -1;</span>
<span class="nc" id="L313">    public int maxEmbeddedClobSize = -1;</span>
<span class="nc" id="L314">    public int inClauseLimit = -1;</span>
<span class="nc" id="L315">    public int datePrecision = MILLI;</span>

    /**
     * @deprecated Use 'dateMillisecondBehavior' instead.
     */
<span class="nc" id="L320">    @Deprecated</span>
    public boolean roundTimeToMillisec = true;

    /*
     * This defines how the milliseconds of a Date field are handled
     * when the Date is retrieved from the database, as follows:
     *
     * ROUND: This is the default.  The
     * Date will be rounded to the nearest millisecond.
     * DROP: The milliseconds will be dropped, thus rounding is not
     * performed.  As an example, a date of '2010-01-01 12:00:00.687701'
     * stored in the database will become '2010-01-01 12:00:00.000' in
     * the Date field of the entity.
     * RETAIN: The milliseconds will not be rounded and retained.  As an
     * example, a date of '2010-01-01 12:00:00.687701' stored in the
     * database will become '2010-01-01 12:00:00.687' in the Date field
     * of the entity.
     */
<span class="nc" id="L338">    public enum DateMillisecondBehaviors { DROP, ROUND, RETAIN };</span>
    private DateMillisecondBehaviors dateMillisecondBehavior;

    /**
     * Defines how {@code Boolean} and {@code boolean} values get represented
     * in OpenJPA. Default to {@code INT_10}.
     * for backward compatibility.
     */
<span class="nc" id="L346">    protected BooleanRepresentation booleanRepresentation = BooleanRepresentationFactory.INT_10;</span>

<span class="nc" id="L348">    public int characterColumnSize = 255;</span>
<span class="nc" id="L349">    public String arrayTypeName = &quot;ARRAY&quot;;</span>
<span class="nc" id="L350">    public String bigintTypeName = &quot;BIGINT&quot;;</span>
<span class="nc" id="L351">    public String binaryTypeName = &quot;BINARY&quot;;</span>
<span class="nc" id="L352">    public String bitTypeName = &quot;BIT&quot;;</span>
<span class="nc" id="L353">    public String blobTypeName = &quot;BLOB&quot;;</span>
<span class="nc" id="L354">    public String booleanTypeName = &quot;BOOLEAN&quot;;</span>
<span class="nc" id="L355">    public String charTypeName = &quot;CHAR&quot;;</span>
<span class="nc" id="L356">    public String clobTypeName = &quot;CLOB&quot;;</span>
<span class="nc" id="L357">    public String dateTypeName = &quot;DATE&quot;;</span>
<span class="nc" id="L358">    public String decimalTypeName = &quot;DECIMAL&quot;;</span>
<span class="nc" id="L359">    public String distinctTypeName = &quot;DISTINCT&quot;;</span>
<span class="nc" id="L360">    public String doubleTypeName = &quot;DOUBLE&quot;;</span>
<span class="nc" id="L361">    public String floatTypeName = &quot;FLOAT&quot;;</span>
<span class="nc" id="L362">    public String integerTypeName = &quot;INTEGER&quot;;</span>
<span class="nc" id="L363">    public String javaObjectTypeName = &quot;JAVA_OBJECT&quot;;</span>
<span class="nc" id="L364">    public String longVarbinaryTypeName = &quot;LONGVARBINARY&quot;;</span>
<span class="nc" id="L365">    public String longVarcharTypeName = &quot;LONGVARCHAR&quot;;</span>
<span class="nc" id="L366">    public String nullTypeName = &quot;NULL&quot;;</span>
<span class="nc" id="L367">    public String numericTypeName = &quot;NUMERIC&quot;;</span>
<span class="nc" id="L368">    public String otherTypeName = &quot;OTHER&quot;;</span>
<span class="nc" id="L369">    public String realTypeName = &quot;REAL&quot;;</span>
<span class="nc" id="L370">    public String refTypeName = &quot;REF&quot;;</span>
<span class="nc" id="L371">    public String smallintTypeName = &quot;SMALLINT&quot;;</span>
<span class="nc" id="L372">    public String structTypeName = &quot;STRUCT&quot;;</span>
<span class="nc" id="L373">    public String timeTypeName = &quot;TIME&quot;;</span>
<span class="nc" id="L374">    public String timestampTypeName = &quot;TIMESTAMP&quot;;</span>
<span class="nc" id="L375">    public String timeWithZoneTypeName = &quot;TIME WITH TIME ZONE&quot;;</span>
<span class="nc" id="L376">    public String timestampWithZoneTypeName = &quot;TIMESTAMP WITH TIME ZONE&quot;;</span>
<span class="nc" id="L377">    public String tinyintTypeName = &quot;TINYINT&quot;;</span>
<span class="nc" id="L378">    public String varbinaryTypeName = &quot;VARBINARY&quot;;</span>
<span class="nc" id="L379">    public String varcharTypeName = &quot;VARCHAR&quot;;</span>
<span class="nc" id="L380">    public String xmlTypeName = &quot;XML&quot;;</span>
<span class="nc" id="L381">    public String xmlTypeEncoding = &quot;UTF-8&quot;;</span>
<span class="nc" id="L382">    public String getStringVal = &quot;&quot;;</span>

    // schema metadata
<span class="nc" id="L385">    public boolean useSchemaName = true;</span>
<span class="nc" id="L386">    public String tableTypes = &quot;TABLE&quot;;</span>
<span class="nc" id="L387">    public boolean supportsSchemaForGetTables = true;</span>
<span class="nc" id="L388">    public boolean supportsSchemaForGetColumns = true;</span>
<span class="nc" id="L389">    public boolean supportsNullTableForGetColumns = true;</span>
<span class="nc" id="L390">    public boolean supportsNullTableForGetPrimaryKeys = false;</span>
<span class="nc" id="L391">    public boolean supportsNullTableForGetIndexInfo = false;</span>
<span class="nc" id="L392">    public boolean supportsNullTableForGetImportedKeys = false;</span>
<span class="nc" id="L393">    public boolean useGetBestRowIdentifierForPrimaryKeys = false;</span>
<span class="nc" id="L394">    public boolean requiresAutoCommitForMetaData = false;</span>
<span class="nc" id="L395">    public boolean tableLengthIncludesSchema = false;</span>

    // auto-increment
<span class="nc" id="L398">    public int maxAutoAssignNameLength = 31;</span>
<span class="nc" id="L399">    public String autoAssignClause = null;</span>
<span class="nc" id="L400">    public String autoAssignTypeName = null;</span>
<span class="nc" id="L401">    public boolean supportsAutoAssign = false;</span>
<span class="nc" id="L402">    public String lastGeneratedKeyQuery = null;</span>
<span class="nc" id="L403">    public String nextSequenceQuery = null;</span>
<span class="nc" id="L404">    public String sequenceSQL = null;</span>
<span class="nc" id="L405">    public String sequenceSchemaSQL = null;</span>
<span class="nc" id="L406">    public String sequenceNameSQL = null;</span>
    // most native sequences can be run inside the business transaction
<span class="nc" id="L408">    public int nativeSequenceType= Seq.TYPE_CONTIGUOUS;</span>

    /**
     * This variable was used in 2.1.x and prior releases to indicate that
     * OpenJPA should not use the CACHE clause when getting a native
     * sequence; instead the INCREMENT BY clause gets its value equal to the
     * allocationSize property.  Post 2.1.x, code was added to allow
     * said functionality by default (see OPENJPA-1376).  For forward
     * compatibility, this variable should not be removed.
     */
<span class="nc" id="L418">    @Deprecated</span>
    public boolean useNativeSequenceCache = true;

    /**
     * If a user sets the previous variable (useNativeSequenceCache) to false, we should log a
     * warning indicating that the variable no longer has an effect due to the code changes
     * of OPENJPA-1376.  We only want to log the warning once per instance, thus this
     * variable will be used to indicate if the warning should be printed or not.
     */
<span class="nc" id="L427">    @Deprecated</span>
    private boolean logNativeSequenceCacheWarning = true;

<span class="nc" id="L430">    protected JDBCConfiguration conf = null;</span>
<span class="nc" id="L431">    protected Log log = null;</span>
<span class="nc" id="L432">    protected boolean connected = false;</span>
<span class="nc" id="L433">    protected boolean isJDBC3 = false;</span>
<span class="nc" id="L434">    protected boolean isJDBC4 = false;</span>
<span class="nc" id="L435">    protected final Set&lt;String&gt; reservedWordSet = new HashSet&lt;&gt;();</span>
    // reservedWordSet subset that CANNOT be used as valid column names
    // (i.e., without surrounding them with double-quotes)
<span class="nc" id="L438">    protected Set&lt;String&gt; invalidColumnWordSet = new HashSet&lt;&gt;();</span>
<span class="nc" id="L439">    protected final Set&lt;String&gt; systemSchemaSet = new HashSet&lt;&gt;();</span>
<span class="nc" id="L440">    protected final Set&lt;String&gt; systemTableSet = new HashSet&lt;&gt;();</span>
<span class="nc" id="L441">    protected final Set&lt;String&gt; fixedSizeTypeNameSet = new HashSet&lt;&gt;();</span>

    /**
     * set of types that might have an optional fraction (sub-second) part.
     * @{code @Column(scale=-1)} sets the fraction to zero.
     * @{code @Column(scale=0)} will use the default behaviour (no fraction information generated)
     */
<span class="nc" id="L448">    public final Set&lt;String&gt; fractionalTypeNameSet = new HashSet&lt;&gt;();</span>

    /**
     * Default amount of digits for fractional Types.
     * This is not supported/required by every database.
     *
     * This value is only being used if no explicit {@code @Column(scale=n)} is set or n is zero.
     * Use {@code @Column(scale=-1)} to disable the explicit fraction part in the SQL generator.
     * @see #fractionalTypeNameSet
     * @see #getDateFractionDigits(Column, String)
     */
<span class="nc" id="L459">    public int dateFractionDigits = 6;</span>


<span class="nc" id="L462">    protected final Set&lt;String&gt; typeModifierSet = new HashSet&lt;&gt;();</span>

    // NamingConfiguration properties
<span class="nc" id="L465">    private boolean delimitIdentifiers = false;</span>
<span class="nc" id="L466">    public Boolean supportsDelimitedIdentifiers = null;</span>
<span class="nc" id="L467">    public String leadingDelimiter = &quot;\&quot;&quot;;</span>
<span class="nc" id="L468">    public String trailingDelimiter = &quot;\&quot;&quot;;</span>
<span class="nc" id="L469">    public String nameConcatenator = &quot;_&quot;;</span>
<span class="nc" id="L470">    public String delimitedCase = SCHEMA_CASE_PRESERVE;</span>
<span class="nc" id="L471">    public String catalogSeparator = &quot;.&quot;;</span>
<span class="nc" id="L472">    protected String defaultSchemaName = null;</span>
<span class="nc" id="L473">    private String conversionKey = null;</span>

    // Naming utility and naming rules
<span class="nc" id="L476">    private DBIdentifierUtil namingUtil = null;</span>
<span class="nc" id="L477">    private Map&lt;String, IdentifierRule&gt; namingRules = new HashMap&lt;&gt;();</span>
<span class="nc" id="L478">    private IdentifierRule defaultNamingRule = null;  // cached for performance</span>

    /**
     * If a native query begins with any of the values found here then it will
     * be treated as a select statement.
     */
<span class="nc" id="L484">    protected final Set&lt;String&gt; selectWordSet = new HashSet&lt;&gt;();</span>

    // when we store values that lose precision, track the types so that the
    // first time it happens we can warn the user
<span class="nc" id="L488">    private Set&lt;Class&lt;?&gt;&gt; _precisionWarnedTypes = null;</span>

    // batchLimit value:
    // -1 = unlimited
    // 0  = no batch
    // any positive number = batch limit
<span class="nc" id="L494">    public int batchLimit = NO_BATCH;</span>

<span class="nc" id="L496">    public final Map&lt;Integer,Set&lt;String&gt;&gt; sqlStateCodes =</span>
        new HashMap&lt;&gt;();

    protected ProxyManager _proxyManager;

<span class="nc" id="L501">    public DBDictionary() {</span>
<span class="nc" id="L502">        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{</span>
            &quot;BIGINT&quot;, &quot;BIT&quot;, &quot;BLOB&quot;, &quot;CLOB&quot;, &quot;DATE&quot;, &quot;DECIMAL&quot;, &quot;DISTINCT&quot;,
            &quot;DOUBLE&quot;, &quot;FLOAT&quot;, &quot;INTEGER&quot;, &quot;JAVA_OBJECT&quot;, &quot;NULL&quot;, &quot;NUMERIC&quot;,
            &quot;OTHER&quot;, &quot;REAL&quot;, &quot;REF&quot;, &quot;SMALLINT&quot;, &quot;STRUCT&quot;, &quot;TIME&quot;, &quot;TIMESTAMP&quot;,
            &quot;TINYINT&quot;,
        }));

<span class="nc" id="L509">        selectWordSet.add(&quot;SELECT&quot;);</span>
<span class="nc" id="L510">    }</span>

    /**
     * This method is called when the dictionary first sees any connection.
     * It is used to initialize dictionary metadata if needed. If you
     * override this method, be sure to call
     * &lt;code&gt;super.connectedConfiguration&lt;/code&gt;.
     */
    public void connectedConfiguration(Connection conn)
        throws SQLException {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (!connected) {</span>
<span class="nc" id="L521">            DatabaseMetaData metaData = null;</span>
            try {
<span class="nc" id="L523">                metaData = conn.getMetaData();</span>

<span class="nc" id="L525">                databaseProductName    = nullSafe(metaData.getDatabaseProductName());</span>
<span class="nc" id="L526">                databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());</span>
<span class="nc" id="L527">                setMajorVersion(metaData.getDatabaseMajorVersion());</span>
<span class="nc" id="L528">                setMinorVersion(metaData.getDatabaseMinorVersion());</span>
                try {
                    // JDBC3-only method, so it might throw an
                    // AbstractMethodError
<span class="nc" id="L532">                    int JDBCMajorVersion = metaData.getJDBCMajorVersion();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                    isJDBC3 = JDBCMajorVersion &gt;= 3;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">                    isJDBC4 = JDBCMajorVersion &gt;= 4;</span>
<span class="nc" id="L535">                } catch (Throwable t) {</span>
                    // ignore if not JDBC3
<span class="nc" id="L537">                }</span>
<span class="nc" id="L538">            } catch (Exception e) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                if (log.isTraceEnabled())</span>
<span class="nc" id="L540">                    log.trace(e.toString(), e);</span>
<span class="nc" id="L541">            }</span>

<span class="nc bnc" id="L543" title="All 2 branches missed.">            if (log.isTraceEnabled()) {</span>
<span class="nc" id="L544">                log.trace(DBDictionaryFactory.toString(metaData));</span>

<span class="nc bnc" id="L546" title="All 2 branches missed.">                if (isJDBC3) {</span>
                    try {
<span class="nc" id="L548">                        log.trace(_loc.get(&quot;connection-defaults&quot;, new Object[]{</span>
<span class="nc" id="L549">                            conn.getAutoCommit(), conn.getHoldability(),</span>
<span class="nc" id="L550">                            conn.getTransactionIsolation()}));</span>
<span class="nc" id="L551">                    } catch (Throwable t) {</span>
<span class="nc" id="L552">                        log.trace(&quot;Unable to trace connection settings&quot;, t);</span>
<span class="nc" id="L553">                    }</span>
                }
            }

            // Configure the naming utility
<span class="nc bnc" id="L558" title="All 2 branches missed.">            if (supportsDelimitedIdentifiers == null) // not explicitly set</span>
<span class="nc" id="L559">                configureNamingUtil(metaData);</span>

            // Auto-detect generated keys retrieval support unless user specified it.
<span class="nc bnc" id="L562" title="All 2 branches missed.">            if (supportsGetGeneratedKeys == null) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                supportsGetGeneratedKeys =  (isJDBC3) ? metaData.supportsGetGeneratedKeys() : false;</span>
            }
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (log.isInfoEnabled()) {</span>
<span class="nc" id="L566">                log.info(_loc.get(&quot;dict-info&quot;, new Object[] {</span>
<span class="nc" id="L567">                        metaData.getDatabaseProductName(), getMajorVersion(), getMinorVersion(),</span>
<span class="nc" id="L568">                        metaData.getDriverName(), metaData.getDriverVersion()}));</span>
            }
        }
<span class="nc" id="L571">        connected = true;</span>
<span class="nc" id="L572">    }</span>

    private void configureNamingUtil(DatabaseMetaData metaData) {
        // Get the naming utility from the configuration
<span class="nc" id="L576">        setSupportsDelimitedIdentifiers(metaData);</span>
<span class="nc" id="L577">        setDelimitedCase(metaData);</span>
<span class="nc" id="L578">    }</span>

    /**
     * Configures the naming rules for this dictionary.  Subclasses should
     * override this method, providing their own naming rules.
     */
    protected void configureNamingRules() {
        // Add the default naming rule
<span class="nc" id="L586">        DBIdentifierRule defRule = new DBIdentifierRule(DBIdentifierType.DEFAULT, reservedWordSet);</span>
<span class="nc" id="L587">        namingRules.put(defRule.getName(), defRule);</span>
        // Disable delimiting of column definition.  DB platforms are very
        // picky about delimiters in column definitions. Base column types
        // do not require delimiters and will cause failures if delimited.
<span class="nc" id="L591">        DBIdentifierRule cdRule = new ColumnDefIdentifierRule();</span>
<span class="nc" id="L592">        cdRule.setCanDelimit(false);</span>
<span class="nc" id="L593">        namingRules.put(cdRule.getName(), cdRule);</span>
<span class="nc" id="L594">    }</span>

    //////////////////////
    // ResultSet wrappers
    //////////////////////

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Array getArray(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L606">        return rs.getArray(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public InputStream getAsciiStream(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L615">        return rs.getAsciiStream(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public BigDecimal getBigDecimal(ResultSet rs, int column)
        throws SQLException {
<span class="nc bnc" id="L624" title="All 2 branches missed.">        if (storeLargeNumbersAsStrings) {</span>
<span class="nc" id="L625">            String str = getString(rs, column);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            return (str == null) ? null : new BigDecimal(str);</span>
        }
<span class="nc" id="L628">        return rs.getBigDecimal(column);</span>
    }

    /**
     * Returns the specified column value as an unknown numeric type;
     * we try from the most generic to the least generic.
     */
    public Number getNumber(ResultSet rs, int column)
        throws SQLException {
        // try from the most generic, and if errors occur, try
        // less generic types; this enables us to handle values
        // like Double.NaN without having to introspect on the
        // ResultSetMetaData (bug #1053). Note that we handle
        // generic exceptions, since some drivers may throw
        // NumberFormatExceptions, whereas others may throw SQLExceptions
        try {
<span class="nc" id="L644">            return getBigDecimal(rs, column);</span>
<span class="nc" id="L645">        } catch (Exception e1) {</span>
            try {
<span class="nc" id="L647">                return Double.valueOf(getDouble(rs, column));</span>
<span class="nc" id="L648">            } catch (Exception e2) {</span>
                try {
<span class="nc" id="L650">                    return Float.valueOf(getFloat(rs, column));</span>
<span class="nc" id="L651">                } catch (Exception e3) {</span>
                    try {
<span class="nc" id="L653">                        return getLong(rs, column);</span>
<span class="nc" id="L654">                    } catch (Exception e4) {</span>
                        try {
<span class="nc" id="L656">                            return getInt(rs, column);</span>
<span class="nc" id="L657">                        } catch (Exception e5) {</span>
                        }
                    }
                }
            }

<span class="nc bnc" id="L663" title="All 2 branches missed.">            if (e1 instanceof RuntimeException)</span>
<span class="nc" id="L664">                throw(RuntimeException) e1;</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">            if (e1 instanceof SQLException)</span>
<span class="nc" id="L666">                throw(SQLException) e1;</span>
        }

<span class="nc" id="L669">        return null;</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public BigInteger getBigInteger(ResultSet rs, int column)
        throws SQLException {
<span class="nc bnc" id="L678" title="All 2 branches missed.">        if (storeLargeNumbersAsStrings) {</span>
<span class="nc" id="L679">            String str = getString(rs, column);</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">            return (str == null) ? null : new BigDecimal(str).toBigInteger();</span>
        }
<span class="nc" id="L682">        BigDecimal bd = getBigDecimal(rs, column);</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        return (bd == null) ? null : bd.toBigInteger();</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public InputStream getBinaryStream(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L692">        return rs.getBinaryStream(column);</span>
    }

    public InputStream getLOBStream(JDBCStore store, ResultSet rs,
        int column) throws SQLException {
<span class="nc" id="L697">        return rs.getBinaryStream(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Blob getBlob(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L706">        return rs.getBlob(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Object getBlobObject(ResultSet rs, int column, JDBCStore store)
        throws SQLException {
<span class="nc" id="L715">        InputStream in = null;</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">        if (useGetBytesForBlobs || useGetObjectForBlobs) {</span>
<span class="nc" id="L717">            byte[] bytes = getBytes(rs, column);</span>
<span class="nc bnc" id="L718" title="All 4 branches missed.">            if (bytes != null &amp;&amp; bytes.length &gt; 0)</span>
<span class="nc" id="L719">                in = new ByteArrayInputStream(bytes);</span>
<span class="nc" id="L720">        } else {</span>
<span class="nc" id="L721">            Blob blob = getBlob(rs, column);</span>
<span class="nc bnc" id="L722" title="All 4 branches missed.">            if (blob != null &amp;&amp; blob.length() &gt; 0)</span>
<span class="nc" id="L723">                in = blob.getBinaryStream();</span>
        }
<span class="nc bnc" id="L725" title="All 2 branches missed.">        if (in == null)</span>
<span class="nc" id="L726">            return null;</span>

        try {
<span class="nc bnc" id="L729" title="All 2 branches missed.">            if (store == null)</span>
<span class="nc" id="L730">                return Serialization.deserialize(in, null);</span>
<span class="nc" id="L731">            return Serialization.deserialize(in, store.getContext());</span>
        } finally {
            try {
<span class="nc" id="L734">                in.close();</span>
<span class="nc" id="L735">            } catch (IOException ioe) {</span>
<span class="nc" id="L736">            }</span>
        }
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public boolean getBoolean(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L746">        return booleanRepresentation.getBoolean(rs, column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public byte getByte(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L755">        return rs.getByte(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public byte[] getBytes(ResultSet rs, int column)
        throws SQLException {
<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (useGetBytesForBlobs)</span>
<span class="nc" id="L765">            return rs.getBytes(column);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">        if (useGetObjectForBlobs)</span>
<span class="nc" id="L767">            return (byte[]) rs.getObject(column);</span>

<span class="nc" id="L769">        Blob blob = getBlob(rs, column);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if (blob == null)</span>
<span class="nc" id="L771">            return null;</span>
<span class="nc" id="L772">        int length = (int) blob.length();</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (length == 0)</span>
<span class="nc" id="L774">            return null;</span>
<span class="nc" id="L775">        return blob.getBytes(1, length);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type. Converts the date from a {@link Timestamp} by default.
     */
    public Calendar getCalendar(ResultSet rs, int column) throws SQLException {
<span class="nc" id="L783">        Date d = getDate(rs, column);</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">        if (d == null)</span>
<span class="nc" id="L785">            return null;</span>
<span class="nc" id="L786">        Calendar cal = (Calendar) getProxyManager().newCalendarProxy(GregorianCalendar.class, null);</span>
<span class="nc" id="L787">        cal.setTime(d);</span>
<span class="nc" id="L788">        return cal;</span>
    }

    /**
     * Retrieve the specified column of the SQL ResultSet to the proper
     * {@link LocalDate} java type.
     */
    public LocalDate getLocalDate(ResultSet rs, int column) throws SQLException {
<span class="nc" id="L796">        java.sql.Date date = rs.getDate(column);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">        return date != null ? date.toLocalDate() : null;</span>
    }

    /**
     * Retrieve the specified column of the SQL ResultSet to the proper
     * {@link LocalTime} java type.
     */
    public LocalTime getLocalTime(ResultSet rs, int column) throws SQLException {
<span class="nc" id="L805">        java.sql.Time time = rs.getTime(column);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">        return time != null ? time.toLocalTime() : null;</span>
    }

    /**
     * Retrieve the specified column of the SQL ResultSet to the proper
     * {@link LocalDateTime} java type.
     */
    public LocalDateTime getLocalDateTime(ResultSet rs, int column) throws SQLException {
<span class="nc" id="L814">        Timestamp tst = rs.getTimestamp(column);</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">        return tst != null ? tst.toLocalDateTime() : null;</span>
    }

    /**
     * Retrieve the specified column of the SQL ResultSet to the proper
     * {@link OffsetTime} java type.
     */
    public OffsetTime getOffsetTime(ResultSet rs, int column) throws SQLException {
<span class="nc" id="L823">        java.sql.Time time = rs.getTime(column);</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">        return time != null ? time.toLocalTime().atOffset(OffsetDateTime.now().getOffset()) : null;</span>
    }

    /**
     * Retrieve the specified column of the SQL ResultSet to the proper
     * {@link OffsetDateTime} java type.
     */
    public OffsetDateTime getOffsetDateTime(ResultSet rs, int column) throws SQLException {
<span class="nc" id="L832">        Timestamp tst = rs.getTimestamp(column);</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        return tst != null ? tst.toLocalDateTime().atZone(ZoneId.systemDefault()).toOffsetDateTime() : null;</span>
    }

    private ProxyManager getProxyManager() {
<span class="nc bnc" id="L837" title="All 2 branches missed.">        if (_proxyManager == null) {</span>
<span class="nc" id="L838">            _proxyManager = conf.getProxyManagerInstance();</span>
        }
<span class="nc" id="L840">        return _proxyManager;</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public char getChar(ResultSet rs, int column)
        throws SQLException {
<span class="nc bnc" id="L849" title="All 2 branches missed.">        if (storeCharsAsNumbers)</span>
<span class="nc" id="L850">            return (char) getInt(rs, column);</span>

<span class="nc" id="L852">        String str = getString(rs, column);</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">        return (StringUtil.isEmpty(str)) ? 0 : str.charAt(0);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Reader getCharacterStream(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L862">        return rs.getCharacterStream(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Clob getClob(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L871">        return rs.getClob(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public String getClobString(ResultSet rs, int column)
        throws SQLException {
<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (useGetStringForClobs)</span>
<span class="nc" id="L881">            return rs.getString(column);</span>

<span class="nc" id="L883">        Clob clob = getClob(rs, column);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">        if (clob == null)</span>
<span class="nc" id="L885">            return null;</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">        if (clob.length() == 0)</span>
<span class="nc" id="L887">            return &quot;&quot;;</span>

        // unlikely that we'll have strings over Integer.MAX_VALUE chars
<span class="nc" id="L890">        return clob.getSubString(1, (int) clob.length());</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type. Converts the date from a {@link Timestamp} by default.
     */
    public Date getDate(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L899">        Timestamp tstamp = getTimestamp(rs, column, null);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (tstamp == null)</span>
<span class="nc" id="L901">            return null;</span>

        // get the fractional seconds component, rounding away anything beyond
        // milliseconds
<span class="nc" id="L905">        int fractional = 0;</span>
<span class="nc bnc" id="L906" title="All 4 branches missed.">        switch (getMillisecondBehavior()) {</span>
            case DROP :
<span class="nc" id="L908">                fractional = 0;</span>
<span class="nc" id="L909">                break;</span>
            case RETAIN :
<span class="nc" id="L911">                fractional = (int) (tstamp.getNanos() / (double) MILLI);</span>
<span class="nc" id="L912">                break;</span>
            case ROUND :
<span class="nc" id="L914">                fractional = (int) Math.round(tstamp.getNanos() / (double) MILLI);</span>
                break;
        }

        // get the millis component; some JDBC drivers round this to the
        // nearest second, while others do not
<span class="nc" id="L920">        long millis = (tstamp.getTime() / 1000L) * 1000L;</span>
<span class="nc" id="L921">        return new Date(millis + fractional);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public java.sql.Date getDate(ResultSet rs, int column, Calendar cal)
        throws SQLException {
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (cal == null)</span>
<span class="nc" id="L931">            return rs.getDate(column);</span>
<span class="nc" id="L932">        return rs.getDate(column, cal);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public double getDouble(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L941">        return rs.getDouble(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public float getFloat(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L950">        return rs.getFloat(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public int getInt(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L959">        return rs.getInt(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Locale getLocale(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L968">        String str = getString(rs, column);</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">        if (StringUtil.isEmpty(str))</span>
<span class="nc" id="L970">            return null;</span>

<span class="nc" id="L972">        String[] params = StringUtil.split(str, &quot;_&quot;, 3);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (params.length &lt; 3)</span>
<span class="nc" id="L974">            return null;</span>
<span class="nc" id="L975">        return new Locale(params[0], params[1], params[2]);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public long getLong(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L984">        return rs.getLong(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Object getObject(ResultSet rs, int column, Map map)
        throws SQLException {
<span class="nc bnc" id="L993" title="All 2 branches missed.">        if (map == null)</span>
<span class="nc" id="L994">            return rs.getObject(column);</span>
<span class="nc" id="L995">        return rs.getObject(column, map);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Ref getRef(ResultSet rs, int column, Map map)
        throws SQLException {
<span class="nc" id="L1004">        return rs.getRef(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public short getShort(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L1013">        return rs.getShort(column);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public String getString(ResultSet rs, int column)
        throws SQLException {
<span class="nc" id="L1022">        String res = rs.getString(column);</span>
<span class="nc bnc" id="L1023" title="All 4 branches missed.">        if ((res != null) &amp;&amp; trimStringColumns) {</span>
<span class="nc" id="L1024">            res = res.trim();</span>
        }
<span class="nc" id="L1026">        return res;</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Time getTime(ResultSet rs, int column, Calendar cal)
        throws SQLException {
<span class="nc bnc" id="L1035" title="All 2 branches missed.">        if (cal == null)</span>
<span class="nc" id="L1036">            return rs.getTime(column);</span>
<span class="nc" id="L1037">        return rs.getTime(column, cal);</span>
    }

    /**
     * Convert the specified column of the SQL ResultSet to the proper
     * java type.
     */
    public Timestamp getTimestamp(ResultSet rs, int column, Calendar cal)
        throws SQLException {
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        if (cal == null)</span>
<span class="nc" id="L1047">            return rs.getTimestamp(column);</span>
<span class="nc" id="L1048">        return rs.getTimestamp(column, cal);</span>
    }

    //////////////////////////////
    // PreparedStatement wrappers
    //////////////////////////////

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setArray(PreparedStatement stmnt, int idx, Array val,
        Column col)
        throws SQLException {
<span class="nc" id="L1061">        stmnt.setArray(idx, val);</span>
<span class="nc" id="L1062">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setAsciiStream(PreparedStatement stmnt, int idx, InputStream val, int length, Column col)
        throws SQLException {
<span class="nc" id="L1069">        stmnt.setAsciiStream(idx, val, length);</span>
<span class="nc" id="L1070">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setBigDecimal(PreparedStatement stmnt, int idx, BigDecimal val, Column col)
        throws SQLException {
<span class="nc bnc" id="L1077" title="All 8 branches missed.">        if ((col != null &amp;&amp; col.isCompatible(Types.VARCHAR, null, 0, 0))</span>
            || (col == null &amp;&amp; storeLargeNumbersAsStrings)) {
<span class="nc" id="L1079">            setString(stmnt, idx, val.toString(), col);</span>
        }
        else {
<span class="nc" id="L1082">            stmnt.setBigDecimal(idx, val);</span>
        }
<span class="nc" id="L1084">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setBigInteger(PreparedStatement stmnt, int idx, BigInteger val, Column col)
        throws SQLException {
<span class="nc bnc" id="L1091" title="All 8 branches missed.">        if ((col != null &amp;&amp; col.isCompatible(Types.VARCHAR, null, 0, 0))</span>
            || (col == null &amp;&amp; storeLargeNumbersAsStrings)) {
<span class="nc" id="L1093">            setString(stmnt, idx, val.toString(), col);</span>
        }
        else {
<span class="nc" id="L1096">            setBigDecimal(stmnt, idx, new BigDecimal(val), col);</span>
        }
<span class="nc" id="L1098">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setBinaryStream(PreparedStatement stmnt, int idx, InputStream val, int length, Column col)
        throws SQLException {

        //OPENJPA-2067: If the user has set the 'useJDBC4SetBinaryStream' property
        //then lets use the JDBC 4.0 version of the setBinaryStream method.
<span class="nc bnc" id="L1108" title="All 2 branches missed.">        if (useJDBC4SetBinaryStream) {</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">            if (isJDBC4){</span>
<span class="nc" id="L1110">                stmnt.setBinaryStream(idx, val);</span>
<span class="nc" id="L1111">                return;</span>
            }
            else {
<span class="nc" id="L1114">                log.trace(_loc.get(&quot;jdbc4-setbinarystream-unsupported&quot;));</span>
            }
        }

<span class="nc" id="L1118">        stmnt.setBinaryStream(idx, val, length);</span>
<span class="nc" id="L1119">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setBlob(PreparedStatement stmnt, int idx, Blob val, Column col)
        throws SQLException {
<span class="nc" id="L1126">        stmnt.setBlob(idx, val);</span>
<span class="nc" id="L1127">    }</span>

    /**
     * Set the given value as a parameter to the statement. Uses the
     * {@link #serialize} method to serialize the value.
     */
    public void setBlobObject(PreparedStatement stmnt, int idx, Object val, Column col, JDBCStore store)
        throws SQLException {
<span class="nc" id="L1135">        setBytes(stmnt, idx, serialize(val, store), col);</span>
<span class="nc" id="L1136">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setBoolean(PreparedStatement stmnt, int idx, boolean val, Column col)
        throws SQLException {
<span class="nc" id="L1143">        booleanRepresentation.setBoolean(stmnt, idx, val);</span>
<span class="nc" id="L1144">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setByte(PreparedStatement stmnt, int idx, byte val, Column col)
        throws SQLException {
<span class="nc" id="L1151">        stmnt.setByte(idx, val);</span>
<span class="nc" id="L1152">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setBytes(PreparedStatement stmnt, int idx, byte[] val,
        Column col)
        throws SQLException {
<span class="nc bnc" id="L1160" title="All 2 branches missed.">        if (useSetBytesForBlobs)</span>
<span class="nc" id="L1161">            stmnt.setBytes(idx, val);</span>
        else
<span class="nc" id="L1163">            setBinaryStream(stmnt, idx, new ByteArrayInputStream(val),</span>
                val.length, col);
<span class="nc" id="L1165">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setChar(PreparedStatement stmnt, int idx, char val, Column col)
        throws SQLException {
<span class="nc bnc" id="L1172" title="All 8 branches missed.">        if ((col != null &amp;&amp; col.isCompatible(Types.INTEGER, null, 0, 0))</span>
            || (col == null &amp;&amp; storeCharsAsNumbers))
<span class="nc" id="L1174">            setInt(stmnt, idx, (int) val, col);</span>
        else
<span class="nc" id="L1176">            setString(stmnt, idx, String.valueOf(val), col);</span>
<span class="nc" id="L1177">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setCharacterStream(PreparedStatement stmnt, int idx,
        Reader val, int length, Column col)
        throws SQLException {
<span class="nc" id="L1185">        stmnt.setCharacterStream(idx, val, length);</span>
<span class="nc" id="L1186">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setClob(PreparedStatement stmnt, int idx, Clob val, Column col)
        throws SQLException {
<span class="nc" id="L1193">        stmnt.setClob(idx, val);</span>
<span class="nc" id="L1194">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setClobString(PreparedStatement stmnt, int idx, String val,
        Column col)
        throws SQLException {
<span class="nc bnc" id="L1202" title="All 2 branches missed.">        if (useSetStringForClobs)</span>
<span class="nc" id="L1203">            stmnt.setString(idx, val);</span>
        else {
            // set reader from string
<span class="nc" id="L1206">            StringReader in = new StringReader(val);</span>
<span class="nc" id="L1207">            setCharacterStream(stmnt, idx, in, val.length(), col);</span>
        }
<span class="nc" id="L1209">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setDate(PreparedStatement stmnt, int idx, Date val, Column col)
        throws SQLException {
<span class="nc bnc" id="L1216" title="All 4 branches missed.">        if (col != null &amp;&amp; col.getType() == Types.DATE)</span>
<span class="nc" id="L1217">            setDate(stmnt, idx, new java.sql.Date(val.getTime()), null, col);</span>
<span class="nc bnc" id="L1218" title="All 4 branches missed.">        else if (col != null &amp;&amp; col.getType() == Types.TIME)</span>
<span class="nc" id="L1219">            setTime(stmnt, idx, new Time(val.getTime()), null, col);</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        else if (val instanceof Timestamp)</span>
<span class="nc" id="L1221">            setTimestamp(stmnt, idx,(Timestamp) val, null, col);</span>
        else
<span class="nc" id="L1223">            setTimestamp(stmnt, idx, new Timestamp(val.getTime()), null, col);</span>
<span class="nc" id="L1224">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setDate(PreparedStatement stmnt, int idx, java.sql.Date val, Calendar cal, Column col)
        throws SQLException {
<span class="nc bnc" id="L1231" title="All 2 branches missed.">        if (cal == null) {</span>
<span class="nc" id="L1232">            stmnt.setDate(idx, val);</span>
        }
        else {
<span class="nc" id="L1235">            stmnt.setDate(idx, val, cal);</span>
        }
<span class="nc" id="L1237">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setCalendar(PreparedStatement stmnt, int idx, Calendar val, Column col)
        throws SQLException {
        // by default we merely delegate to the Date parameter
<span class="nc" id="L1245">        setDate(stmnt, idx, val.getTime(), col);</span>
<span class="nc" id="L1246">    }</span>

    /**
     * Set the given LocalDate value as a parameter to the statement.
     *
     */
    public void setLocalDate(PreparedStatement stmnt, int idx, LocalDate val, Column col)
        throws SQLException {
<span class="nc" id="L1254">        setDate(stmnt, idx, java.sql.Date.valueOf(val), null, col);</span>
<span class="nc" id="L1255">    }</span>

    /**
     * Set the given LocalTime value as a parameter to the statement.
     *
     */
    public void setLocalTime(PreparedStatement stmnt, int idx, LocalTime val, Column col)
        throws SQLException {
<span class="nc" id="L1263">        setTime(stmnt, idx, java.sql.Time.valueOf(val), null, col);</span>
<span class="nc" id="L1264">    }</span>

    /**
     * Set the given LocalTime value as a parameter to the statement.
     *
     */
    public void setLocalDateTime(PreparedStatement stmnt, int idx, LocalDateTime val, Column col)
        throws SQLException {
<span class="nc" id="L1272">        setTimestamp(stmnt, idx, java.sql.Timestamp.valueOf(val), null, col);</span>
<span class="nc" id="L1273">    }</span>


    /**
     * Set the given LocalTime value as a parameter to the statement.
     *
     */
    public void setOffsetTime(PreparedStatement stmnt, int idx, OffsetTime val, Column col)
            throws SQLException {
        // adjust to the default timezone right now.
        // This is an ugly hack and cries for troubles in case the daylight saving changes...
        // Which is also the reason why we cannot cache the offset.
        // According to the Oracle docs the JDBC driver always assumes 'local time' ...
<span class="nc" id="L1286">        LocalTime localTime = val.withOffsetSameInstant(OffsetDateTime.now().getOffset()).toLocalTime();</span>
<span class="nc" id="L1287">        setLocalTime(stmnt, idx, localTime, col);</span>
<span class="nc" id="L1288">    }</span>

    /**
     * Set the given LocalTime value as a parameter to the statement.
     *
     */
    public void setOffsetDateTime(PreparedStatement stmnt, int idx, OffsetDateTime val, Column col)
            throws SQLException {
<span class="nc" id="L1296">        LocalDateTime localdt = val.atZoneSameInstant(ZoneId.systemDefault()).toLocalDateTime();</span>
<span class="nc" id="L1297">        setLocalDateTime(stmnt, idx, localdt, col);</span>
<span class="nc" id="L1298">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setDouble(PreparedStatement stmnt, int idx, double val, Column col)
        throws SQLException {
<span class="nc" id="L1305">        stmnt.setDouble(idx, val);</span>
<span class="nc" id="L1306">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setFloat(PreparedStatement stmnt, int idx, float val, Column col)
        throws SQLException {
<span class="nc" id="L1313">        stmnt.setFloat(idx, val);</span>
<span class="nc" id="L1314">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setInt(PreparedStatement stmnt, int idx, int val, Column col)
        throws SQLException {
<span class="nc" id="L1321">        stmnt.setInt(idx, val);</span>
<span class="nc" id="L1322">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setLong(PreparedStatement stmnt, int idx, long val, Column col)
        throws SQLException {
<span class="nc" id="L1329">        stmnt.setLong(idx, val);</span>
<span class="nc" id="L1330">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setLocale(PreparedStatement stmnt, int idx, Locale val, Column col)
        throws SQLException {
<span class="nc" id="L1337">        setString(stmnt, idx, val.getLanguage() + &quot;_&quot; + val.getCountry()</span>
<span class="nc" id="L1338">            + &quot;_&quot; + val.getVariant(), col);</span>
<span class="nc" id="L1339">    }</span>

    /**
     * Set null as a parameter to the statement. The column
     * type will come from {@link Types}.
     */
    public void setNull(PreparedStatement stmnt, int idx, int colType, Column col)
        throws SQLException {
<span class="nc" id="L1347">        stmnt.setNull(idx, colType);</span>
<span class="nc" id="L1348">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setNumber(PreparedStatement stmnt, int idx, Number num, Column col)
        throws SQLException {
        // check for known floating point types to give driver a chance to
        // handle special numbers like NaN and infinity; bug #1053
<span class="nc bnc" id="L1357" title="All 2 branches missed.">        if (num instanceof Double)</span>
<span class="nc" id="L1358">            setDouble(stmnt, idx, ((Double) num).doubleValue(), col);</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">        else if (num instanceof Float)</span>
<span class="nc" id="L1360">            setFloat(stmnt, idx, ((Float) num).floatValue(), col);</span>
        else
<span class="nc" id="L1362">            setBigDecimal(stmnt, idx, new BigDecimal(num.toString()), col);</span>
<span class="nc" id="L1363">    }</span>

    /**
     * Set the given value as a parameter to the statement. The column
     * type will come from {@link Types}.
     */
    public void setObject(PreparedStatement stmnt, int idx, Object val, int colType, Column col)
        throws SQLException {
<span class="nc bnc" id="L1371" title="All 4 branches missed.">        if (colType == -1 || colType == Types.OTHER)</span>
<span class="nc" id="L1372">            stmnt.setObject(idx, val);</span>
        else
<span class="nc" id="L1374">            stmnt.setObject(idx, val, colType);</span>
<span class="nc" id="L1375">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setRef(PreparedStatement stmnt, int idx, Ref val, Column col)
        throws SQLException {
<span class="nc" id="L1382">        stmnt.setRef(idx, val);</span>
<span class="nc" id="L1383">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setShort(PreparedStatement stmnt, int idx, short val, Column col)
        throws SQLException {
<span class="nc" id="L1390">        stmnt.setShort(idx, val);</span>
<span class="nc" id="L1391">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setString(PreparedStatement stmnt, int idx, String val, Column col)
        throws SQLException {
<span class="nc" id="L1398">        stmnt.setString(idx, val);</span>
<span class="nc" id="L1399">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setTime(PreparedStatement stmnt, int idx, Time val, Calendar cal, Column col)
        throws SQLException {
<span class="nc bnc" id="L1406" title="All 2 branches missed.">        if (cal == null)</span>
<span class="nc" id="L1407">            stmnt.setTime(idx, val);</span>
        else
<span class="nc" id="L1409">            stmnt.setTime(idx, val, cal);</span>
<span class="nc" id="L1410">    }</span>

    /**
     * Set the given value as a parameter to the statement.
     */
    public void setTimestamp(PreparedStatement stmnt, int idx, Timestamp val, Calendar cal, Column col)
        throws SQLException {

<span class="nc" id="L1418">        val = StateManagerImpl.roundTimestamp(val, datePrecision);</span>

<span class="nc bnc" id="L1420" title="All 2 branches missed.">        if (cal == null)</span>
<span class="nc" id="L1421">            stmnt.setTimestamp(idx, val);</span>
        else
<span class="nc" id="L1423">            stmnt.setTimestamp(idx, val, cal);</span>
<span class="nc" id="L1424">    }</span>

    /**
     * Set a column value into a prepared statement.
     *
     * @param stmnt the prepared statement to parameterize
     * @param idx the index of the parameter in the prepared statement
     * @param val the value of the column
     * @param col the column being set
     * @param type the field mapping type code for the value
     * @param store the store manager for the current context
     */
    public void setTyped(PreparedStatement stmnt, int idx, Object val, Column col, int type, JDBCStore store)
        throws SQLException {
<span class="nc bnc" id="L1438" title="All 2 branches missed.">        if (val == null) {</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">            setNull(stmnt, idx, (col == null) ? Types.OTHER : col.getType(),</span>
                col);
<span class="nc" id="L1441">            return;</span>
        }

        Sized s;
        Calendard c;
<span class="nc bnc" id="L1446" title="All 33 branches missed.">        switch (type) {</span>
            case JavaTypes.BOOLEAN:
            case JavaTypes.BOOLEAN_OBJ:
<span class="nc" id="L1449">                setBoolean(stmnt, idx, ((Boolean) val).booleanValue(), col);</span>
<span class="nc" id="L1450">                break;</span>
            case JavaTypes.BYTE:
            case JavaTypes.BYTE_OBJ:
<span class="nc" id="L1453">                setByte(stmnt, idx, ((Number) val).byteValue(), col);</span>
<span class="nc" id="L1454">                break;</span>
            case JavaTypes.CHAR:
            case JavaTypes.CHAR_OBJ:
<span class="nc" id="L1457">                setChar(stmnt, idx, ((Character) val).charValue(), col);</span>
<span class="nc" id="L1458">                break;</span>
            case JavaTypes.DOUBLE:
            case JavaTypes.DOUBLE_OBJ:
<span class="nc" id="L1461">                setDouble(stmnt, idx, ((Number) val).doubleValue(), col);</span>
<span class="nc" id="L1462">                break;</span>
            case JavaTypes.FLOAT:
            case JavaTypes.FLOAT_OBJ:
<span class="nc" id="L1465">                setFloat(stmnt, idx, ((Number) val).floatValue(), col);</span>
<span class="nc" id="L1466">                break;</span>
            case JavaTypes.INT:
            case JavaTypes.INT_OBJ:
<span class="nc" id="L1469">                setInt(stmnt, idx, ((Number) val).intValue(), col);</span>
<span class="nc" id="L1470">                break;</span>
            case JavaTypes.LONG:
            case JavaTypes.LONG_OBJ:
<span class="nc" id="L1473">                setLong(stmnt, idx, ((Number) val).longValue(), col);</span>
<span class="nc" id="L1474">                break;</span>
            case JavaTypes.SHORT:
            case JavaTypes.SHORT_OBJ:
<span class="nc" id="L1477">                setShort(stmnt, idx, ((Number) val).shortValue(), col);</span>
<span class="nc" id="L1478">                break;</span>
            case JavaTypes.STRING:
<span class="nc bnc" id="L1480" title="All 4 branches missed.">                if (col != null &amp;&amp; (col.getType() == Types.CLOB</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">                    || col.getType() == Types.LONGVARCHAR))</span>
<span class="nc" id="L1482">                    setClobString(stmnt, idx, (String) val, col);</span>
                else {
<span class="nc bnc" id="L1484" title="All 2 branches missed.">                    if (val instanceof String)</span>
<span class="nc" id="L1485">                        setString(stmnt, idx, (String) val, col);</span>
                    else
<span class="nc" id="L1487">                        setString(stmnt, idx, val.toString(), col);</span>
                }
<span class="nc" id="L1489">                break;</span>
            case JavaTypes.OBJECT:
<span class="nc" id="L1491">                setBlobObject(stmnt, idx, val, col, store);</span>
<span class="nc" id="L1492">                break;</span>
            case JavaTypes.DATE:
<span class="nc" id="L1494">                setDate(stmnt, idx, (Date) val, col);</span>
<span class="nc" id="L1495">                break;</span>
            case JavaTypes.CALENDAR:
<span class="nc" id="L1497">                setCalendar(stmnt, idx, (Calendar) val, col);</span>
<span class="nc" id="L1498">                break;</span>
            case JavaTypes.LOCAL_DATE:
<span class="nc" id="L1500">                setLocalDate(stmnt, idx, (LocalDate) val, col);</span>
<span class="nc" id="L1501">                break;</span>
            case JavaTypes.LOCAL_TIME:
<span class="nc" id="L1503">                setLocalTime(stmnt, idx, (LocalTime) val, col);</span>
<span class="nc" id="L1504">                break;</span>
            case JavaTypes.LOCAL_DATETIME:
<span class="nc" id="L1506">                setLocalDateTime(stmnt, idx, (LocalDateTime) val, col);</span>
<span class="nc" id="L1507">                break;</span>
            case JavaTypes.OFFSET_TIME:
<span class="nc" id="L1509">                setOffsetTime(stmnt, idx, (OffsetTime) val, col);</span>
<span class="nc" id="L1510">                break;</span>
            case JavaTypes.OFFSET_DATETIME:
<span class="nc" id="L1512">                setOffsetDateTime(stmnt, idx, (OffsetDateTime) val, col);</span>
<span class="nc" id="L1513">                break;</span>
            case JavaTypes.BIGDECIMAL:
<span class="nc" id="L1515">                setBigDecimal(stmnt, idx, (BigDecimal) val, col);</span>
<span class="nc" id="L1516">                break;</span>
            case JavaTypes.BIGINTEGER:
<span class="nc" id="L1518">                setBigInteger(stmnt, idx, (BigInteger) val, col);</span>
<span class="nc" id="L1519">                break;</span>
            case JavaTypes.NUMBER:
<span class="nc" id="L1521">                setNumber(stmnt, idx, (Number) val, col);</span>
<span class="nc" id="L1522">                break;</span>
            case JavaTypes.LOCALE:
<span class="nc" id="L1524">                setLocale(stmnt, idx, (Locale) val, col);</span>
<span class="nc" id="L1525">                break;</span>
            case JavaSQLTypes.SQL_ARRAY:
<span class="nc" id="L1527">                setArray(stmnt, idx, (Array) val, col);</span>
<span class="nc" id="L1528">                break;</span>
            case JavaSQLTypes.ASCII_STREAM:
<span class="nc" id="L1530">                s = (Sized) val;</span>
<span class="nc" id="L1531">                setAsciiStream(stmnt, idx, (InputStream) s.value, s.size, col);</span>
<span class="nc" id="L1532">                break;</span>
            case JavaSQLTypes.BINARY_STREAM:
<span class="nc" id="L1534">                s = (Sized) val;</span>
<span class="nc" id="L1535">                setBinaryStream(stmnt, idx, (InputStream) s.value, s.size, col);</span>
<span class="nc" id="L1536">                break;</span>
            case JavaSQLTypes.BLOB:
<span class="nc" id="L1538">                setBlob(stmnt, idx, (Blob) val, col);</span>
<span class="nc" id="L1539">                break;</span>
            case JavaSQLTypes.BYTES:
<span class="nc" id="L1541">                setBytes(stmnt, idx, (byte[]) val, col);</span>
<span class="nc" id="L1542">                break;</span>
            case JavaSQLTypes.CHAR_STREAM:
<span class="nc" id="L1544">                s = (Sized) val;</span>
<span class="nc" id="L1545">                setCharacterStream(stmnt, idx, (Reader) s.value, s.size, col);</span>
<span class="nc" id="L1546">                break;</span>
            case JavaSQLTypes.CLOB:
<span class="nc" id="L1548">                setClob(stmnt, idx, (Clob) val, col);</span>
<span class="nc" id="L1549">                break;</span>
            case JavaSQLTypes.SQL_DATE:
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                if (val instanceof Calendard) {</span>
<span class="nc" id="L1552">                    c = (Calendard) val;</span>
<span class="nc" id="L1553">                    setDate(stmnt, idx, (java.sql.Date) c.value, c.calendar,</span>
                        col);
                } else
<span class="nc" id="L1556">                    setDate(stmnt, idx, (java.sql.Date) val, null, col);</span>
<span class="nc" id="L1557">                break;</span>
            case JavaSQLTypes.REF:
<span class="nc" id="L1559">                setRef(stmnt, idx, (Ref) val, col);</span>
<span class="nc" id="L1560">                break;</span>
            case JavaSQLTypes.TIME:
<span class="nc bnc" id="L1562" title="All 2 branches missed.">                if (val instanceof Calendard) {</span>
<span class="nc" id="L1563">                    c = (Calendard) val;</span>
<span class="nc" id="L1564">                    setTime(stmnt, idx, (Time) c.value, c.calendar, col);</span>
                } else
<span class="nc" id="L1566">                    setTime(stmnt, idx, (Time) val, null, col);</span>
<span class="nc" id="L1567">                break;</span>
            case JavaSQLTypes.TIMESTAMP:
<span class="nc bnc" id="L1569" title="All 2 branches missed.">                if (val instanceof Calendard) {</span>
<span class="nc" id="L1570">                    c = (Calendard) val;</span>
<span class="nc" id="L1571">                    setTimestamp(stmnt, idx, (Timestamp) c.value, c.calendar,</span>
                        col);
                } else
<span class="nc" id="L1574">                    setTimestamp(stmnt, idx, (Timestamp) val, null, col);</span>
<span class="nc" id="L1575">                break;</span>
            default:
<span class="nc bnc" id="L1577" title="All 4 branches missed.">                if (col != null &amp;&amp; (col.getType() == Types.BLOB</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">                    || col.getType() == Types.VARBINARY))</span>
<span class="nc" id="L1579">                    setBlobObject(stmnt, idx, val, col, store);</span>
                else
<span class="nc" id="L1581">                    setObject(stmnt, idx, val, col.getType(), col);</span>
        }
<span class="nc" id="L1583">    }</span>

    /**
     * Set a completely unknown parameter into a prepared statement.
     */
    public void setUnknown(PreparedStatement stmt, int idx, Object val, Column col) throws SQLException {
<span class="nc bnc" id="L1589" title="All 2 branches missed.">        if (val instanceof Object[]) {</span>
<span class="nc" id="L1590">            Object[] valArray = (Object[])val;</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">            for (Object object : valArray) {</span>
<span class="nc" id="L1592">                setUnknown(stmt, idx, col, object);</span>
            }
<span class="nc" id="L1594">        } else {</span>
<span class="nc" id="L1595">            setUnknown(stmt, idx, col, val);</span>
        }
<span class="nc" id="L1597">    }</span>

    /**
     * Set a completely unknown parameter into a prepared statement.
     */
    public void setUnknown(PreparedStatement stmnt, int idx, Column col, Object val) throws SQLException {
<span class="nc" id="L1603">        Sized sized = null;</span>
<span class="nc" id="L1604">        Calendard cald = null;</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">        if (val instanceof Sized) {</span>
<span class="nc" id="L1606">            sized = (Sized) val;</span>
<span class="nc" id="L1607">            val = sized.value;</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">        } else if (val instanceof Calendard) {</span>
<span class="nc" id="L1609">            cald = (Calendard) val;</span>
<span class="nc" id="L1610">            val = cald.value;</span>
        }

<span class="nc bnc" id="L1613" title="All 2 branches missed.">        if (val == null)</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">            setNull(stmnt, idx, (col == null) ? Types.OTHER : col.getType(),</span>
                col);
<span class="nc bnc" id="L1616" title="All 2 branches missed.">        else if (val instanceof String)</span>
<span class="nc" id="L1617">            setString(stmnt, idx, val.toString(), col);</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">        else if (val instanceof Integer)</span>
<span class="nc" id="L1619">            setInt(stmnt, idx, ((Integer) val).intValue(), col);</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">        else if (val instanceof Boolean)</span>
<span class="nc" id="L1621">            setBoolean(stmnt, idx, ((Boolean) val).booleanValue(), col);</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">        else if (val instanceof Long)</span>
<span class="nc" id="L1623">            setLong(stmnt, idx, ((Long) val).longValue(), col);</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">        else if (val instanceof Float)</span>
<span class="nc" id="L1625">            setFloat(stmnt, idx, ((Float) val).floatValue(), col);</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">        else if (val instanceof Double)</span>
<span class="nc" id="L1627">            setDouble(stmnt, idx, ((Double) val).doubleValue(), col);</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">        else if (val instanceof Byte)</span>
<span class="nc" id="L1629">            setByte(stmnt, idx, ((Byte) val).byteValue(), col);</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">        else if (val instanceof Character)</span>
<span class="nc" id="L1631">            setChar(stmnt, idx, ((Character) val).charValue(), col);</span>
<span class="nc bnc" id="L1632" title="All 2 branches missed.">        else if (val instanceof Short)</span>
<span class="nc" id="L1633">            setShort(stmnt, idx, ((Short) val).shortValue(), col);</span>
<span class="nc bnc" id="L1634" title="All 2 branches missed.">        else if (val instanceof Locale)</span>
<span class="nc" id="L1635">            setLocale(stmnt, idx, (Locale) val, col);</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">        else if (val instanceof BigDecimal)</span>
<span class="nc" id="L1637">            setBigDecimal(stmnt, idx, (BigDecimal) val, col);</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">        else if (val instanceof BigInteger)</span>
<span class="nc" id="L1639">            setBigInteger(stmnt, idx, (BigInteger) val, col);</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">        else if (val instanceof Array)</span>
<span class="nc" id="L1641">            setArray(stmnt, idx, (Array) val, col);</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">        else if (val instanceof Blob)</span>
<span class="nc" id="L1643">            setBlob(stmnt, idx, (Blob) val, col);</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">        else if (val instanceof byte[])</span>
<span class="nc" id="L1645">            setBytes(stmnt, idx, (byte[]) val, col);</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">        else if (val instanceof Clob)</span>
<span class="nc" id="L1647">            setClob(stmnt, idx, (Clob) val, col);</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">        else if (val instanceof Ref)</span>
<span class="nc" id="L1649">            setRef(stmnt, idx, (Ref) val, col);</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">        else if (val instanceof java.sql.Date)</span>
<span class="nc" id="L1651">            setDate(stmnt, idx, (java.sql.Date) val,</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">                (cald == null) ? null : cald.calendar, col);</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">        else if (val instanceof Timestamp)</span>
<span class="nc" id="L1654">            setTimestamp(stmnt, idx, (Timestamp) val,</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">                (cald == null) ? null : cald.calendar, col);</span>
<span class="nc bnc" id="L1656" title="All 2 branches missed.">        else if (val instanceof Time)</span>
<span class="nc" id="L1657">            setTime(stmnt, idx, (Time) val,</span>
<span class="nc bnc" id="L1658" title="All 2 branches missed.">                (cald == null) ? null : cald.calendar, col);</span>
<span class="nc bnc" id="L1659" title="All 2 branches missed.">        else if (val instanceof Date)</span>
<span class="nc" id="L1660">            setDate(stmnt, idx, (Date) val, col);</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">        else if (val instanceof Calendar)</span>
<span class="nc" id="L1662">            setDate(stmnt, idx, ((Calendar) val).getTime(), col);</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">        else if (val instanceof LocalDate) {</span>
<span class="nc" id="L1664">            setLocalDate(stmnt, idx, (LocalDate) val, col);</span>
        }
<span class="nc bnc" id="L1666" title="All 2 branches missed.">        else if (val instanceof LocalTime) {</span>
<span class="nc" id="L1667">            setLocalTime(stmnt, idx, (LocalTime) val, col);</span>
        }
<span class="nc bnc" id="L1669" title="All 2 branches missed.">        else if (val instanceof LocalDateTime) {</span>
<span class="nc" id="L1670">            setLocalDateTime(stmnt, idx, (LocalDateTime) val, col);</span>
        }
<span class="nc bnc" id="L1672" title="All 2 branches missed.">        else if (val instanceof Reader)</span>
<span class="nc" id="L1673">            setCharacterStream(stmnt, idx, (Reader) val,</span>
<span class="nc bnc" id="L1674" title="All 2 branches missed.">                (sized == null) ? 0 : sized.size, col);</span>
        else
<span class="nc" id="L1676">            throw new UserException(_loc.get(&quot;bad-param&quot;, val.getClass()));</span>
<span class="nc" id="L1677">    }</span>

    /**
     * Return the serialized bytes for the given object.
     */
    public byte[] serialize(Object val, JDBCStore store)
        throws SQLException {
<span class="nc bnc" id="L1684" title="All 2 branches missed.">        if (val == null)</span>
<span class="nc" id="L1685">            return null;</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">        if (val instanceof SerializedData)</span>
<span class="nc" id="L1687">            return ((SerializedData) val).bytes;</span>
<span class="nc" id="L1688">        return Serialization.serialize(val, store.getContext());</span>
    }

    /**
     * Invoke the JDK 1.4 &lt;code&gt;setBytes&lt;/code&gt; method on the given BLOB object.
     */
    public void putBytes(Blob blob, byte[] data)
        throws SQLException {
<span class="nc" id="L1696">        blob.setBytes(1L, data);</span>
<span class="nc" id="L1697">    }</span>

    /**
     * Invoke the JDK 1.4 &lt;code&gt;setString&lt;/code&gt; method on the given CLOB
     * object.
     */
    public void putString(Clob clob, String data)
        throws SQLException {
<span class="nc" id="L1705">        clob.setString(1L, data);</span>
<span class="nc" id="L1706">    }</span>

    /**
     * Invoke the JDK 1.4 &lt;code&gt;setCharacterStream&lt;/code&gt; method on the given
     * CLOB object.
     */
    public void putChars(Clob clob, char[] data)
        throws SQLException {
<span class="nc" id="L1714">        Writer writer = clob.setCharacterStream(1L);</span>
        try {
<span class="nc" id="L1716">            writer.write(data);</span>
<span class="nc" id="L1717">            writer.flush();</span>
<span class="nc" id="L1718">        } catch (IOException ioe) {</span>
<span class="nc" id="L1719">            throw new SQLException(ioe.toString());</span>
<span class="nc" id="L1720">        }</span>
<span class="nc" id="L1721">    }</span>

    /**
     * Warn that a particular value could not be stored precisely.
     * After the first warning for a particular type, messages
     * will be turned into trace messages.
     */
    protected void storageWarning(Object orig, Object converted) {
        boolean warn;
<span class="nc" id="L1730">        synchronized (this) {</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">            if (_precisionWarnedTypes == null)</span>
<span class="nc" id="L1732">                _precisionWarnedTypes = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1733">            warn = _precisionWarnedTypes.add(orig.getClass());</span>
<span class="nc" id="L1734">        }</span>

<span class="nc bnc" id="L1736" title="All 8 branches missed.">        if (storageLimitationsFatal || (warn &amp;&amp; log.isWarnEnabled())</span>
<span class="nc bnc" id="L1737" title="All 2 branches missed.">            || (!warn &amp;&amp; log.isTraceEnabled())) {</span>
<span class="nc" id="L1738">            Message msg = _loc.get(&quot;storage-restriction&quot;, new Object[]{</span>
                platform,
                orig,
<span class="nc" id="L1741">                orig.getClass().getName(),</span>
                converted,
            });

<span class="nc bnc" id="L1745" title="All 2 branches missed.">            if (storageLimitationsFatal)</span>
<span class="nc" id="L1746">                throw new StoreException(msg);</span>

<span class="nc bnc" id="L1748" title="All 2 branches missed.">            if (warn)</span>
<span class="nc" id="L1749">                log.warn(msg);</span>
            else
<span class="nc" id="L1751">                log.trace(msg);</span>
        }
<span class="nc" id="L1753">    }</span>

    /////////
    // Types
    /////////

    /**
     * Return the preferred {@link Types} constant for the given
     * {@link JavaTypes} or {@link JavaSQLTypes} constant.
     */
    public int getJDBCType(int metaTypeCode, boolean lob) {
<span class="nc" id="L1764">        return getJDBCType(metaTypeCode, lob, 0, 0);</span>
    }

    /**
     * Return the preferred {@link Types} constant for the given
     * {@link JavaTypes} or {@link JavaSQLTypes} constant.
     */
    public int getJDBCType(int metaTypeCode, boolean lob, int precis,
        int scale, boolean xml) {
<span class="nc" id="L1773">        return getJDBCType(metaTypeCode, lob, precis, scale);</span>
    }

    /**
     * Return the preferred {@link Types} constant for the given
     * {@link JavaTypes} or {@link JavaSQLTypes} constant.
     */
    public int getJDBCType(int metaTypeCode, boolean lob, int precis,
        int scale) {
<span class="nc bnc" id="L1782" title="All 2 branches missed.">        if (lob) {</span>
<span class="nc bnc" id="L1783" title="All 2 branches missed.">            switch (metaTypeCode) {</span>
                case JavaTypes.STRING:
                case JavaSQLTypes.ASCII_STREAM:
                case JavaSQLTypes.CHAR_STREAM:
<span class="nc" id="L1787">                    return getPreferredType(Types.CLOB);</span>
                default:
<span class="nc" id="L1789">                    return getPreferredType(Types.BLOB);</span>
            }
        }

<span class="nc bnc" id="L1793" title="All 25 branches missed.">        switch (metaTypeCode) {</span>
            case JavaTypes.BOOLEAN:
            case JavaTypes.BOOLEAN_OBJ:
<span class="nc" id="L1796">                return getPreferredType(Types.BIT);</span>
            case JavaTypes.BYTE:
            case JavaTypes.BYTE_OBJ:
<span class="nc" id="L1799">                return getPreferredType(Types.TINYINT);</span>
            case JavaTypes.CHAR:
            case JavaTypes.CHAR_OBJ:
<span class="nc bnc" id="L1802" title="All 2 branches missed.">                if (storeCharsAsNumbers)</span>
<span class="nc" id="L1803">                    return getPreferredType(Types.INTEGER);</span>
<span class="nc" id="L1804">                return getPreferredType(Types.CHAR);</span>
            case JavaTypes.DOUBLE:
            case JavaTypes.DOUBLE_OBJ:
<span class="nc bnc" id="L1807" title="All 4 branches missed.">                if(precis &gt; 0 || scale &gt; 0) {</span>
<span class="nc" id="L1808">                    return getPreferredType(Types.NUMERIC);</span>
                }
                else {
<span class="nc" id="L1811">                    return getPreferredType(Types.DOUBLE);</span>
                }
            case JavaTypes.FLOAT:
            case JavaTypes.FLOAT_OBJ:
<span class="nc bnc" id="L1815" title="All 4 branches missed.">                if(precis &gt; 0 || scale &gt; 0) {</span>
<span class="nc" id="L1816">                    return getPreferredType(Types.NUMERIC);</span>
                }
                else {
<span class="nc" id="L1819">                    return getPreferredType(Types.REAL);</span>
                }
            case JavaTypes.INT:
            case JavaTypes.INT_OBJ:
<span class="nc" id="L1823">                return getPreferredType(Types.INTEGER);</span>
            case JavaTypes.LONG:
            case JavaTypes.LONG_OBJ:
<span class="nc" id="L1826">                return getPreferredType(Types.BIGINT);</span>
            case JavaTypes.SHORT:
            case JavaTypes.SHORT_OBJ:
<span class="nc" id="L1829">                return getPreferredType(Types.SMALLINT);</span>
            case JavaTypes.STRING:
            case JavaTypes.LOCALE:
            case JavaSQLTypes.ASCII_STREAM:
            case JavaSQLTypes.CHAR_STREAM:
<span class="nc" id="L1834">                return getPreferredType(Types.VARCHAR);</span>
            case JavaTypes.BIGINTEGER:
<span class="nc bnc" id="L1836" title="All 2 branches missed.">                if (storeLargeNumbersAsStrings)</span>
<span class="nc" id="L1837">                    return getPreferredType(Types.VARCHAR);</span>
<span class="nc" id="L1838">                return getPreferredType(Types.BIGINT);</span>
            case JavaTypes.BIGDECIMAL:
<span class="nc bnc" id="L1840" title="All 2 branches missed.">                if (storeLargeNumbersAsStrings)</span>
<span class="nc" id="L1841">                    return getPreferredType(Types.VARCHAR);</span>
<span class="nc" id="L1842">                return getPreferredType(Types.NUMERIC);</span>
            case JavaTypes.NUMBER:
<span class="nc bnc" id="L1844" title="All 2 branches missed.">                if (storeLargeNumbersAsStrings)</span>
<span class="nc" id="L1845">                    return getPreferredType(Types.VARCHAR);</span>
<span class="nc" id="L1846">                return getPreferredType(Types.NUMERIC);</span>
            case JavaTypes.CALENDAR:
            case JavaTypes.DATE:
<span class="nc" id="L1849">                return getPreferredType(Types.TIMESTAMP);</span>
            case JavaTypes.LOCAL_DATE:
<span class="nc" id="L1851">                return getPreferredType(Types.DATE);</span>
            case JavaTypes.LOCAL_TIME:
<span class="nc" id="L1853">                return getPreferredType(Types.TIME);</span>
            case JavaTypes.LOCAL_DATETIME:
<span class="nc" id="L1855">                return getPreferredType(Types.TIMESTAMP);</span>
            case JavaTypes.OFFSET_TIME:
<span class="nc" id="L1857">                return getPreferredType(Types.TIME_WITH_TIMEZONE);</span>
            case JavaTypes.OFFSET_DATETIME:
<span class="nc" id="L1859">                return getPreferredType(Types.TIMESTAMP_WITH_TIMEZONE);</span>
            case JavaSQLTypes.SQL_ARRAY:
<span class="nc" id="L1861">                return getPreferredType(Types.ARRAY);</span>
            case JavaSQLTypes.BINARY_STREAM:
            case JavaSQLTypes.BLOB:
            case JavaSQLTypes.BYTES:
<span class="nc" id="L1865">                return getPreferredType(Types.BLOB);</span>
            case JavaSQLTypes.CLOB:
<span class="nc" id="L1867">                return getPreferredType(Types.CLOB);</span>
            case JavaSQLTypes.SQL_DATE:
<span class="nc" id="L1869">                return getPreferredType(Types.DATE);</span>
            case JavaSQLTypes.TIME:
<span class="nc" id="L1871">                return getPreferredType(Types.TIME);</span>
            case JavaSQLTypes.TIMESTAMP:
<span class="nc" id="L1873">                return getPreferredType(Types.TIMESTAMP);</span>
            default:
<span class="nc" id="L1875">                return getPreferredType(Types.BLOB);</span>
        }
    }

    /**
     * Return the preferred {@link Types} type for the given one. Returns
     * the given type by default.
     */
    public int getPreferredType(int type) {
<span class="nc" id="L1884">        return type;</span>
    }

    /**
     * Return the preferred database type name for the given column's type
     * from {@link Types}.
     */
    public String getTypeName(Column col) {
<span class="nc bnc" id="L1892" title="All 2 branches missed.">        if (!DBIdentifier.isEmpty(col.getTypeIdentifier()))</span>
<span class="nc" id="L1893">            return appendSize(col, toDBName(col.getTypeIdentifier()));</span>

<span class="nc bnc" id="L1895" title="All 4 branches missed.">        if (col.isAutoAssigned() &amp;&amp; autoAssignTypeName != null)</span>
<span class="nc" id="L1896">            return appendSize(col, autoAssignTypeName);</span>

<span class="nc" id="L1898">        return appendSize(col, getTypeName(col.getType()));</span>
    }

    /**
     * Returns the type name for the specific constant as defined
     * by {@link java.sql.Types}.
     *
     * @param type the type
     * @return the name for the type
     */
    public String getTypeName(int type) {
<span class="nc bnc" id="L1909" title="All 32 branches missed.">        switch (type) {</span>
            case Types.ARRAY:
<span class="nc" id="L1911">                return arrayTypeName;</span>
            case Types.BIGINT:
<span class="nc" id="L1913">                return bigintTypeName;</span>
            case Types.BINARY:
<span class="nc" id="L1915">                return binaryTypeName;</span>
            case Types.BIT:
<span class="nc" id="L1917">                return bitTypeName;</span>
            case Types.BLOB:
<span class="nc" id="L1919">                return blobTypeName;</span>
            case Types.BOOLEAN:
<span class="nc" id="L1921">                return booleanTypeName;</span>
            case Types.CHAR:
<span class="nc" id="L1923">                return charTypeName;</span>
            case Types.CLOB:
<span class="nc" id="L1925">                return clobTypeName;</span>
            case Types.DATE:
<span class="nc" id="L1927">                return dateTypeName;</span>
            case Types.DECIMAL:
<span class="nc" id="L1929">                return decimalTypeName;</span>
            case Types.DISTINCT:
<span class="nc" id="L1931">                return distinctTypeName;</span>
            case Types.DOUBLE:
<span class="nc" id="L1933">                return doubleTypeName;</span>
            case Types.FLOAT:
<span class="nc" id="L1935">                return floatTypeName;</span>
            case Types.INTEGER:
<span class="nc" id="L1937">                return integerTypeName;</span>
            case Types.JAVA_OBJECT:
<span class="nc" id="L1939">                return javaObjectTypeName;</span>
            case Types.LONGVARBINARY:
<span class="nc" id="L1941">                return longVarbinaryTypeName;</span>
            case Types.LONGVARCHAR:
<span class="nc" id="L1943">                return longVarcharTypeName;</span>
            case Types.NULL:
<span class="nc" id="L1945">                return nullTypeName;</span>
            case Types.NUMERIC:
<span class="nc" id="L1947">                return numericTypeName;</span>
            case Types.OTHER:
<span class="nc" id="L1949">                return otherTypeName;</span>
            case Types.REAL:
<span class="nc" id="L1951">                return realTypeName;</span>
            case Types.REF:
<span class="nc" id="L1953">                return refTypeName;</span>
            case Types.SMALLINT:
<span class="nc" id="L1955">                return smallintTypeName;</span>
            case Types.STRUCT:
<span class="nc" id="L1957">                return structTypeName;</span>
            case Types.TIME:
<span class="nc" id="L1959">                return timeTypeName;</span>
            case Types.TIMESTAMP:
<span class="nc" id="L1961">                return timestampTypeName;</span>
            case Types.TIME_WITH_TIMEZONE:
<span class="nc" id="L1963">                return timeWithZoneTypeName;</span>
            case Types.TIMESTAMP_WITH_TIMEZONE:
<span class="nc" id="L1965">                return timestampWithZoneTypeName;</span>
            case Types.TINYINT:
<span class="nc" id="L1967">                return tinyintTypeName;</span>
            case Types.VARBINARY:
<span class="nc" id="L1969">                return varbinaryTypeName;</span>
            case Types.VARCHAR:
<span class="nc" id="L1971">                return varcharTypeName;</span>
            default:
<span class="nc" id="L1973">                return otherTypeName;</span>
        }
    }

    /**
     * Helper method to add size properties to the specified type.
     * If present, the string &quot;{0}&quot; will be replaced with the size definition;
     * otherwise the size definition will be appended to the type name.
     * If your database has column types that don't allow size definitions,
     * override this method to return the unaltered type name for columns of
     * those types (or add the type names to the
     * &lt;code&gt;fixedSizeTypeNameSet&lt;/code&gt;).
     *
     * &lt;P&gt;Some databases support &quot;type modifiers&quot;, for example the unsigned
     * &quot;modifier&quot; in MySQL. In these cases the size should go between the type
     * and the &quot;modifier&quot;, instead of after the modifier. For example
     * CREATE table FOO ( myint INT (10) UNSIGNED . . .) instead of
     * CREATE table FOO ( myint INT UNSIGNED (10) . . .).
     * Type modifiers should be added to &lt;code&gt;typeModifierSet&lt;/code&gt; in
     * subclasses.
     */
    protected String appendSize(Column col, String typeName) {
<span class="nc" id="L1995">        String upperCaseTypeName = typeName.toUpperCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">        if (fixedSizeTypeNameSet.contains(upperCaseTypeName)) {</span>
<span class="nc" id="L1997">            return typeName;</span>
        }
<span class="nc bnc" id="L1999" title="All 2 branches missed.">        if (typeName.indexOf('(') != -1) {</span>
<span class="nc" id="L2000">            return typeName;</span>
        }


<span class="nc" id="L2004">        String size = null;</span>
<span class="nc" id="L2005">        int colSize = col.getSize();</span>

<span class="nc bnc" id="L2007" title="All 4 branches missed.">        if (colSize&lt;=0  &amp;&amp; fractionalTypeNameSet.contains(upperCaseTypeName)){</span>
            // special handling for types with fractions
            // Attention! We abuse @Column(scale=n)
            // One can disable all fractions with @Column(scale=-1)
<span class="nc bnc" id="L2011" title="All 2 branches missed.">            if (col.getDecimalDigits() != 0) { // the default</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">                colSize = col.getDecimalDigits() == -1 ? 0 : col.getDecimalDigits();</span>
            }
            else {
<span class="nc" id="L2015">                colSize = getDateFractionDigits(col, typeName);</span>
            }
<span class="nc" id="L2017">            size = &quot;(&quot; + colSize + &quot;)&quot;;</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">        } else if (colSize &gt; 0) {</span>
<span class="nc" id="L2019">            StringBuilder buf = new StringBuilder(10);</span>
<span class="nc" id="L2020">            buf.append(&quot;(&quot;).append(colSize);</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">            if (col.getDecimalDigits() &gt; 0)</span>
<span class="nc" id="L2022">                buf.append(&quot;, &quot;).append(col.getDecimalDigits());</span>
<span class="nc" id="L2023">            buf.append(&quot;)&quot;);</span>
<span class="nc" id="L2024">            size = buf.toString();</span>
        }

<span class="nc" id="L2027">        return insertSize(typeName, size);</span>
    }

    /**
     * Only get's used if no explicit scale is used (@{code @Column(scale=0)} which is the default).
     * Attention! @{code @Column(scale=-1)} disables the scale of a column
     * @return the fraction length of types which have a fraction
     * @see #fractionalTypeNameSet
     */
    protected int getDateFractionDigits(Column col, String typeName) {
<span class="nc" id="L2037">        return dateFractionDigits;</span>
    }

    /**
     * Helper method that inserts a size clause for a given SQL type.
     *
     * @param typeName  The SQL type e.g. INT
     * @param size      The size clause e.g. (10)
     * @return          The typeName + size clause. Usually the size clause will
     *                  be appended to typeName. If the typeName contains a
     *                  marker : {0} or if typeName contains a modifier the
     *                  size clause will be inserted appropriately.
     */
    protected String insertSize(String typeName, String size) {
<span class="nc bnc" id="L2051" title="All 2 branches missed.">        if (StringUtil.isEmpty(size)) {</span>
<span class="nc" id="L2052">            int idx = typeName.indexOf(&quot;{0}&quot;);</span>
<span class="nc bnc" id="L2053" title="All 2 branches missed.">            if (idx != -1) {</span>
<span class="nc" id="L2054">                return typeName.substring(0, idx);</span>
            }
<span class="nc" id="L2056">            return typeName;</span>
        }

<span class="nc" id="L2059">        int idx = typeName.indexOf(&quot;{0}&quot;);</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">        if (idx != -1) {</span>
            // replace '{0}' with size
<span class="nc" id="L2062">            String ret = typeName.substring(0, idx);</span>
<span class="nc bnc" id="L2063" title="All 2 branches missed.">            if (size != null)</span>
<span class="nc" id="L2064">                ret = ret + size;</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">            if (typeName.length() &gt; idx + 3)</span>
<span class="nc" id="L2066">                ret = ret + typeName.substring(idx + 3);</span>
<span class="nc" id="L2067">            return ret;</span>
        }
<span class="nc bnc" id="L2069" title="All 2 branches missed.">        if (!typeModifierSet.isEmpty()) {</span>
            String s;
<span class="nc" id="L2071">            idx = typeName.length();</span>
<span class="nc" id="L2072">            int curIdx = -1;</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">            for (Iterator&lt;String&gt; i = typeModifierSet.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2074">                s = i.next();</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">                if (typeName.toUpperCase(Locale.ENGLISH).indexOf(s) != -1) {</span>
<span class="nc" id="L2076">                    curIdx = typeName.toUpperCase(Locale.ENGLISH).indexOf(s);</span>
<span class="nc bnc" id="L2077" title="All 4 branches missed.">                    if (curIdx != -1 &amp;&amp; curIdx &lt; idx) {</span>
<span class="nc" id="L2078">                        idx = curIdx;</span>
                    }
                }
            }
<span class="nc bnc" id="L2082" title="All 2 branches missed.">            if(idx != typeName.length()) {</span>
<span class="nc" id="L2083">                String ret = typeName.substring(0, idx);</span>
<span class="nc" id="L2084">                ret = ret + size;</span>
<span class="nc" id="L2085">                ret = ret + ' ' + typeName.substring(idx);</span>
<span class="nc" id="L2086">                return ret;</span>
            }
        }
<span class="nc" id="L2089">        return typeName + size;</span>
    }

    ///////////
    // Selects
    ///////////

    /**
     * Set the name of the join syntax to use: sql92, traditional, database.
     */
    public void setJoinSyntax(String syntax) {
<span class="nc bnc" id="L2100" title="All 2 branches missed.">        if (&quot;sql92&quot;.equals(syntax))</span>
<span class="nc" id="L2101">            joinSyntax = SYNTAX_SQL92;</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">        else if (&quot;traditional&quot;.equals(syntax))</span>
<span class="nc" id="L2103">            joinSyntax = SYNTAX_TRADITIONAL;</span>
<span class="nc bnc" id="L2104" title="All 2 branches missed.">        else if (&quot;database&quot;.equals(syntax))</span>
<span class="nc" id="L2105">            joinSyntax = SYNTAX_DATABASE;</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">        else if (!StringUtil.isEmpty(syntax))</span>
<span class="nc" id="L2107">            throw new IllegalArgumentException(syntax);</span>
<span class="nc" id="L2108">    }</span>

    public boolean isImplicitJoin() {
<span class="nc" id="L2111">        return false;</span>
    }

    /**
     * Return a SQL string to act as a placeholder for the given column.
     */
    public String getPlaceholderValueString(Column col) {
<span class="nc bnc" id="L2118" title="All 8 branches missed.">        switch (col.getType()) {</span>
            case Types.BIGINT:
            case Types.BIT:
            case Types.INTEGER:
            case Types.NUMERIC:
            case Types.SMALLINT:
            case Types.TINYINT:
<span class="nc" id="L2125">                return &quot;0&quot;;</span>
            case Types.CHAR:
<span class="nc bnc" id="L2127" title="All 2 branches missed.">                return (storeCharsAsNumbers) ? &quot;0&quot; : &quot;' '&quot;;</span>
            case Types.CLOB:
            case Types.LONGVARCHAR:
            case Types.VARCHAR:
<span class="nc" id="L2131">                return &quot;''&quot;;</span>
            case Types.DATE:
<span class="nc" id="L2133">                return ZERO_DATE_STR;</span>
            case Types.DECIMAL:
            case Types.DOUBLE:
            case Types.FLOAT:
            case Types.REAL:
<span class="nc" id="L2138">                return &quot;0.0&quot;;</span>
            case Types.TIME:
<span class="nc" id="L2140">                return ZERO_TIME_STR;</span>
            case Types.TIMESTAMP:
<span class="nc" id="L2142">                return ZERO_TIMESTAMP_STR;</span>
            default:
<span class="nc" id="L2144">                return &quot;NULL&quot;;</span>
        }
    }

    /**
     * Create a SELECT COUNT statement in the proper join syntax for the
     * given instance.
     */
    public SQLBuffer toSelectCount(Select sel) {
<span class="nc" id="L2153">        SQLBuffer selectSQL = new SQLBuffer(this);</span>
        SQLBuffer from;
<span class="nc" id="L2155">        sel.addJoinClassConditions();</span>
<span class="nc bnc" id="L2156" title="All 2 branches missed.">        if (sel.getFromSelect() != null)</span>
<span class="nc" id="L2157">            from = getFromSelect(sel, false);</span>
        else
<span class="nc" id="L2159">            from = getFrom(sel, false);</span>
<span class="nc" id="L2160">        SQLBuffer where = getWhere(sel, false);</span>

        // if no grouping and no range, we might be able to get by without
        // a subselect
<span class="nc bnc" id="L2164" title="All 4 branches missed.">        if (sel.getGrouping() == null &amp;&amp; sel.getStartIndex() == 0</span>
<span class="nc bnc" id="L2165" title="All 2 branches missed.">            &amp;&amp; sel.getEndIndex() == Long.MAX_VALUE) {</span>
            // if the select has no identifier cols, use COUNT(*)
<span class="nc bnc" id="L2167" title="All 2 branches missed.">            List aliases = (!sel.isDistinct()) ? Collections.EMPTY_LIST</span>
<span class="nc" id="L2168">                : sel.getIdentifierAliases();</span>
<span class="nc bnc" id="L2169" title="All 4 branches missed.">            if (useWildCardForCount || aliases.isEmpty()) {</span>
<span class="nc" id="L2170">                selectSQL.append(&quot;COUNT(*)&quot;);</span>
<span class="nc" id="L2171">                return toSelect(selectSQL, null, from, where, null, null, null,</span>
                    false, false, 0, Long.MAX_VALUE);
            }

            // if there is a single distinct col, use COUNT(DISTINCT col)
<span class="nc bnc" id="L2176" title="All 2 branches missed.">            if (aliases.size() == 1) {</span>
<span class="nc" id="L2177">                selectSQL.append(&quot;COUNT(DISTINCT &quot;).</span>
<span class="nc" id="L2178">                    append(aliases.get(0).toString()).append(&quot;)&quot;);</span>
<span class="nc" id="L2179">                return toSelect(selectSQL, null, from, where, null, null, null,</span>
                    false, false, 0, Long.MAX_VALUE);
            }

            // can we combine distinct cols?
<span class="nc bnc" id="L2184" title="All 2 branches missed.">            if (distinctCountColumnSeparator != null) {</span>
<span class="nc" id="L2185">                selectSQL.append(&quot;COUNT(DISTINCT &quot;);</span>
<span class="nc bnc" id="L2186" title="All 2 branches missed.">                for (int i = 0; i &lt; aliases.size(); i++) {</span>
<span class="nc bnc" id="L2187" title="All 2 branches missed.">                    if (i &gt; 0) {</span>
<span class="nc" id="L2188">                        selectSQL.append(&quot; &quot;);</span>
<span class="nc" id="L2189">                        selectSQL.append(distinctCountColumnSeparator);</span>
<span class="nc" id="L2190">                        selectSQL.append(&quot; &quot;);</span>
                    }
<span class="nc" id="L2192">                    selectSQL.append(aliases.get(i).toString());</span>
                }
<span class="nc" id="L2194">                selectSQL.append(&quot;)&quot;);</span>
<span class="nc" id="L2195">                return toSelect(selectSQL, null, from, where, null, null, null,</span>
                    false, false, 0, Long.MAX_VALUE);
            }
        }

        // since we can't combine distinct cols, we have to perform an outer
        // COUNT(*) select using the original select as a subselect in the
        // FROM clause
<span class="nc" id="L2203">        assertSupport(supportsSubselect, &quot;SupportsSubselect&quot;);</span>

<span class="nc" id="L2205">        SQLBuffer subSelect = getSelects(sel, true, false);</span>
<span class="nc" id="L2206">        SQLBuffer subFrom = from;</span>
<span class="nc" id="L2207">        from = new SQLBuffer(this);</span>
<span class="nc" id="L2208">        from.append(&quot;(&quot;);</span>
<span class="nc" id="L2209">        from.append(toSelect(subSelect, null, subFrom, where,</span>
<span class="nc" id="L2210">            sel.getGrouping(), sel.getHaving(), null, sel.isDistinct(),</span>
<span class="nc" id="L2211">            false, sel.getStartIndex(), sel.getEndIndex(), true, sel));</span>
<span class="nc" id="L2212">        from.append(&quot;)&quot;);</span>
<span class="nc bnc" id="L2213" title="All 2 branches missed.">        if (requiresAliasForSubselect)</span>
<span class="nc" id="L2214">            from.append(&quot; &quot;).append(Select.FROM_SELECT_ALIAS);</span>

<span class="nc" id="L2216">        selectSQL.append(&quot;COUNT(*)&quot;);</span>
<span class="nc" id="L2217">        return toSelect(selectSQL, null, from, null, null, null, null,</span>
            false, false, 0, Long.MAX_VALUE);
    }

    /**
     * Create a DELETE statement for the specified Select. If the
     * database does not support the bulk delete statement (such as
     * cases where a subselect is required and the database doesn't support
     * subselects), this method should return null.
     */
    public SQLBuffer toDelete(ClassMapping mapping, Select sel,
        Object[] params) {
<span class="nc" id="L2229">        return toBulkOperation(mapping, sel, null, params, null);</span>
    }

    public SQLBuffer toUpdate(ClassMapping mapping, Select sel,
        JDBCStore store, Object[] params, Map updates) {
<span class="nc" id="L2234">        return toBulkOperation(mapping, sel, store, params, updates);</span>
    }

    /**
     * Returns the SQL for a bulk operation, either a DELETE or an UPDATE.
     *
     * @param mapping the mapping against which we are operating
     * @param sel the Select that will constitute the WHERE clause
     * @param store the current store
     * @param updateParams the Map that holds the update parameters; a null
     * value indicates that this is a delete operation
     * @return the SQLBuffer for the update, or &lt;em&gt;null&lt;/em&gt; if it is not
     * possible to perform the bulk update
     */
    protected SQLBuffer toBulkOperation(ClassMapping mapping, Select sel,
        JDBCStore store, Object[] params, Map updateParams) {
<span class="nc" id="L2250">        SQLBuffer sql = new SQLBuffer(this);</span>
<span class="nc bnc" id="L2251" title="All 2 branches missed.">        if (updateParams == null) {</span>
<span class="nc bnc" id="L2252" title="All 2 branches missed.">          if (requiresTargetForDelete) {</span>
<span class="nc" id="L2253">            sql.append(&quot;DELETE &quot;);</span>
<span class="nc" id="L2254">            SQLBuffer deleteTargets = getDeleteTargets(sel);</span>
<span class="nc" id="L2255">            sql.append(deleteTargets);</span>
<span class="nc" id="L2256">            sql.append(&quot; FROM &quot;);</span>
<span class="nc" id="L2257">          } else {</span>
<span class="nc" id="L2258">            sql.append(&quot;DELETE FROM &quot;);</span>
          }
        }
        else
<span class="nc" id="L2262">            sql.append(&quot;UPDATE &quot;);</span>
<span class="nc" id="L2263">        sel.addJoinClassConditions();</span>

        // if there is only a single table in the select, then we can
        // just issue a single DELETE FROM TABLE WHERE &lt;conditions&gt;
        // statement; otherwise, since SQL doesn't allow deleting
        // from one of a multi-table select, we need to issue a subselect
        // like DELETE FROM TABLE WHERE EXISTS
        // (SELECT 1 FROM TABLE t0 WHERE t0.ID = TABLE.ID); also, some
        // databases do not allow aliases in delete statements, which
        // also causes us to use a subselect
<span class="nc" id="L2273">        Collection&lt;String&gt; selectedTables = getSelectTableAliases(sel);</span>
<span class="nc bnc" id="L2274" title="All 6 branches missed.">        if (selectedTables.size() == 1 &amp;&amp; supportsSubselect</span>
            &amp;&amp; allowsAliasInBulkClause) {
            SQLBuffer from;
<span class="nc bnc" id="L2277" title="All 2 branches missed.">            if (sel.getFromSelect() != null)</span>
<span class="nc" id="L2278">                from = getFromSelect(sel, false);</span>
            else
<span class="nc" id="L2280">                from = getFrom(sel, false);</span>

<span class="nc" id="L2282">            sql.append(from);</span>
<span class="nc" id="L2283">            appendUpdates(sel, store, sql, params, updateParams,</span>
                allowsAliasInBulkClause);

<span class="nc" id="L2286">            SQLBuffer where = sel.getWhere();</span>
<span class="nc bnc" id="L2287" title="All 4 branches missed.">            if (where != null &amp;&amp; !where.isEmpty()) {</span>
<span class="nc" id="L2288">                sql.append(&quot; WHERE &quot;);</span>
<span class="nc" id="L2289">                sql.append(where);</span>
            }
<span class="nc" id="L2291">            return sql;</span>
        }

<span class="nc" id="L2294">        Table table = mapping.getTable();</span>
<span class="nc" id="L2295">        String tableName = getFullName(table, false);</span>

        // only use a  subselect if the where is not empty; otherwise
        // an unqualified delete or update will work
<span class="nc bnc" id="L2299" title="All 4 branches missed.">        if (sel.getWhere() == null || sel.getWhere().isEmpty()) {</span>
<span class="nc" id="L2300">            sql.append(tableName);</span>
<span class="nc" id="L2301">            appendUpdates(sel, store, sql, params, updateParams, false);</span>
<span class="nc" id="L2302">            return sql;</span>
        }

        // we need to use a subselect if we are to bulk delete where
        // the select includes multiple tables; if the database
        // doesn't support it, then we need to signal this by returning null
<span class="nc bnc" id="L2308" title="All 4 branches missed.">        if (!supportsSubselect || !supportsCorrelatedSubselect)</span>
<span class="nc" id="L2309">            return null;</span>

<span class="nc" id="L2311">        Column[] pks = mapping.getPrimaryKeyColumns();</span>
<span class="nc" id="L2312">        sel.clearSelects();</span>
<span class="nc" id="L2313">        sel.setDistinct(true);</span>

        // if we have only a single PK, we can use a non-correlated
        // subquery (using an IN statement), which is much faster than
        // a correlated subquery (since a correlated subquery needs
        // to be executed once for each row in the table)
<span class="nc bnc" id="L2319" title="All 2 branches missed.">        if (pks.length == 1) {</span>
<span class="nc" id="L2320">            sel.select(pks[0]);</span>
<span class="nc" id="L2321">            sql.append(tableName);</span>
<span class="nc" id="L2322">            appendUpdates(sel, store, sql, params, updateParams, false);</span>
<span class="nc" id="L2323">            sql.append(&quot; WHERE &quot;).</span>
<span class="nc" id="L2324">                append(pks[0]).append(&quot; IN (&quot;).</span>
<span class="nc" id="L2325">                append(sel.toSelect(false, null)).append(&quot;)&quot;);</span>
        } else {
<span class="nc" id="L2327">            sel.clearSelects();</span>
<span class="nc" id="L2328">            sel.setDistinct(false);</span>

            // since the select is using a correlated subquery, we
            // only need to select a bogus virtual column
<span class="nc" id="L2332">            sel.select(&quot;1&quot;, null);</span>

            // add in the joins to the table
<span class="nc" id="L2335">            Column[] cols = table.getPrimaryKey().getColumns();</span>
<span class="nc" id="L2336">            SQLBuffer buf = new SQLBuffer(this);</span>
<span class="nc" id="L2337">            buf.append(&quot;(&quot;);</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">            for (int i = 0; i &lt; cols.length; i++) {</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">                if (i &gt; 0)</span>
<span class="nc" id="L2340">                    buf.append(&quot; AND &quot;);</span>

                // add in &quot;t0.PK = MYTABLE.PK&quot;
<span class="nc" id="L2343">                buf.append(sel.getColumnAlias(cols[i])).append(&quot; = &quot;).</span>
<span class="nc" id="L2344">                    append(table).append(catalogSeparator).append(cols[i]);</span>
            }
<span class="nc" id="L2346">            buf.append(&quot;)&quot;);</span>
<span class="nc" id="L2347">            sel.where(buf, null);</span>

<span class="nc" id="L2349">            sql.append(tableName);</span>
<span class="nc" id="L2350">            appendUpdates(sel, store, sql, params, updateParams, false);</span>
<span class="nc" id="L2351">            sql.append(&quot; WHERE EXISTS (&quot;).</span>
<span class="nc" id="L2352">                append(sel.toSelect(false, null)).append(&quot;)&quot;);</span>
        }
<span class="nc" id="L2354">        return sql;</span>
    }

    protected Collection&lt;String&gt; getSelectTableAliases(Select sel) {
<span class="nc" id="L2358">        return sel.getTableAliases();</span>
    }

    protected SQLBuffer getDeleteTargets(Select sel) {
<span class="nc" id="L2362">      SQLBuffer deleteTargets = new SQLBuffer(this);</span>
<span class="nc" id="L2363">      Collection&lt;String&gt; aliases = sel.getTableAliases();</span>
      // Assumes aliases are of the form &quot;TABLENAME t0&quot;
      // or &quot;\&quot;TABLE NAME\&quot; t0&quot;
<span class="nc bnc" id="L2366" title="All 2 branches missed.">      for (Iterator&lt;String&gt; itr = aliases.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2367">        String tableAlias = itr.next();</span>
<span class="nc" id="L2368">        String[] names = Normalizer.splitName(tableAlias, IdentifierUtil.SPACE);</span>
<span class="nc bnc" id="L2369" title="All 2 branches missed.">        if (names.length &gt; 1) {</span>
<span class="nc bnc" id="L2370" title="All 2 branches missed.">          if (allowsAliasInBulkClause) {</span>
<span class="nc" id="L2371">            deleteTargets.append(names[1]);</span>
          } else {
<span class="nc" id="L2373">            deleteTargets.append(toDBName(DBIdentifier.newTable(names[0])));</span>
          }
        } else {
<span class="nc" id="L2376">          deleteTargets.append(toDBName(DBIdentifier.newTable(tableAlias)));</span>
        }
<span class="nc bnc" id="L2378" title="All 2 branches missed.">        if (itr.hasNext())</span>
<span class="nc" id="L2379">          deleteTargets.append(&quot;, &quot;);</span>
<span class="nc" id="L2380">      }</span>
<span class="nc" id="L2381">      return deleteTargets;</span>
    }

    protected void appendUpdates(Select sel, JDBCStore store, SQLBuffer sql,
        Object[] params, Map updateParams, boolean allowAlias) {
<span class="nc bnc" id="L2386" title="All 4 branches missed.">        if (updateParams == null || updateParams.size() == 0)</span>
<span class="nc" id="L2387">            return;</span>

        // manually build up the SET clause for the UPDATE statement
<span class="nc" id="L2390">        sql.append(&quot; SET &quot;);</span>
<span class="nc" id="L2391">        ExpContext ctx = new ExpContext(store, params,</span>
<span class="nc" id="L2392">            store.getFetchConfiguration());</span>

        // If the updates map contains any version fields, assume that the
        // optimistic lock version data is being handled properly by the
        // caller. Otherwise, give the version indicator an opportunity to
        // add more update clauses as needed.
<span class="nc" id="L2398">        boolean augmentUpdates = true;</span>

<span class="nc bnc" id="L2400" title="All 2 branches missed.">        for (Iterator i = updateParams.entrySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L2401">            Map.Entry next = (Map.Entry) i.next();</span>
<span class="nc" id="L2402">            Path path = (Path) next.getKey();</span>
<span class="nc" id="L2403">            FieldMapping fmd = (FieldMapping) path.last();</span>

<span class="nc bnc" id="L2405" title="All 2 branches missed.">            if (fmd.isVersion())</span>
<span class="nc" id="L2406">                augmentUpdates = false;</span>

<span class="nc" id="L2408">            Val val = (Val) next.getValue();</span>
<span class="nc bnc" id="L2409" title="All 2 branches missed.">            if (val == null)</span>
<span class="nc" id="L2410">                val = new Null();</span>
<span class="nc" id="L2411">            Column col = fmd.getColumns()[0];</span>
<span class="nc bnc" id="L2412" title="All 2 branches missed.">            if (allowAlias) {</span>
<span class="nc" id="L2413">              sql.append(sel.getColumnAlias(col));</span>
            } else {
<span class="nc" id="L2415">              sql.append(toDBName(col.getIdentifier()));</span>
            }
<span class="nc" id="L2417">            sql.append(&quot; = &quot;);</span>

<span class="nc" id="L2419">            ExpState state = val.initialize(sel, ctx, 0);</span>
            // JDBC Paths are always PCPaths; PCPath implements Val
<span class="nc" id="L2421">            ExpState pathState = ((Val) path).initialize(sel, ctx, 0);</span>
<span class="nc" id="L2422">            calculateValue(val, sel, ctx, state, path, pathState);</span>

            // append the value with a null for the Select; i
            // indicates that the
<span class="nc" id="L2426">            int length = val.length(sel, ctx, state);</span>
<span class="nc bnc" id="L2427" title="All 2 branches missed.">            for (int j = 0; j &lt; length; j++)</span>
<span class="nc bnc" id="L2428" title="All 2 branches missed.">                val.appendTo((allowAlias) ? sel : null, ctx, state, sql, j);</span>

<span class="nc bnc" id="L2430" title="All 2 branches missed.">            if (i.hasNext())</span>
<span class="nc" id="L2431">                sql.append(&quot;, &quot;);</span>
<span class="nc" id="L2432">        }</span>

<span class="nc bnc" id="L2434" title="All 2 branches missed.">        if (augmentUpdates) {</span>
<span class="nc" id="L2435">            Path path = (Path) updateParams.keySet().iterator().next();</span>
<span class="nc" id="L2436">            FieldMapping fm = (FieldMapping) path.last();</span>

<span class="nc" id="L2438">            ClassMapping meta = fm.getDefiningMapping();</span>
<span class="nc" id="L2439">            Map&lt;Column,?&gt; updates = meta.getVersion().getBulkUpdateValues();</span>
<span class="nc bnc" id="L2440" title="All 2 branches missed.">            for (Map.Entry e : updates.entrySet()) {</span>
<span class="nc" id="L2441">                Column col = (Column) e.getKey();</span>
<span class="nc" id="L2442">                Object val = e.getValue();</span>
<span class="nc" id="L2443">                sql.append(&quot;, &quot;).append(toDBName(col.getIdentifier())).append(&quot; = &quot;);</span>
                // Version update value for Numeric version is encoded in a String
                // to make SQL such as version = version+1 while Time stamp version is parameterized
<span class="nc bnc" id="L2446" title="All 2 branches missed.">                if (val instanceof String) {</span>
<span class="nc" id="L2447">                    sql.append((String)val);</span>
                } else {
<span class="nc" id="L2449">                    sql.appendValue(val);</span>
                }
<span class="nc" id="L2451">            }</span>
        }
<span class="nc" id="L2453">    }</span>

    /**
     * Create SQL to delete the contents of the specified tables.
     * The default implementation drops all non-deferred RESTRICT foreign key
     * constraints involving the specified tables, issues DELETE statements
     * against the tables, and then adds the dropped constraints back in.
     * Databases with more optimal ways of deleting the contents of several
     * tables should override this method.
     */
    public String[] getDeleteTableContentsSQL(Table[] tables,Connection conn) {
<span class="nc" id="L2464">        Collection&lt;String&gt; sql = new ArrayList&lt;&gt;();</span>

        // collect and drop non-deferred physical restrict constraints, and
        // collect the DELETE FROM statements
<span class="nc" id="L2468">        Collection&lt;String&gt; deleteSQL = new ArrayList&lt;&gt;(tables.length);</span>
<span class="nc" id="L2469">        Collection&lt;ForeignKey&gt; restrictConstraints =</span>
            new LinkedHashSet&lt;&gt;();
<span class="nc bnc" id="L2471" title="All 2 branches missed.">        for (int i = 0; i &lt; tables.length; i++) {</span>
<span class="nc" id="L2472">            ForeignKey[] fks = tables[i].getForeignKeys();</span>
<span class="nc bnc" id="L2473" title="All 2 branches missed.">            for (int j = 0; j &lt; fks.length; j++) {</span>
<span class="nc bnc" id="L2474" title="All 4 branches missed.">                if (!fks[j].isLogical() &amp;&amp; !fks[j].isDeferred()</span>
<span class="nc bnc" id="L2475" title="All 2 branches missed.">                    &amp;&amp; fks[j].getDeleteAction() == ForeignKey.ACTION_RESTRICT)</span>
<span class="nc" id="L2476">                restrictConstraints.add(fks[j]);</span>
            }

<span class="nc" id="L2479">            deleteSQL.add(&quot;DELETE FROM &quot; +</span>
<span class="nc" id="L2480">                toDBName(tables[i].getFullIdentifier()));</span>
        }

<span class="nc bnc" id="L2483" title="All 2 branches missed.">        for(ForeignKey fk : restrictConstraints) {</span>
<span class="nc" id="L2484">            String[] constraintSQL = getDropForeignKeySQL(fk,conn);</span>
<span class="nc" id="L2485">            sql.addAll(Arrays.asList(constraintSQL));</span>
<span class="nc" id="L2486">        }</span>

        // add the delete statements after all the constraint mutations
<span class="nc" id="L2489">        sql.addAll(deleteSQL);</span>

        // add the deleted constraints back to the schema
<span class="nc bnc" id="L2492" title="All 2 branches missed.">        for (ForeignKey fk : restrictConstraints) {</span>
<span class="nc" id="L2493">            String[] constraintSQL = getAddForeignKeySQL(fk);</span>
<span class="nc" id="L2494">            sql.addAll(Arrays.asList(constraintSQL));</span>
<span class="nc" id="L2495">        }</span>

<span class="nc" id="L2497">        return (String[]) sql.toArray(new String[sql.size()]);</span>
    }

    /**
     * Create a SELECT statement in the proper join syntax for the given
     * instance.
     */
    public SQLBuffer toSelect(Select sel, boolean forUpdate,
        JDBCFetchConfiguration fetch) {
<span class="nc" id="L2506">        sel.addJoinClassConditions();</span>
<span class="nc bnc" id="L2507" title="All 4 branches missed.">        boolean update = forUpdate &amp;&amp; sel.getFromSelect() == null;</span>
<span class="nc" id="L2508">        SQLBuffer select = getSelects(sel, false, update);</span>
<span class="nc" id="L2509">        SQLBuffer ordering = null;</span>
<span class="nc bnc" id="L2510" title="All 4 branches missed.">        if (!sel.isAggregate() || sel.getGrouping() != null)</span>
<span class="nc" id="L2511">            ordering = sel.getOrdering();</span>
        SQLBuffer from;
<span class="nc bnc" id="L2513" title="All 2 branches missed.">        if (sel.getFromSelect() != null)</span>
<span class="nc" id="L2514">            from = getFromSelect(sel, forUpdate);</span>
        else
<span class="nc" id="L2516">            from = getFrom(sel, update);</span>
<span class="nc" id="L2517">        SQLBuffer where = getWhere(sel, update);</span>
<span class="nc" id="L2518">        return toSelect(select, fetch, from, where, sel.getGrouping(),</span>
<span class="nc" id="L2519">            sel.getHaving(), ordering, sel.isDistinct(), forUpdate,</span>
<span class="nc" id="L2520">            sel.getStartIndex(), sel.getEndIndex(), sel);</span>
    }

    /**
     * Return the portion of the select statement between the FROM keyword
     * and the WHERE keyword.
     */
    protected SQLBuffer getFrom(Select sel, boolean forUpdate) {
<span class="nc" id="L2528">        SQLBuffer fromSQL = new SQLBuffer(this);</span>
<span class="nc" id="L2529">        Collection aliases = sel.getTableAliases();</span>
<span class="nc bnc" id="L2530" title="All 4 branches missed.">        if (aliases.size() &lt; 2 || sel.getJoinSyntax() != SYNTAX_SQL92) {</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">            for (Iterator itr = aliases.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2532">                fromSQL.append(itr.next().toString());</span>
<span class="nc bnc" id="L2533" title="All 4 branches missed.">                if (forUpdate &amp;&amp; tableForUpdateClause != null)</span>
<span class="nc" id="L2534">                    fromSQL.append(&quot; &quot;).append(tableForUpdateClause);</span>
<span class="nc bnc" id="L2535" title="All 2 branches missed.">                if (itr.hasNext())</span>
<span class="nc" id="L2536">                    fromSQL.append(&quot;, &quot;);</span>
            }
<span class="nc bnc" id="L2538" title="All 4 branches missed.">            if (aliases.size() &lt; 2 &amp;&amp; sel.getParent() != null) {</span>
                // subquery may contain correlated joins
<span class="nc" id="L2540">                Iterator itr = sel.getJoinIterator();</span>
<span class="nc bnc" id="L2541" title="All 2 branches missed.">                while (itr.hasNext()) {</span>
<span class="nc" id="L2542">                    Join join = (Join) itr.next();</span>
                    // append where clause
<span class="nc bnc" id="L2544" title="All 4 branches missed.">                    if (join.isCorrelated() &amp;&amp; join.getForeignKey() != null) {</span>
<span class="nc" id="L2545">                        SQLBuffer where = new SQLBuffer(this);</span>
<span class="nc" id="L2546">                        where.append(&quot;(&quot;).append(toTraditionalJoin(join)).append(&quot;)&quot;);</span>
<span class="nc" id="L2547">                        sel.where(where.getSQL());</span>
                    }
<span class="nc" id="L2549">                }</span>
<span class="nc" id="L2550">            }</span>
        } else {
<span class="nc" id="L2552">            Iterator itr = sel.getJoinIterator();</span>
<span class="nc" id="L2553">            boolean first = true;</span>
<span class="nc bnc" id="L2554" title="All 2 branches missed.">            while (itr.hasNext()) {</span>
<span class="nc" id="L2555">                Join join = (Join) itr.next();</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">                if (correlatedJoinCondition(join, sel))</span>
<span class="nc" id="L2557">                    continue;</span>

<span class="nc bnc" id="L2559" title="All 2 branches missed.">                if (join.isCorrelated())</span>
<span class="nc" id="L2560">                    toCorrelatedJoin(sel, join, forUpdate, first);</span>
                else
<span class="nc" id="L2562">                    fromSQL.append(toSQL92Join(sel, join, forUpdate,</span>
                        first));
<span class="nc" id="L2564">                first = false;</span>
<span class="nc bnc" id="L2565" title="All 4 branches missed.">                if (itr.hasNext() &amp;&amp; join.isCorrelated()) {</span>
<span class="nc bnc" id="L2566" title="All 2 branches missed.">                    if (fromSQL.getSQL().length() &gt; 0)</span>
<span class="nc" id="L2567">                        fromSQL.append(&quot;, &quot;);</span>
<span class="nc" id="L2568">                    first = true;</span>
                }
<span class="nc" id="L2570">            }</span>

<span class="nc bnc" id="L2572" title="All 2 branches missed.">            for (Iterator itr2 = aliases.iterator(); itr2.hasNext();) {</span>
<span class="nc" id="L2573">                String tableAlias = itr2.next().toString();</span>
<span class="nc bnc" id="L2574" title="All 2 branches missed.">                if (fromSQL.getSQL().indexOf(tableAlias) == -1) {</span>
<span class="nc bnc" id="L2575" title="All 4 branches missed.">                    if (!first &amp;&amp; fromSQL.getSQL().length() &gt; 0)</span>
<span class="nc" id="L2576">                        fromSQL.append(&quot;, &quot;);</span>
<span class="nc" id="L2577">                    fromSQL.append(tableAlias);</span>
<span class="nc bnc" id="L2578" title="All 4 branches missed.">                    if (forUpdate &amp;&amp; tableForUpdateClause != null)</span>
<span class="nc" id="L2579">                        fromSQL.append(&quot; &quot;).append(tableForUpdateClause);</span>
<span class="nc" id="L2580">                    first = false;</span>
                }
<span class="nc" id="L2582">            }</span>
        }
<span class="nc" id="L2584">        return fromSQL;</span>
    }

    private boolean correlatedJoinCondition(Join join, Select sel) {
<span class="nc bnc" id="L2588" title="All 2 branches missed.">        if (!join.isCorrelated())</span>
<span class="nc" id="L2589">            return false;</span>
<span class="nc" id="L2590">        Iterator itr = sel.getJoinIterator();</span>
<span class="nc" id="L2591">        boolean skip = false;</span>
        //if table1 in join is in the main query, table2 is in
        //subquery, and table2 participates in other joins
        //in subquery, the join condition can only be placed in
        //the where clause in the subquery
<span class="nc bnc" id="L2596" title="All 2 branches missed.">        while (itr.hasNext()) {</span>
<span class="nc" id="L2597">            Join join1 = (Join) itr.next();</span>
<span class="nc bnc" id="L2598" title="All 4 branches missed.">            if (join == join1 &amp;&amp; !join.isForeignKeyInversed()) {</span>
<span class="nc" id="L2599">                continue;</span>
            }
<span class="nc bnc" id="L2601" title="All 2 branches missed.">            if (join.getIndex2() == join1.getIndex1() ||</span>
<span class="nc bnc" id="L2602" title="All 2 branches missed.">                join.getIndex2() == join1.getIndex2()) {</span>
<span class="nc" id="L2603">                skip = true;</span>
<span class="nc bnc" id="L2604" title="All 2 branches missed.">                if (join.getForeignKey() != null){</span>
<span class="nc" id="L2605">                    SQLBuffer where = new SQLBuffer(this);</span>
<span class="nc" id="L2606">                    where.append(&quot;(&quot;).append(toTraditionalJoin(join)).append(&quot;)&quot;);</span>
<span class="nc" id="L2607">                    sel.where(where.getSQL());</span>
<span class="nc" id="L2608">                }</span>
                break;
            }
<span class="nc" id="L2611">        }</span>
<span class="nc" id="L2612">        return skip;</span>
    }


    /**
     * Return the FROM clause for a select that selects from a tmp table
     * created by an inner select.
     */
    protected SQLBuffer getFromSelect(Select sel, boolean forUpdate) {
<span class="nc" id="L2621">        SQLBuffer fromSQL = new SQLBuffer(this);</span>
<span class="nc" id="L2622">        fromSQL.append(&quot;(&quot;);</span>
<span class="nc" id="L2623">        fromSQL.append(toSelect(sel.getFromSelect(), forUpdate, null));</span>
<span class="nc" id="L2624">        fromSQL.append(&quot;)&quot;);</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">        if (requiresAliasForSubselect)</span>
<span class="nc" id="L2626">            fromSQL.append(&quot; &quot;).append(Select.FROM_SELECT_ALIAS);</span>
<span class="nc" id="L2627">        return fromSQL;</span>
    }

    /**
     * Return the WHERE portion of the select statement, or null if no where
     * conditions.
     */
    protected SQLBuffer getWhere(Select sel, boolean forUpdate) {
<span class="nc" id="L2635">        Joins joins = sel.getJoins();</span>
<span class="nc bnc" id="L2636" title="All 4 branches missed.">        if (sel.getJoinSyntax() == SYNTAX_SQL92</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">            || joins == null || joins.isEmpty())</span>
<span class="nc" id="L2638">            return sel.getWhere();</span>

<span class="nc" id="L2640">        SQLBuffer where = new SQLBuffer(this);</span>
<span class="nc bnc" id="L2641" title="All 2 branches missed.">        if (sel.getWhere() != null)</span>
<span class="nc" id="L2642">            where.append(sel.getWhere());</span>
<span class="nc bnc" id="L2643" title="All 2 branches missed.">        if (joins != null)</span>
<span class="nc" id="L2644">            sel.append(where, joins);</span>
<span class="nc" id="L2645">        return where;</span>
    }

    /**
     * Use the given join instance to create SQL joining its tables in
     * the traditional style.
     */
    public SQLBuffer toTraditionalJoin(Join join) {
<span class="nc" id="L2653">        ForeignKey fk = join.getForeignKey();</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">        if (fk == null)</span>
<span class="nc" id="L2655">            return null;</span>

<span class="nc" id="L2657">        boolean inverse = join.isForeignKeyInversed();</span>
<span class="nc bnc" id="L2658" title="All 2 branches missed.">        Column[] from = (inverse) ? fk.getPrimaryKeyColumns()</span>
<span class="nc" id="L2659">            : fk.getColumns();</span>
<span class="nc bnc" id="L2660" title="All 2 branches missed.">        Column[] to = (inverse) ? fk.getColumns()</span>
<span class="nc" id="L2661">            : fk.getPrimaryKeyColumns();</span>

        // do column joins
<span class="nc" id="L2664">        SQLBuffer buf = new SQLBuffer(this);</span>
<span class="nc" id="L2665">        int count = 0;</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">        for (int i = 0; i &lt; from.length; i++, count++) {</span>
<span class="nc bnc" id="L2667" title="All 2 branches missed.">            if (count &gt; 0)</span>
<span class="nc" id="L2668">                buf.append(&quot; AND &quot;);</span>
<span class="nc" id="L2669">            buf.append(join.getAlias1()).append(&quot;.&quot;).append(from[i]);</span>
<span class="nc" id="L2670">            buf.append(&quot; = &quot;);</span>
<span class="nc" id="L2671">            buf.append(join.getAlias2()).append(&quot;.&quot;).append(to[i]);</span>
        }

        // do constant joins
<span class="nc" id="L2675">        Column[] constCols = fk.getConstantColumns();</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">        for (int i = 0; i &lt; constCols.length; i++, count++) {</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">            if (count &gt; 0)</span>
<span class="nc" id="L2678">                buf.append(&quot; AND &quot;);</span>
<span class="nc bnc" id="L2679" title="All 2 branches missed.">            if (inverse)</span>
<span class="nc" id="L2680">                buf.appendValue(fk.getConstant(constCols[i]), constCols[i]);</span>
            else
<span class="nc" id="L2682">                buf.append(join.getAlias1()).append(&quot;.&quot;).</span>
<span class="nc" id="L2683">                    append(constCols[i]);</span>
<span class="nc" id="L2684">            buf.append(&quot; = &quot;);</span>

<span class="nc bnc" id="L2686" title="All 2 branches missed.">            if (inverse)</span>
<span class="nc" id="L2687">                buf.append(join.getAlias2()).append(&quot;.&quot;).</span>
<span class="nc" id="L2688">                    append(constCols[i]);</span>
            else
<span class="nc" id="L2690">                buf.appendValue(fk.getConstant(constCols[i]), constCols[i]);</span>
        }

<span class="nc" id="L2693">        Column[] constColsPK = fk.getConstantPrimaryKeyColumns();</span>
<span class="nc bnc" id="L2694" title="All 2 branches missed.">        for (int i = 0; i &lt; constColsPK.length; i++, count++) {</span>
<span class="nc bnc" id="L2695" title="All 2 branches missed.">            if (count &gt; 0)</span>
<span class="nc" id="L2696">                buf.append(&quot; AND &quot;);</span>
<span class="nc bnc" id="L2697" title="All 2 branches missed.">            if (inverse)</span>
<span class="nc" id="L2698">                buf.append(join.getAlias1()).append(&quot;.&quot;).</span>
<span class="nc" id="L2699">                    append(constColsPK[i]);</span>
            else
<span class="nc" id="L2701">                buf.appendValue(fk.getPrimaryKeyConstant(constColsPK[i]),</span>
                    constColsPK[i]);
<span class="nc" id="L2703">            buf.append(&quot; = &quot;);</span>

<span class="nc bnc" id="L2705" title="All 2 branches missed.">            if (inverse)</span>
<span class="nc" id="L2706">                buf.appendValue(fk.getPrimaryKeyConstant(constColsPK[i]),</span>
                    constColsPK[i]);
            else
<span class="nc" id="L2709">                buf.append(join.getAlias2()).append(&quot;.&quot;).</span>
<span class="nc" id="L2710">                    append(constColsPK[i]);</span>
        }
<span class="nc" id="L2712">        return buf;</span>
    }

    /**
     * Use the given join instance to create SQL joining its tables in
     * the SQL92 style.
     */
    public SQLBuffer toSQL92Join(Select sel, Join join, boolean forUpdate,
        boolean first) {
<span class="nc" id="L2721">        SQLBuffer buf = new SQLBuffer(this);</span>

<span class="nc bnc" id="L2723" title="All 2 branches missed.">        if (first) {</span>
<span class="nc" id="L2724">            buf.append(join.getTable1()).append(&quot; &quot;).</span>
<span class="nc" id="L2725">                append(join.getAlias1());</span>
<span class="nc bnc" id="L2726" title="All 4 branches missed.">            if (forUpdate &amp;&amp; tableForUpdateClause != null)</span>
<span class="nc" id="L2727">                buf.append(&quot; &quot;).append(tableForUpdateClause);</span>
        }

<span class="nc" id="L2730">        buf.append(&quot; &quot;);</span>
<span class="nc bnc" id="L2731" title="All 2 branches missed.">        if (join.getType() == Join.TYPE_OUTER)</span>
<span class="nc" id="L2732">            buf.append(outerJoinClause);</span>
<span class="nc bnc" id="L2733" title="All 2 branches missed.">        else if (join.getType() == Join.TYPE_INNER)</span>
<span class="nc" id="L2734">            buf.append(innerJoinClause);</span>
        else // cross
<span class="nc" id="L2736">            buf.append(crossJoinClause);</span>
<span class="nc" id="L2737">        buf.append(&quot; &quot;);</span>

<span class="nc" id="L2739">        buf.append(join.getTable2()).append(&quot; &quot;).append(join.getAlias2());</span>
<span class="nc bnc" id="L2740" title="All 4 branches missed.">        if (forUpdate &amp;&amp; tableForUpdateClause != null)</span>
<span class="nc" id="L2741">            buf.append(&quot; &quot;).append(tableForUpdateClause);</span>

<span class="nc bnc" id="L2743" title="All 2 branches missed.">        if (join.getForeignKey() != null)</span>
<span class="nc" id="L2744">            buf.append(&quot; ON &quot;).append(toTraditionalJoin(join));</span>
<span class="nc bnc" id="L2745" title="All 2 branches missed.">        else if (requiresConditionForCrossJoin &amp;&amp;</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">                join.getType() == Join.TYPE_CROSS)</span>
<span class="nc" id="L2747">            buf.append(&quot; ON (1 = 1)&quot;);</span>

<span class="nc" id="L2749">        return buf;</span>
    }

    private SQLBuffer toCorrelatedJoin(Select sel, Join join, boolean forUpdate,
        boolean first) {
<span class="nc bnc" id="L2754" title="All 2 branches missed.">        if (join.getForeignKey() != null){</span>
<span class="nc" id="L2755">            SQLBuffer where = new SQLBuffer(this);</span>
<span class="nc" id="L2756">            where.append(&quot;(&quot;).append(toTraditionalJoin(join)).append(&quot;)&quot;);</span>
<span class="nc" id="L2757">            sel.where(where.getSQL());</span>
        }

<span class="nc" id="L2760">        return null;</span>
    }

    /**
     * Use the given join instance to create SQL joining its tables in
     * the database's native syntax. Throws an exception by default.
     */
    public SQLBuffer toNativeJoin(Join join) {
<span class="nc" id="L2768">        throw new UnsupportedException();</span>
    }

    /**
     * Returns if the given foreign key can be eagerly loaded using other joins.
     */
    public boolean canOuterJoin(int syntax, ForeignKey fk) {
<span class="nc bnc" id="L2775" title="All 2 branches missed.">        return syntax != SYNTAX_TRADITIONAL;</span>
    }

    /**
     * Combine the given components into a SELECT statement.
     */
    public SQLBuffer toSelect(SQLBuffer selects, JDBCFetchConfiguration fetch,
        SQLBuffer from, SQLBuffer where, SQLBuffer group,
        SQLBuffer having, SQLBuffer order,
        boolean distinct, boolean forUpdate, long start, long end) {
<span class="nc" id="L2785">        return toOperation(getSelectOperation(fetch), selects, from, where,</span>
            group, having, order, distinct, start, end,
<span class="nc" id="L2787">            getForUpdateClause(fetch, forUpdate, null));</span>
    }

    /**
     * Combine the given components into a SELECT statement.
     */
    protected SQLBuffer toSelect(SQLBuffer selects,
        JDBCFetchConfiguration fetch,
        SQLBuffer from, SQLBuffer where, SQLBuffer group,
        SQLBuffer having, SQLBuffer order,
        boolean distinct, boolean forUpdate, long start, long end,
        boolean subselect, Select sel) {
<span class="nc" id="L2799">        return toOperation(getSelectOperation(fetch), selects, from, where,</span>
            group, having, order, distinct, start, end,
<span class="nc" id="L2801">            getForUpdateClause(fetch, forUpdate, null), subselect);</span>
    }

    public SQLBuffer toSelect(SQLBuffer selects, JDBCFetchConfiguration fetch,
            SQLBuffer from, SQLBuffer where, SQLBuffer group,
            SQLBuffer having, SQLBuffer order,
            boolean distinct, boolean forUpdate, long start, long end,
            boolean subselect, boolean checkTableForUpdate) {
<span class="nc" id="L2809">            return toOperation(getSelectOperation(fetch), selects, from, where,</span>
                    group, having, order, distinct, start, end,
<span class="nc" id="L2811">                    getForUpdateClause(fetch, forUpdate, null), subselect,</span>
                    checkTableForUpdate);
        }

    /**
     * Combine the given components into a SELECT statement.
     */
    protected SQLBuffer toSelect(SQLBuffer selects,
        JDBCFetchConfiguration fetch,
        SQLBuffer from, SQLBuffer where, SQLBuffer group,
        SQLBuffer having, SQLBuffer order,
        boolean distinct, boolean forUpdate, long start, long end,
        Select sel) {
<span class="nc" id="L2824">        return toOperation(getSelectOperation(fetch), selects, from, where,</span>
            group, having, order, distinct, start, end,
<span class="nc" id="L2826">            getForUpdateClause(fetch, forUpdate, sel));</span>
    }

    /**
     * Get the update clause for the query based on the
     * updateClause and isolationLevel hints
     */
    protected String getForUpdateClause(JDBCFetchConfiguration fetch,
        boolean isForUpdate, Select sel) {
<span class="nc bnc" id="L2835" title="All 4 branches missed.">        if (fetch != null &amp;&amp; fetch.getIsolation() != -1) {</span>
<span class="nc" id="L2836">            throw new InvalidStateException(_loc.get(</span>
<span class="nc" id="L2837">                &quot;isolation-level-config-not-supported&quot;, getClass().getName()));</span>
<span class="nc bnc" id="L2838" title="All 4 branches missed.">        } else if (isForUpdate &amp;&amp; !simulateLocking) {</span>
<span class="nc" id="L2839">            assertSupport(supportsSelectForUpdate, &quot;SupportsSelectForUpdate&quot;);</span>
<span class="nc" id="L2840">            return forUpdateClause;</span>
        } else {
<span class="nc" id="L2842">            return null;</span>
        }
    }

    /**
     * Return true if the dictionary uses isolation level to compute the
     * returned getForUpdateClause() SQL clause.
     */
    public boolean supportsIsolationForUpdate() {
<span class="nc" id="L2851">        return false;</span>
    }

    /**
     * Return the &quot;SELECT&quot; operation clause, adding any available hints, etc.
     */
    public String getSelectOperation(JDBCFetchConfiguration fetch) {
<span class="nc" id="L2858">        return &quot;SELECT&quot;;</span>
    }

    /**
     * Return the SQL for the given selecting operation.
     */
    public SQLBuffer toOperation(String op, SQLBuffer selects,
        SQLBuffer from, SQLBuffer where, SQLBuffer group, SQLBuffer having,
        SQLBuffer order, boolean distinct, long start, long end,
        String forUpdateClause) {
<span class="nc" id="L2868">        return toOperation(op, selects, from, where, group, having, order,</span>
            distinct, start, end, forUpdateClause, false);
    }

    /**
     * Return the SQL for the given selecting operation.
     */
    public SQLBuffer toOperation(String op, SQLBuffer selects,
        SQLBuffer from, SQLBuffer where, SQLBuffer group, SQLBuffer having,
        SQLBuffer order, boolean distinct, long start, long end,
        String forUpdateClause, boolean subselect) {
<span class="nc" id="L2879">        return toOperation(op, selects, from, where, group, having, order,</span>
                distinct, start, end, forUpdateClause, subselect, false);
    }

    /**
     * Return the SQL for the given selecting operation.
     */
    private SQLBuffer toOperation(String op, SQLBuffer selects, SQLBuffer from,
            SQLBuffer where, SQLBuffer group, SQLBuffer having, SQLBuffer order,
            boolean distinct, long start, long end, String forUpdateClause,
            boolean subselect, boolean checkTableForUpdate) {
<span class="nc" id="L2890">        SQLBuffer buf = new SQLBuffer(this);</span>
<span class="nc" id="L2891">        buf.append(op);</span>

<span class="nc bnc" id="L2893" title="All 4 branches missed.">        boolean range = start != 0 || end != Long.MAX_VALUE;</span>
<span class="nc bnc" id="L2894" title="All 4 branches missed.">        if (range &amp;&amp; rangePosition == RANGE_PRE_DISTINCT)</span>
<span class="nc" id="L2895">            appendSelectRange(buf, start, end, subselect);</span>
<span class="nc bnc" id="L2896" title="All 2 branches missed.">        if (distinct)</span>
<span class="nc" id="L2897">            buf.append(&quot; DISTINCT&quot;);</span>
<span class="nc bnc" id="L2898" title="All 4 branches missed.">        if (range &amp;&amp; rangePosition == RANGE_POST_DISTINCT)</span>
<span class="nc" id="L2899">            appendSelectRange(buf, start, end, subselect);</span>

<span class="nc" id="L2901">        buf.append(&quot; &quot;).append(selects).append(&quot; FROM &quot;).append(from);</span>

<span class="nc bnc" id="L2903" title="All 2 branches missed.">        if (checkTableForUpdate</span>
<span class="nc bnc" id="L2904" title="All 4 branches missed.">                &amp;&amp; (StringUtil.isEmpty(forUpdateClause) &amp;&amp; !StringUtil.isEmpty(tableForUpdateClause))) {</span>
<span class="nc" id="L2905">            buf.append(&quot; &quot;).append(tableForUpdateClause);</span>
        }

<span class="nc bnc" id="L2908" title="All 4 branches missed.">        if (where != null &amp;&amp; !where.isEmpty())</span>
<span class="nc" id="L2909">            buf.append(&quot; WHERE &quot;).append(where);</span>
<span class="nc bnc" id="L2910" title="All 4 branches missed.">        if (group != null &amp;&amp; !group.isEmpty())</span>
<span class="nc" id="L2911">            buf.append(&quot; GROUP BY &quot;).append(group);</span>
<span class="nc bnc" id="L2912" title="All 4 branches missed.">        if (having != null &amp;&amp; !having.isEmpty()) {</span>
<span class="nc" id="L2913">            assertSupport(supportsHaving, &quot;SupportsHaving&quot;);</span>
<span class="nc" id="L2914">            buf.append(&quot; HAVING &quot;).append(having);</span>
        }
<span class="nc bnc" id="L2916" title="All 4 branches missed.">        if (order != null &amp;&amp; !order.isEmpty())</span>
<span class="nc" id="L2917">            buf.append(&quot; ORDER BY &quot;).append(order);</span>
<span class="nc bnc" id="L2918" title="All 4 branches missed.">        if (range &amp;&amp; rangePosition == RANGE_POST_SELECT)</span>
<span class="nc" id="L2919">            appendSelectRange(buf, start, end, subselect);</span>
<span class="nc bnc" id="L2920" title="All 2 branches missed.">        if (forUpdateClause != null)</span>
<span class="nc" id="L2921">            buf.append(&quot; &quot;).append(forUpdateClause);</span>
<span class="nc bnc" id="L2922" title="All 4 branches missed.">        if (range &amp;&amp; rangePosition == RANGE_POST_LOCK)</span>
<span class="nc" id="L2923">            appendSelectRange(buf, start, end, subselect);</span>
<span class="nc" id="L2924">        return buf;</span>
    }

    /**
     * If this dictionary can select ranges,
     * use this method to append the range SQL.
     */
    protected void appendSelectRange(SQLBuffer buf, long start, long end,
        boolean subselect) {
<span class="nc" id="L2933">    }</span>

    /**
     * Return the portion of the select statement between the SELECT keyword
     * and the FROM keyword.
     */
    protected SQLBuffer getSelects(Select sel, boolean distinctIdentifiers,
        boolean forUpdate) {
        // append the aliases for all the columns
<span class="nc" id="L2942">        SQLBuffer selectSQL = new SQLBuffer(this);</span>
        List aliases;
<span class="nc bnc" id="L2944" title="All 2 branches missed.">        if (distinctIdentifiers)</span>
<span class="nc" id="L2945">            aliases = sel.getIdentifierAliases();</span>
        else
<span class="nc" id="L2947">            aliases = sel.getSelectAliases();</span>

        Object alias;
<span class="nc bnc" id="L2950" title="All 2 branches missed.">        for (int i = 0; i &lt; aliases.size(); i++) {</span>
<span class="nc" id="L2951">            alias = aliases.get(i);</span>
<span class="nc bnc" id="L2952" title="All 2 branches missed.">            if (alias instanceof String) {</span>
<span class="nc" id="L2953">                alias = getNamingUtil().convertAlias((String)alias);</span>
            }
<span class="nc" id="L2955">            appendSelect(selectSQL, alias, sel, i);</span>
<span class="nc bnc" id="L2956" title="All 2 branches missed.">            if (i &lt; aliases.size() - 1)</span>
<span class="nc" id="L2957">                selectSQL.append(&quot;, &quot;);</span>
        }
<span class="nc" id="L2959">        return selectSQL;</span>
    }

    /**
     * Append &lt;code&gt;elem&lt;/code&gt; to &lt;code&gt;selectSQL&lt;/code&gt;.
     * @param selectSQL The SQLBuffer to append to.
     * @param elem A {@link SQLBuffer} or a {@link String} to append.
     *
     * @since 1.1.0
     */
    protected void appendSelect(SQLBuffer selectSQL, Object elem, Select sel, int idx) {
<span class="nc bnc" id="L2970" title="All 2 branches missed.">        if (elem instanceof SQLBuffer)</span>
<span class="nc" id="L2971">            selectSQL.append((SQLBuffer) elem);</span>
        else
<span class="nc" id="L2973">            selectSQL.append(elem.toString());</span>
<span class="nc" id="L2974">    }</span>

    /**
     * Returns true if a &quot;FOR UPDATE&quot; clause can be used for the specified
     * Select object.
     */
    public boolean supportsLocking(Select sel) {
<span class="nc bnc" id="L2981" title="All 2 branches missed.">        if (sel.isAggregate())</span>
<span class="nc" id="L2982">            return false;</span>
<span class="nc bnc" id="L2983" title="All 2 branches missed.">        if (!supportsSelectForUpdate)</span>
<span class="nc" id="L2984">            return false;</span>
<span class="nc bnc" id="L2985" title="All 4 branches missed.">        if (!supportsLockingWithSelectRange &amp;&amp; (sel.getStartIndex() != 0</span>
<span class="nc bnc" id="L2986" title="All 2 branches missed.">            || sel.getEndIndex() != Long.MAX_VALUE))</span>
<span class="nc" id="L2987">            return false;</span>

        // only inner select is locked
<span class="nc bnc" id="L2990" title="All 2 branches missed.">        if (sel.getFromSelect() != null)</span>
<span class="nc" id="L2991">            sel = sel.getFromSelect();</span>

<span class="nc bnc" id="L2993" title="All 4 branches missed.">        if (!supportsLockingWithDistinctClause &amp;&amp; sel.isDistinct())</span>
<span class="nc" id="L2994">            return false;</span>
<span class="nc bnc" id="L2995" title="All 2 branches missed.">        if (!supportsLockingWithMultipleTables</span>
<span class="nc bnc" id="L2996" title="All 2 branches missed.">            &amp;&amp; sel.getTableAliases().size() &gt; 1)</span>
<span class="nc" id="L2997">            return false;</span>
<span class="nc bnc" id="L2998" title="All 4 branches missed.">        if (!supportsLockingWithOrderClause &amp;&amp; sel.getOrdering() != null)</span>
<span class="nc" id="L2999">            return false;</span>
<span class="nc bnc" id="L3000" title="All 4 branches missed.">        if (!supportsLockingWithOuterJoin || !supportsLockingWithInnerJoin) {</span>
<span class="nc bnc" id="L3001" title="All 2 branches missed.">            for (Iterator itr = sel.getJoinIterator(); itr.hasNext();) {</span>
<span class="nc" id="L3002">                Join join = (Join) itr.next();</span>
<span class="nc bnc" id="L3003" title="All 2 branches missed.">                if (!supportsLockingWithOuterJoin</span>
<span class="nc bnc" id="L3004" title="All 2 branches missed.">                    &amp;&amp; join.getType() == Join.TYPE_OUTER)</span>
<span class="nc" id="L3005">                    return false;</span>
<span class="nc bnc" id="L3006" title="All 2 branches missed.">                if (!supportsLockingWithInnerJoin</span>
<span class="nc bnc" id="L3007" title="All 2 branches missed.">                    &amp;&amp; join.getType() == Join.TYPE_INNER)</span>
<span class="nc" id="L3008">                    return false;</span>
<span class="nc" id="L3009">            }</span>
        }
<span class="nc" id="L3011">        return true;</span>
    }

    /**
     * Return false if the given select requires a forward-only result set.
     */
    public boolean supportsRandomAccessResultSet(Select sel,
        boolean forUpdate) {
<span class="nc bnc" id="L3019" title="All 2 branches missed.">        return !sel.isAggregate();</span>
    }

    /**
     * Assert that the given dictionary flag is true. If it is not true,
     * throw an error saying that the given setting needs to return true for
     * the current operation to work.
     */
    public void assertSupport(boolean feature, String property) {
<span class="nc bnc" id="L3028" title="All 2 branches missed.">        if (!feature)</span>
<span class="nc" id="L3029">            throw new UnsupportedException(_loc.get(&quot;feature-not-supported&quot;,</span>
<span class="nc" id="L3030">                getClass(), property));</span>
<span class="nc" id="L3031">    }</span>

    ////////////////////
    // Query functions
    ////////////////////

    /**
     * Invoke this database's substring function.
     * Numeric parameters are inlined if possible. This is to handle grouping by SUBSTRING -
     * most databases do not allow parameter binding in this case.
     *
     * @param buf the SQL buffer to write the substring invocation to
     * @param str a query value representing the target string
     * @param start a query value representing the start index
     * @param length a query value representing the length of substring, or null for none
     */
    public void substring(SQLBuffer buf, FilterValue str, FilterValue start,
        FilterValue length) {
<span class="nc" id="L3049">        buf.append(substringFunctionName).append(&quot;(&quot;);</span>
<span class="nc" id="L3050">        str.appendTo(buf);</span>
<span class="nc" id="L3051">        buf.append(&quot;, &quot;);</span>
<span class="nc bnc" id="L3052" title="All 2 branches missed.">        if (start.getValue() instanceof Number) {</span>
<span class="nc" id="L3053">            buf.append(Long.toString(toLong(start)));</span>
        } else {
<span class="nc" id="L3055">            start.appendTo(buf);</span>
        }
<span class="nc bnc" id="L3057" title="All 2 branches missed.">        if (length != null) {</span>
<span class="nc" id="L3058">            buf.append(&quot;, &quot;);</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">            if (length.getValue() instanceof Number) {</span>
<span class="nc" id="L3060">                buf.append(Long.toString(toLong(length)));</span>
            } else {
<span class="nc" id="L3062">                length.appendTo(buf);</span>
            }
        }
<span class="nc" id="L3065">        buf.append(&quot;)&quot;);</span>
<span class="nc" id="L3066">    }</span>

    long toLong(FilterValue litValue) {
<span class="nc" id="L3069">        return ((Number) litValue.getValue()).longValue();</span>
    }

    /**
     * Invoke this database's indexOf function.
     *
     * @param buf the SQL buffer to write the indexOf invocation to
     * @param str a query value representing the target string
     * @param find a query value representing the search string
     * @param start a query value representing the start index, or null
     * to start at the beginning
     */
    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,
        FilterValue start) {
<span class="nc" id="L3083">        buf.append(&quot;(INSTR((&quot;);</span>
<span class="nc bnc" id="L3084" title="All 2 branches missed.">        if (start != null)</span>
<span class="nc" id="L3085">            substring(buf, str, start, null);</span>
        else
<span class="nc" id="L3087">            str.appendTo(buf);</span>
<span class="nc" id="L3088">        buf.append(&quot;), (&quot;);</span>
<span class="nc" id="L3089">        find.appendTo(buf);</span>
<span class="nc" id="L3090">        buf.append(&quot;))&quot;);</span>
<span class="nc bnc" id="L3091" title="All 2 branches missed.">        if (start != null) {</span>
<span class="nc" id="L3092">            buf.append(&quot; - 1  + &quot;);</span>
<span class="nc" id="L3093">            start.appendTo(buf);</span>
        }
<span class="nc" id="L3095">        buf.append(&quot;)&quot;);</span>
<span class="nc" id="L3096">    }</span>

    /**
     * Append the numeric parts of a mathematical function.
     *
     * @param buf the SQL buffer to write the math function
     * @param op the mathematical operation to perform
     * @param lhs the left hand side of the math function
     * @param rhs the right hand side of the math function
     */
    public void mathFunction(SQLBuffer buf, String op, FilterValue lhs,
        FilterValue rhs) {
<span class="nc" id="L3108">        boolean castlhs = false;</span>
<span class="nc" id="L3109">        boolean castrhs = false;</span>
<span class="nc" id="L3110">        Class lc = Filters.wrap(lhs.getType());</span>
<span class="nc" id="L3111">        Class rc = Filters.wrap(rhs.getType());</span>
<span class="nc" id="L3112">        int type = 0;</span>
<span class="nc bnc" id="L3113" title="All 4 branches missed.">        if (requiresCastForMathFunctions &amp;&amp; (lc != rc</span>
<span class="nc bnc" id="L3114" title="All 4 branches missed.">            || (lhs.isConstant() || rhs.isConstant()))) {</span>
<span class="nc" id="L3115">            Class c = Filters.promote(lc, rc);</span>
<span class="nc" id="L3116">            type = getJDBCType(JavaTypes.getTypeCode(c), false);</span>
<span class="nc bnc" id="L3117" title="All 4 branches missed.">            if (type != Types.VARBINARY &amp;&amp; type != Types.BLOB) {</span>
<span class="nc bnc" id="L3118" title="All 6 branches missed.">                castlhs = (lhs.isConstant() &amp;&amp; rhs.isConstant()) || lc != c;</span>
<span class="nc bnc" id="L3119" title="All 6 branches missed.">                castrhs = (lhs.isConstant() &amp;&amp; rhs.isConstant()) || rc != c;</span>
            }
        }

<span class="nc" id="L3123">        boolean mod = &quot;MOD&quot;.equals(op);</span>
<span class="nc bnc" id="L3124" title="All 2 branches missed.">        if (mod) {</span>
<span class="nc bnc" id="L3125" title="All 2 branches missed.">            if (supportsModOperator)</span>
<span class="nc" id="L3126">                op = &quot;%&quot;;</span>
            else
<span class="nc" id="L3128">                buf.append(op);</span>
        }
<span class="nc" id="L3130">        buf.append(&quot;(&quot;);</span>

<span class="nc bnc" id="L3132" title="All 2 branches missed.">        if (castlhs)</span>
<span class="nc" id="L3133">            appendCast(buf, lhs, type);</span>
        else
<span class="nc" id="L3135">            lhs.appendTo(buf);</span>

<span class="nc bnc" id="L3137" title="All 4 branches missed.">        if (mod &amp;&amp; !supportsModOperator)</span>
<span class="nc" id="L3138">            buf.append(&quot;, &quot;);</span>
        else
<span class="nc" id="L3140">            buf.append(&quot; &quot;).append(op).append(&quot; &quot;);</span>

<span class="nc bnc" id="L3142" title="All 2 branches missed.">        if (castrhs)</span>
<span class="nc" id="L3143">            appendCast(buf, rhs, type);</span>
        else
<span class="nc" id="L3145">            rhs.appendTo(buf);</span>

<span class="nc" id="L3147">        buf.append(&quot;)&quot;);</span>
<span class="nc" id="L3148">    }</span>

    /**
     * Append a comparison.
     *
     * @param buf the SQL buffer to write the comparison
     * @param op the comparison operation to perform
     * @param lhs the left hand side of the comparison
     * @param rhs the right hand side of the comparison
     */
    public void comparison(SQLBuffer buf, String op, FilterValue lhs,
        FilterValue rhs) {
<span class="nc bnc" id="L3160" title="All 2 branches missed.">        boolean lhsxml = lhs.getXPath() != null;</span>
<span class="nc bnc" id="L3161" title="All 2 branches missed.">        boolean rhsxml = rhs.getXPath() != null;</span>
<span class="nc bnc" id="L3162" title="All 4 branches missed.">        if (lhsxml || rhsxml) {</span>
<span class="nc" id="L3163">            appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);</span>
<span class="nc" id="L3164">            return;</span>
        }
<span class="nc" id="L3166">        boolean castlhs = false;</span>
<span class="nc" id="L3167">        boolean castrhs = false;</span>
<span class="nc" id="L3168">        Class lc = Filters.wrap(lhs.getType());</span>
<span class="nc" id="L3169">        Class rc = Filters.wrap(rhs.getType());</span>

        // special case of comparison of two boolean constants
        // because some databases do not like false = false or false = true
        // but all databases understand 1 = 0 or 0 &lt;&gt; 1 etc.
<span class="nc bnc" id="L3174" title="All 8 branches missed.">        if (lc == rc &amp;&amp; lc == Boolean.class &amp;&amp; lhs.isConstant() &amp;&amp; rhs.isConstant()) {</span>
<span class="nc bnc" id="L3175" title="All 2 branches missed.">            String lvalue = Boolean.TRUE.equals(lhs.getValue()) ? &quot;1&quot; : &quot;0&quot;;</span>
<span class="nc bnc" id="L3176" title="All 2 branches missed.">            String rvalue = Boolean.TRUE.equals(rhs.getValue()) ? &quot;1&quot; : &quot;0&quot;;</span>
<span class="nc" id="L3177">            buf.append(lvalue).append(op).append(rvalue);</span>
<span class="nc" id="L3178">            return;</span>
        }
<span class="nc" id="L3180">        int type = 0;</span>
<span class="nc bnc" id="L3181" title="All 4 branches missed.">        if (requiresCastForComparisons &amp;&amp; (lc != rc</span>
<span class="nc bnc" id="L3182" title="All 4 branches missed.">            || (lhs.isConstant() &amp;&amp; rhs.isConstant()))) {</span>
<span class="nc" id="L3183">            Class c = Filters.promote(lc, rc);</span>
<span class="nc" id="L3184">            type = getJDBCType(JavaTypes.getTypeCode(c), false);</span>
<span class="nc bnc" id="L3185" title="All 4 branches missed.">            if (type != Types.VARBINARY &amp;&amp; type != Types.BLOB) {</span>
<span class="nc bnc" id="L3186" title="All 6 branches missed.">                castlhs = (lhs.isConstant() &amp;&amp; rhs.isConstant()) || lc != c;</span>
<span class="nc bnc" id="L3187" title="All 6 branches missed.">                castrhs = (lhs.isConstant() &amp;&amp; rhs.isConstant()) || rc != c;</span>
<span class="nc bnc" id="L3188" title="All 4 branches missed.">                castlhs = castlhs &amp;&amp; lhs.requiresCast();</span>
<span class="nc bnc" id="L3189" title="All 4 branches missed.">                castrhs = castrhs &amp;&amp; rhs.requiresCast();</span>
            }
        }

<span class="nc bnc" id="L3193" title="All 2 branches missed.">        if (castlhs)</span>
<span class="nc" id="L3194">            appendCast(buf, lhs, type);</span>
        else
<span class="nc" id="L3196">            lhs.appendTo(buf);</span>

<span class="nc" id="L3198">        buf.append(&quot; &quot;).append(op).append(&quot; &quot;);</span>

<span class="nc bnc" id="L3200" title="All 2 branches missed.">        if (castrhs)</span>
<span class="nc" id="L3201">            appendCast(buf, rhs, type);</span>
        else
<span class="nc" id="L3203">            rhs.appendTo(buf);</span>
<span class="nc" id="L3204">    }</span>

    /**
     * If this dictionary supports XML type,
     * use this method to append xml predicate.
     */
    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,
        FilterValue rhs, boolean lhsxml, boolean rhsxml) {
<span class="nc" id="L3212">        assertSupport(supportsXMLColumn, &quot;SupportsXMLColumn&quot;);</span>
<span class="nc" id="L3213">    }</span>

    /**
     * Append SQL for the given numeric value to the buffer, casting as needed.
     */
    protected void appendNumericCast(SQLBuffer buf, FilterValue val) {
<span class="nc bnc" id="L3219" title="All 2 branches missed.">        if (val.isConstant())</span>
<span class="nc" id="L3220">            appendCast(buf, val, Types.NUMERIC);</span>
        else
<span class="nc" id="L3222">            val.appendTo(buf);</span>
<span class="nc" id="L3223">    }</span>

    /**
     * Cast the specified value to the specified type.
     *
     * @param buf the buffer to append the cast to
     * @param val the value to cast
     * @param type the type of the case, e.g. {@link Types#NUMERIC}
     */
    public void appendCast(SQLBuffer buf, Object val, int type) {
        // Convert the cast function: &quot;CAST({0} AS {1})&quot;
<span class="nc" id="L3234">        int firstParam = castFunction.indexOf(&quot;{0}&quot;);</span>
<span class="nc" id="L3235">        String pre = castFunction.substring(0, firstParam); // &quot;CAST(&quot;</span>
<span class="nc" id="L3236">        String mid = castFunction.substring(firstParam + 3);</span>
<span class="nc" id="L3237">        int secondParam = mid.indexOf(&quot;{1}&quot;);</span>
        String post;
<span class="nc bnc" id="L3239" title="All 2 branches missed.">        if (secondParam &gt; -1) {</span>
<span class="nc" id="L3240">            post = mid.substring(secondParam + 3); // &quot;)&quot;</span>
<span class="nc" id="L3241">            mid = mid.substring(0, secondParam); // &quot; AS &quot;</span>
        } else
<span class="nc" id="L3243">            post = &quot;&quot;;</span>

<span class="nc" id="L3245">        buf.append(pre);</span>
<span class="nc bnc" id="L3246" title="All 2 branches missed.">        if (val instanceof FilterValue)</span>
<span class="nc" id="L3247">            ((FilterValue) val).appendTo(buf);</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">        else if (val instanceof SQLBuffer)</span>
<span class="nc" id="L3249">            buf.append(((SQLBuffer) val));</span>
        else
<span class="nc" id="L3251">            buf.append(val.toString());</span>
<span class="nc" id="L3252">        buf.append(mid);</span>
<span class="nc" id="L3253">        buf.append(getTypeName(type));</span>
<span class="nc" id="L3254">        appendLength(buf, type);</span>
<span class="nc" id="L3255">        buf.append(post);</span>
<span class="nc" id="L3256">    }</span>

    protected void appendLength(SQLBuffer buf, int type) {
<span class="nc" id="L3259">    }</span>


    /**
     * add CAST for a function operator where operand is a param
     * @param func  function name
     * @param val
     * @return updated func
     */
    public String addCastAsType(String func, Val val) {
<span class="nc" id="L3269">        return null;</span>
    }


    ///////////
    // DDL SQL
    ///////////

    /**
     * Increment the reference count of any table components that this
     * dictionary adds that are not used by mappings. Does nothing by default.
     */
    public void refSchemaComponents(Table table) {
<span class="nc" id="L3282">    }</span>

    /**
     * Returns the name of the column using database specific delimiters.
     */
    public DBIdentifier getColumnIdentifier(Column column) {
<span class="nc bnc" id="L3288" title="All 2 branches missed.">        if (column == null) {</span>
<span class="nc" id="L3289">            return DBIdentifier.NULL;</span>
        }
<span class="nc" id="L3291">        return column.getIdentifier();</span>
    }

    public String getColumnDBName(Column column) {
<span class="nc" id="L3295">        return toDBName(getColumnIdentifier(column));</span>
    }

    public String toSnakeCase(final String name) {
<span class="nc" id="L3299">        final StringBuilder out = new StringBuilder(name.length() + 3);</span>
<span class="nc bnc" id="L3300" title="All 4 branches missed.">        final boolean isDelimited = name.startsWith(getLeadingDelimiter()) &amp;&amp; name.endsWith(getTrailingDelimiter());</span>
        final String toConvert;
<span class="nc bnc" id="L3302" title="All 2 branches missed.">        if (isDelimited) {</span>
<span class="nc" id="L3303">            toConvert = name.substring(2, name.length() - 1);</span>
<span class="nc" id="L3304">            out.append(name.substring(0, 2).toLowerCase(ROOT));</span>
        } else {
<span class="nc" id="L3306">            toConvert = name.substring(1);</span>
<span class="nc" id="L3307">            out.append(Character.toLowerCase(name.charAt(0)));</span>
        }
<span class="nc bnc" id="L3309" title="All 2 branches missed.">        for (final char c : toConvert.toCharArray()) {</span>
<span class="nc bnc" id="L3310" title="All 2 branches missed.">            if (!Character.isLetter(c)) { // delimiter</span>
<span class="nc" id="L3311">                out.append(c);</span>
<span class="nc bnc" id="L3312" title="All 2 branches missed.">            } else if (Character.isUpperCase(c)) {</span>
<span class="nc" id="L3313">                out.append('_').append(Character.toLowerCase(c));</span>
            } else {
<span class="nc" id="L3315">                out.append(c);</span>
            }
        }
<span class="nc bnc" id="L3318" title="All 2 branches missed.">        if (toConvert.length() != name.length() - 1) {</span>
<span class="nc" id="L3319">            out.append(name.charAt(name.length() - 1));</span>
        }
<span class="nc" id="L3321">        return out.toString();</span>
    }

    /**
     * Returns the full name of the table, including the schema (delimited
     * by {@link #catalogSeparator}).
     */
    public DBIdentifier getFullIdentifier(Table table, boolean logical) {
<span class="nc bnc" id="L3329" title="All 4 branches missed.">        if (!useSchemaName || DBIdentifier.isNull(table.getSchemaIdentifier()))</span>
<span class="nc" id="L3330">            return table.getIdentifier();</span>
<span class="nc" id="L3331">        return table.getFullIdentifier();</span>
    }

    public String getFullName(Table table, boolean logical) {
<span class="nc bnc" id="L3335" title="All 4 branches missed.">        if (!useSchemaName || DBIdentifier.isNull(table.getSchemaIdentifier()))</span>
<span class="nc" id="L3336">            return toDBName(table.getIdentifier());</span>
<span class="nc" id="L3337">        return toDBName(table.getFullIdentifier());</span>
    }

    /**
     * Returns the full name of the index, including the schema (delimited
     * by the result of {@link #catalogSeparator}).
     */

    public String getFullName(Index index) {
<span class="nc bnc" id="L3346" title="All 4 branches missed.">        if (!useSchemaName || DBIdentifier.isNull(index.getSchemaIdentifier()))</span>
<span class="nc" id="L3347">            return toDBName(index.getIdentifier());</span>
<span class="nc" id="L3348">        return toDBName(index.getFullIdentifier());</span>
    }

    /**
     * Returns the full name of the sequence, including the schema (delimited
     * by the result of {@link #catalogSeparator}).
     */

    public String getFullName(Sequence seq) {
<span class="nc bnc" id="L3357" title="All 4 branches missed.">        if (!useSchemaName || DBIdentifier.isNull(seq.getSchemaIdentifier()))</span>
<span class="nc" id="L3358">            return toDBName(seq.getIdentifier());</span>
<span class="nc" id="L3359">        return toDBName(seq.getFullIdentifier());</span>
    }

    /**
     * Return the subset of the words in reservedWordSet that cannot be used as
     * valid column names for the current DB. If the column name is invalid the
     * getValidColumnName method of the DB dictionary should be invoked to make
     * it valid.
     *
     * @see #getValidColumnName(org.apache.openjpa.jdbc.identifier.DBIdentifier, org.apache.openjpa.jdbc.schema.Table)
     */
    public final Set&lt;String&gt; getInvalidColumnWordSet() {
<span class="nc" id="L3371">        return invalidColumnWordSet;</span>
    }

    /**
     * Make any necessary changes to the given table name to make it valid for
     * the current DB.
     * @deprecated
     */
    @Deprecated
    public String getValidTableName(String name, Schema schema) {
<span class="nc" id="L3381">        return getValidTableName(DBIdentifier.newTable(name), schema).getName();</span>
    }

    /**
     * Make any necessary changes to the given table name to make it valid for
     * the current DB.
     */
    public DBIdentifier getValidTableName(DBIdentifier name, Schema schema) {
<span class="nc" id="L3389">        return namingUtil.getValidTableIdentifier(name, schema, maxTableNameLength);</span>
    }

    /**
     * Make any necessary changes to the given sequence name to make it valid
     * for the current DB.
     * @deprecated
     */
    @Deprecated
    public String getValidSequenceName(String name, Schema schema) {
<span class="nc" id="L3399">        return getValidSequenceName(DBIdentifier.newSequence(name), schema).getName();</span>
    }

    /**
     * Make any necessary changes to the given sequence name to make it valid
     * for the current DB.
     */
    public DBIdentifier getValidSequenceName(DBIdentifier name, Schema schema) {
<span class="nc" id="L3407">        return namingUtil.getValidSequenceIdentifier(name, schema, maxTableNameLength);</span>
    }

    /**
     * Make any necessary changes to the given column name to make it valid
     * for the current DB.  The column name will be made unique for the
     * specified table.
     * @deprecated
     */
    @Deprecated
    public String getValidColumnName(String name, Table table) {
<span class="nc" id="L3418">        return getValidColumnName(DBIdentifier.newColumn(name), table, true).getName();</span>
    }

    public DBIdentifier processDBColumnName(final DBIdentifier name) {
<span class="nc bnc" id="L3422" title="All 2 branches missed.">        if (&quot;snake_case&quot;.equalsIgnoreCase(javaToDbColumnNameProcessing)) {</span>
<span class="nc" id="L3423">            return DBIdentifier.newColumn(toSnakeCase(name.getName()));</span>
        }
<span class="nc" id="L3425">        throw new IllegalArgumentException(</span>
                &quot;Unsupported javaToDbColumnNameProcessing value: '&quot; + javaToDbColumnNameProcessing + &quot;'&quot;);
    }

    /**
     * Make any necessary changes to the given column name to make it valid
     * for the current DB.  The column name will be made unique for the
     * specified table.
     */
    public DBIdentifier getValidColumnName(DBIdentifier name, Table table) {
<span class="nc" id="L3435">        return getValidColumnName(name, table, true);</span>
    }

    /**
     * Make any necessary changes to the given column name to make it valid
     * for the current DB.  If checkForUniqueness is true, the column name will
     * be made unique for the specified table.
     * @deprecated
     */
    @Deprecated
    public String getValidColumnName(String name, Table table,
        boolean checkForUniqueness) {
<span class="nc" id="L3447">        return getValidColumnName(DBIdentifier.newColumn(name), table, checkForUniqueness).toString();</span>
    }

    /**
     * Make any necessary changes to the given column name to make it valid
     * for the current DB.  If checkForUniqueness is true, the column name will
     * be made unique for the specified table.
     */
    public DBIdentifier getValidColumnName(DBIdentifier name, Table table,
        boolean checkForUniqueness) {
<span class="nc" id="L3457">        return getNamingUtil().getValidColumnIdentifier(name, table, maxColumnNameLength,</span>
            checkForUniqueness);
    }

    /**
     * Make any necessary changes to the given primary key name to make it
     * valid for the current DB.
     */
    public String getValidPrimaryKeyName(String name, Table table) {
<span class="nc bnc" id="L3466" title="All 2 branches missed.">        while (name.startsWith(&quot;_&quot;))</span>
<span class="nc" id="L3467">            name = name.substring(1);</span>
<span class="nc" id="L3468">        return makeNameValid(&quot;P_&quot; + name, table.getSchema().getSchemaGroup(),</span>
            maxConstraintNameLength, NAME_ANY);
    }

    /**
     * Make any necessary changes to the given foreign key name to make it
     * valid for the current DB.
     * @deprecated
     */
    @Deprecated
    public String getValidForeignKeyName(String name, Table table,
        Table toTable) {
<span class="nc" id="L3480">        return getValidForeignKeyName(DBIdentifier.newForeignKey(name), table,</span>
<span class="nc" id="L3481">            toTable).getName();</span>
    }

    /**
     * Make any necessary changes to the given foreign key name to make it
     * valid for the current DB.
     */
    public DBIdentifier getValidForeignKeyName(DBIdentifier name, Table table,
        Table toTable) {
<span class="nc" id="L3490">        return namingUtil.getValidForeignKeyIdentifier(name, table, toTable, maxConstraintNameLength);</span>
    }

    /**
     * Make any necessary changes to the given index name to make it valid
     * for the current DB.
     * @deprecated
     */
    @Deprecated
    public String getValidIndexName(String name, Table table) {
<span class="nc" id="L3500">        return getValidIndexName(DBIdentifier.newIndex(name), table).getName();</span>
    }

    /**
     * Make any necessary changes to the given index name to make it valid
     * for the current DB.
     */
    public DBIdentifier getValidIndexName(DBIdentifier name, Table table) {
<span class="nc" id="L3508">        return getNamingUtil().getValidIndexIdentifier(name, table, maxIndexNameLength);</span>
    }

    /**
     * Make any necessary changes to the given unique constraint name to make
     * it valid for the current DB.
     * @deprecated
     */
    @Deprecated
    public String getValidUniqueName(String name, Table table) {
<span class="nc" id="L3518">        return getValidUniqueName(DBIdentifier.newConstraint(name), table).getName();</span>
    }

    /**
     * Make any necessary changes to the given unique constraint name to make
     * it valid for the current DB.
     */
    public DBIdentifier getValidUniqueName(DBIdentifier name, Table table) {
<span class="nc" id="L3526">        return namingUtil.getValidUniqueIdentifier(name, table, maxConstraintNameLength);</span>
    }

    /**
     * Shorten the specified name to the specified target name. This will
     * be done by first stripping out the vowels, and then removing
     * characters from the middle of the word until it reaches the target
     * length.
     */
    public static String shorten(String name, int targetLength) {
<span class="nc bnc" id="L3536" title="All 4 branches missed.">        if (name == null || name.length() &lt;= targetLength)</span>
<span class="nc" id="L3537">            return name;</span>

<span class="nc" id="L3539">        StringBuilder nm = new StringBuilder(name);</span>
<span class="nc bnc" id="L3540" title="All 2 branches missed.">        while (nm.length() &gt; targetLength) {</span>
<span class="nc bnc" id="L3541" title="All 2 branches missed.">            if (!stripVowel(nm)) {</span>
                // cut out the middle char
<span class="nc" id="L3543">                nm.replace(nm.length() / 2, (nm.length() / 2) + 1, &quot;&quot;);</span>
            }
        }
<span class="nc" id="L3546">        return nm.toString();</span>
    }

    /**
     * Remove vowels from the specified StringBuilder.
     *
     * @return true if any vowels have been removed
     */
    private static boolean stripVowel(StringBuilder name) {
<span class="nc bnc" id="L3555" title="All 4 branches missed.">        if (name == null || name.length() == 0)</span>
<span class="nc" id="L3556">            return false;</span>

<span class="nc" id="L3558">        char[] vowels = { 'A', 'E', 'I', 'O', 'U', };</span>
<span class="nc bnc" id="L3559" title="All 2 branches missed.">        for (int i = 0; i &lt; vowels.length; i++) {</span>
<span class="nc" id="L3560">            int index = name.toString().toUpperCase(Locale.ENGLISH).indexOf(vowels[i]);</span>
<span class="nc bnc" id="L3561" title="All 2 branches missed.">            if (index != -1) {</span>
<span class="nc" id="L3562">                name.replace(index, index + 1, &quot;&quot;);</span>
<span class="nc" id="L3563">                return true;</span>
            }
        }
<span class="nc" id="L3566">        return false;</span>
    }

    /**
     * Shortens the given name to the given maximum length, then checks that
     * it is not a reserved word. If it is reserved, appends a &quot;0&quot;. If
     * the name conflicts with an existing schema component, the last
     * character is replace with '0', then '1', etc.
     * Note that the given max len may be 0 if the database metadata is
     * incomplete.
     * @deprecated
     */
    @Deprecated
    protected String makeNameValid(String name, NameSet set, int maxLen,
        int nameType) {
<span class="nc" id="L3581">        return makeNameValid(name, set, maxLen, nameType, true);</span>
    }

    /**
     * Shortens the given name to the given maximum length, then checks that
     * it is not a reserved word. If it is reserved, appends a &quot;0&quot;. If
     * the name conflicts with an existing schema component, the last
     * character is replace with '0', then '1', etc.
     * Note that the given max len may be 0 if the database metadata is
     * incomplete.
     */
    protected DBIdentifier makeNameValid(DBIdentifier name, NameSet set, int maxLen,
        int nameType) {
<span class="nc" id="L3594">        return makeNameValid(name, set, maxLen, nameType, true);</span>
    }

    /**
     * Shortens the given name to the given maximum length, then checks that
     * it is not a reserved word. If it is reserved, appends a &quot;0&quot;. If
     * the name conflicts with an existing schema component and uniqueness
     * checking is enabled, the last character is replace with '0', then
     * '1', etc.
     * Note that the given max len may be 0 if the database metadata is
     * incomplete.
     *
     * Note: If the name is delimited, make sure the ending delimiter is
     * not stripped off.
     */
    protected String makeNameValid(String name, NameSet set, int maxLen,
        int nameType, boolean checkForUniqueness) {
<span class="nc" id="L3611">        return namingUtil.makeNameValid(name, set,</span>
<span class="nc" id="L3612">            maxLen, nameType, checkForUniqueness).toString();</span>
    }

    /**
     * Shortens the given name to the given maximum length, then checks that
     * it is not a reserved word. If it is reserved, appends a &quot;0&quot;. If
     * the name conflicts with an existing schema component and uniqueness
     * checking is enabled, the last character is replace with '0', then
     * '1', etc.
     * Note that the given max len may be 0 if the database metadata is
     * incomplete.
     *
     * Note: If the name is delimited, make sure the ending delimiter is
     * not stripped off.
     */
    protected DBIdentifier makeNameValid(DBIdentifier name, NameSet set, int maxLen,
        int nameType, boolean checkForUniqueness) {
<span class="nc" id="L3629">        return namingUtil.makeIdentifierValid(name, set,</span>
            maxLen, checkForUniqueness);
    }

    /**
     * Return a series of SQL statements to create the given table, complete
     * with columns. Indexes and constraints will be created separately.
     */
    public String[] getCreateTableSQL(Table table, SchemaGroup group) {
<span class="nc" id="L3638">        return getCreateTableSQL(table);</span>
    }

    /**
     * Return a series of SQL statements to create the given table, complete
     * with columns. Indexes and constraints will be created separately.
     */
    public String[] getCreateTableSQL(Table table) {
<span class="nc" id="L3646">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L3647">        String tableName =</span>
<span class="nc" id="L3648">            checkNameLength(getFullIdentifier(table, false), maxTableNameLength, &quot;long-table-name&quot;,</span>
                tableLengthIncludesSchema);
<span class="nc" id="L3650">        buf.append(&quot;CREATE TABLE &quot;).append(tableName);</span>
<span class="nc bnc" id="L3651" title="All 4 branches missed.">        if (supportsComments &amp;&amp; table.hasComment()) {</span>
<span class="nc" id="L3652">            buf.append(&quot; &quot;);</span>
<span class="nc" id="L3653">            comment(buf, table.getComment());</span>
<span class="nc" id="L3654">            buf.append(&quot;\n    (&quot;);</span>
        } else {
<span class="nc" id="L3656">            buf.append(&quot; (&quot;);</span>
        }

        // do this before getting the columns so we know how to handle
        // the last comma
<span class="nc" id="L3661">        StringBuilder endBuf = new StringBuilder();</span>
<span class="nc" id="L3662">        PrimaryKey pk = table.getPrimaryKey();</span>
        String pkStr;
<span class="nc bnc" id="L3664" title="All 2 branches missed.">        if (pk != null) {</span>
<span class="nc" id="L3665">            pkStr = getPrimaryKeyConstraintSQL(pk);</span>
<span class="nc bnc" id="L3666" title="All 2 branches missed.">            if (pkStr != null)</span>
<span class="nc" id="L3667">                endBuf.append(pkStr);</span>
        }

<span class="nc" id="L3670">        Unique[] unqs = table.getUniques();</span>
        String unqStr;
<span class="nc bnc" id="L3672" title="All 2 branches missed.">        for (int i = 0; i &lt; unqs.length; i++) {</span>
<span class="nc" id="L3673">            unqStr = getUniqueConstraintSQL(unqs[i]);</span>
<span class="nc bnc" id="L3674" title="All 2 branches missed.">            if (unqStr != null) {</span>
<span class="nc bnc" id="L3675" title="All 2 branches missed.">                if (endBuf.length() &gt; 0)</span>
<span class="nc" id="L3676">                    endBuf.append(&quot;, &quot;);</span>
<span class="nc" id="L3677">                endBuf.append(unqStr);</span>
            }
        }

<span class="nc" id="L3681">        Column[] cols = table.getColumns();</span>
<span class="nc bnc" id="L3682" title="All 2 branches missed.">        for (int i = 0; i &lt; cols.length; i++) {</span>
<span class="nc" id="L3683">            buf.append(getDeclareColumnSQL(cols[i], false));</span>
<span class="nc bnc" id="L3684" title="All 4 branches missed.">            if (i &lt; cols.length - 1 || endBuf.length() &gt; 0)</span>
<span class="nc" id="L3685">                buf.append(&quot;, &quot;);</span>
<span class="nc bnc" id="L3686" title="All 4 branches missed.">            if (supportsComments &amp;&amp; cols[i].hasComment()) {</span>
<span class="nc" id="L3687">                comment(buf, cols[i].getComment());</span>
<span class="nc" id="L3688">                buf.append(&quot;\n    &quot;);</span>
            }
        }

<span class="nc" id="L3692">        buf.append(endBuf.toString());</span>
<span class="nc" id="L3693">        buf.append(&quot;)&quot;);</span>
<span class="nc" id="L3694">        return new String[]{ buf.toString() };</span>
    }

    public int getBatchFetchSize(int batchFetchSize) {
<span class="nc" id="L3698">        return batchFetchSize;</span>
    }

    protected StringBuilder comment(StringBuilder buf, String comment) {
<span class="nc" id="L3702">        return buf.append(&quot;-- &quot;).append(comment);</span>
    }

    /**
     * Return a series of SQL statements to drop the given table. Indexes
     * will be dropped separately. Returns
     * &lt;code&gt;DROP TABLE &amp;lt;table name&amp;gt;&lt;/code&gt; by default.
     */
    public String[] getDropTableSQL(Table table) {
<span class="nc" id="L3711">        String drop = MessageFormat.format(dropTableSQL, new Object[]{</span>
<span class="nc" id="L3712">            getFullName(table, false) });</span>
<span class="nc" id="L3713">        return new String[]{ drop };</span>
    }

    /**
     * Return a series of SQL statements to create the given sequence. Returns
     * &lt;code&gt;CREATE SEQUENCE &amp;lt;sequence name&amp;gt;[ START WITH &amp;lt;start&amp;gt;]
     * [ INCREMENT BY &amp;lt;increment&amp;gt;]&lt;/code&gt; by default.
     */
    public String[] getCreateSequenceSQL(Sequence seq) {
<span class="nc" id="L3722">        return commonCreateAlterSequenceSQL(seq, true);</span>
    }

    public String getAlterSequenceSQL(Sequence seq) {
<span class="nc" id="L3726">        return commonCreateAlterSequenceSQL(seq, false)[0];</span>
    }

    private String[] commonCreateAlterSequenceSQL(Sequence seq, boolean create) {
<span class="nc bnc" id="L3730" title="All 2 branches missed.">        if (nextSequenceQuery == null)</span>
<span class="nc" id="L3731">            return null;</span>

        //We need a place to detect if the user is setting the 'useNativeSequenceCache' property.
        //While in previous releases this property had meaning, it is no longer useful
        //given the code added via OPENJPA-1327.  As such, we need to warn user's the
        //property no longer has meaning.  While it would be nice to have a better way
        //to detect if the useNativeSequenceCache property has been set, the best we can do
        //is detect the variable in this code path as this is the path a user's code
        //would go down if they are still executing code which actually made use of
        //the support provided via setting useNativeSequenceCache.
<span class="nc bnc" id="L3741" title="All 4 branches missed.">        if (!useNativeSequenceCache &amp;&amp; logNativeSequenceCacheWarning){</span>
<span class="nc" id="L3742">            log.warn(_loc.get(&quot;sequence-cache-warning&quot;));</span>
<span class="nc" id="L3743">            logNativeSequenceCacheWarning=false;</span>
        }

<span class="nc" id="L3746">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L3747" title="All 2 branches missed.">        buf.append(create ? &quot;CREATE&quot; : &quot;ALTER&quot;).append(&quot; SEQUENCE &quot;);</span>

        //Strip off the schema and verify the sequence name is within the legal length, NOT
        //the schema name + sequence name.
<span class="nc" id="L3751">        checkNameLength(toDBName(seq.getFullIdentifier().getUnqualifiedName()),</span>
            maxTableNameLength, &quot;long-seq-name&quot;);
        //Now use the full sequence name (schema + sequence name).
<span class="nc" id="L3754">        String seqName = getFullName(seq);</span>

<span class="nc" id="L3756">        buf.append(seqName);</span>
<span class="nc bnc" id="L3757" title="All 4 branches missed.">        if (create &amp;&amp; seq.getInitialValue() != 0)</span>
<span class="nc" id="L3758">            buf.append(&quot; START WITH &quot;).append(seq.getInitialValue());</span>
<span class="nc bnc" id="L3759" title="All 4 branches missed.">        if ((seq.getIncrement() &gt;= 1) || (seq.getAllocate() &gt;= 1))</span>
<span class="nc" id="L3760">            buf.append(&quot; INCREMENT BY &quot;).append(seq.getIncrement() * seq.getAllocate());</span>
<span class="nc" id="L3761">        return new String[]{ buf.toString() };</span>
    }

    /**
     * Return a series of SQL statements to drop the given sequence. Returns
     * &lt;code&gt;DROP SEQUENCE &amp;lt;sequence name&amp;gt;&lt;/code&gt; by default.
     */
    public String[] getDropSequenceSQL(Sequence seq) {
<span class="nc" id="L3769">        return new String[]{ &quot;DROP SEQUENCE &quot; + getFullName(seq) };</span>
    }

    /**
     * Return a series of SQL statements to create the given index. Returns
     * &lt;code&gt;CREATE [UNIQUE] INDEX &amp;lt;index name&amp;gt; ON &amp;lt;table name&amp;gt;
     * (&amp;lt;col list&amp;gt;)&lt;/code&gt; by default.
     */
    public String[] getCreateIndexSQL(Index index) {
<span class="nc" id="L3778">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L3779">        buf.append(&quot;CREATE &quot;);</span>
<span class="nc bnc" id="L3780" title="All 2 branches missed.">        if (index.isUnique())</span>
<span class="nc" id="L3781">            buf.append(&quot;UNIQUE &quot;);</span>

<span class="nc" id="L3783">        DBIdentifier fullIdxName = index.getIdentifier();</span>
<span class="nc" id="L3784">        DBIdentifier unQualifiedName = fullIdxName.getUnqualifiedName();</span>
<span class="nc" id="L3785">        checkNameLength(toDBName(unQualifiedName), maxIndexNameLength,</span>
                &quot;long-index-name&quot;);
<span class="nc" id="L3787">        String indexName = toDBName(fullIdxName);</span>

<span class="nc" id="L3789">        buf.append(&quot;INDEX &quot;).append(indexName);</span>
<span class="nc" id="L3790">        buf.append(&quot; ON &quot;).append(getFullName(index.getTable(), false));</span>
<span class="nc" id="L3791">        buf.append(&quot; (&quot;).append(namingUtil.appendColumns(index.getColumns())).</span>
<span class="nc" id="L3792">            append(&quot;)&quot;);</span>

<span class="nc" id="L3794">        return new String[]{ buf.toString() };</span>
    }

    /**
     * Return a series of SQL statements to drop the given index. Returns
     * &lt;code&gt;DROP INDEX &amp;lt;index name&amp;gt;&lt;/code&gt; by default.
     */
    public String[] getDropIndexSQL(Index index) {
<span class="nc" id="L3802">        return new String[]{ &quot;DROP INDEX &quot; + getFullName(index) };</span>
    }

    /**
     * Return a series of SQL statements to add the given column to
     * its table. Return an empty array if operation not supported. Returns
     * &lt;code&gt;ALTER TABLE &amp;lt;table name&amp;gt; ADD (&amp;lt;col dec&amp;gt;)&lt;/code&gt;
     * by default.
     */
    public String[] getAddColumnSQL(Column column) {
<span class="nc bnc" id="L3812" title="All 2 branches missed.">        if (!supportsAlterTableWithAddColumn)</span>
<span class="nc" id="L3813">            return new String[0];</span>

<span class="nc" id="L3815">        String dec = getDeclareColumnSQL(column, true);</span>
<span class="nc bnc" id="L3816" title="All 2 branches missed.">        if (dec == null)</span>
<span class="nc" id="L3817">            return new String[0];</span>
<span class="nc" id="L3818">        return new String[]{ &quot;ALTER TABLE &quot;</span>
<span class="nc" id="L3819">            + getFullName(column.getTable(), false) + &quot; ADD &quot; + dec };</span>
    }

    /**
     * Return a series of SQL statements to drop the given column from
     * its table. Return an empty array if operation not supported. Returns
     * &lt;code&gt;ALTER TABLE &amp;lt;table name&amp;gt; DROP COLUMN &amp;lt;col name&amp;gt;&lt;/code&gt;
     * by default.
     */
    public String[] getDropColumnSQL(Column column) {
<span class="nc bnc" id="L3829" title="All 2 branches missed.">        if (!supportsAlterTableWithDropColumn)</span>
<span class="nc" id="L3830">            return new String[0];</span>
<span class="nc" id="L3831">        return new String[]{ &quot;ALTER TABLE &quot;</span>
<span class="nc" id="L3832">            + getFullName(column.getTable(), false)</span>
            + &quot; DROP COLUMN &quot; + column };
    }

    /**
     * Return a series of SQL statements to add the given primary key to
     * its table. Return an empty array if operation not supported.
     * Returns &lt;code&gt;ALTER TABLE &amp;lt;table name&amp;gt; ADD
     * &amp;lt;pk cons sql &amp;gt;&lt;/code&gt; by default.
     */
    public String[] getAddPrimaryKeySQL(PrimaryKey pk) {
<span class="nc" id="L3843">        String pksql = getPrimaryKeyConstraintSQL(pk);</span>
<span class="nc bnc" id="L3844" title="All 2 branches missed.">        if (pksql == null)</span>
<span class="nc" id="L3845">            return new String[0];</span>
<span class="nc" id="L3846">        return new String[]{ &quot;ALTER TABLE &quot;</span>
<span class="nc" id="L3847">            + getFullName(pk.getTable(), false) + &quot; ADD &quot; + pksql };</span>
    }

    /**
     * Return a series of SQL statements to drop the given primary key from
     * its table. Return an empty array if operation not supported.
     * Returns &lt;code&gt;ALTER TABLE &amp;lt;table name&amp;gt; DROP CONSTRAINT
     * &amp;lt;pk name&amp;gt;&lt;/code&gt; by default.
     */
    public String[] getDropPrimaryKeySQL(PrimaryKey pk) {
<span class="nc bnc" id="L3857" title="All 2 branches missed.">        if (DBIdentifier.isNull(pk.getIdentifier()))</span>
<span class="nc" id="L3858">            return new String[0];</span>
<span class="nc" id="L3859">        return new String[]{ &quot;ALTER TABLE &quot;</span>
<span class="nc" id="L3860">            + getFullName(pk.getTable(), false)</span>
<span class="nc" id="L3861">            + &quot; DROP CONSTRAINT &quot; + toDBName(pk.getIdentifier()) };</span>
    }

    /**
     * Return a series of SQL statements to add the given foreign key to
     * its table. Return an empty array if operation not supported.
     * Returns &lt;code&gt;ALTER TABLE &amp;lt;table name&amp;gt; ADD
     * &amp;lt;fk cons sql &amp;gt;&lt;/code&gt; by default.
     */
    public String[] getAddForeignKeySQL(ForeignKey fk) {
<span class="nc" id="L3871">        String fkSQL = getForeignKeyConstraintSQL(fk);</span>
<span class="nc bnc" id="L3872" title="All 2 branches missed.">        if (fkSQL == null)</span>
<span class="nc" id="L3873">            return new String[0];</span>
<span class="nc" id="L3874">        return new String[]{ &quot;ALTER TABLE &quot;</span>
<span class="nc" id="L3875">            + getFullName(fk.getTable(), false) + &quot; ADD &quot; + fkSQL };</span>
    }

    /**
     * Return a series of SQL statements to drop the given foreign key from
     * its table. Return an empty array if operation not supported.
     * Returns &lt;code&gt;ALTER TABLE &amp;lt;table name&amp;gt; DROP CONSTRAINT
     * &amp;lt;fk name&amp;gt;&lt;/code&gt; by default.
     */
    public String[] getDropForeignKeySQL(ForeignKey fk, Connection conn) {
<span class="nc bnc" id="L3885" title="All 2 branches missed.">        if (DBIdentifier.isNull(fk.getIdentifier())) {</span>
            String[] retVal;
<span class="nc" id="L3887">            DBIdentifier fkName = fk.loadIdentifierFromDB(this,conn);</span>
<span class="nc bnc" id="L3888" title="All 4 branches missed.">            retVal = (fkName == null || fkName.getName() == null) ?  new String[0] :</span>
<span class="nc" id="L3889">                new String[]{ &quot;ALTER TABLE &quot;</span>
<span class="nc" id="L3890">                + getFullName(fk.getTable(), false)</span>
<span class="nc" id="L3891">                + &quot; DROP CONSTRAINT &quot; + toDBName(fkName) };</span>
<span class="nc" id="L3892">            return retVal;</span>
        }
<span class="nc" id="L3894">        return new String[]{ &quot;ALTER TABLE &quot;</span>
<span class="nc" id="L3895">            + getFullName(fk.getTable(), false)</span>
<span class="nc" id="L3896">            + &quot; DROP CONSTRAINT &quot; + toDBName(fk.getIdentifier()) };</span>
    }

    /**
     * Return the declaration SQL for the given column. This method is used
     * for each column from within {@link #getCreateTableSQL} and
     * {@link #getAddColumnSQL}.
     */
    protected String getDeclareColumnSQL(Column col, boolean alter) {
<span class="nc" id="L3905">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L3906">        String columnName = checkNameLength(toDBName(col.getIdentifier()), maxColumnNameLength,</span>
                &quot;long-column-name&quot;);
<span class="nc" id="L3908">        buf.append(columnName).append(&quot; &quot;);</span>
<span class="nc" id="L3909">        buf.append(getTypeName(col));</span>

        // can't add constraints to a column we're adding after table
        // creation, cause some data might already be inserted
<span class="nc bnc" id="L3913" title="All 2 branches missed.">        if (!alter) {</span>
<span class="nc bnc" id="L3914" title="All 4 branches missed.">            if (col.getDefaultString() != null &amp;&amp; !col.isAutoAssigned())</span>
<span class="nc" id="L3915">                buf.append(&quot; DEFAULT &quot;).append(col.getDefaultString());</span>
<span class="nc bnc" id="L3916" title="All 6 branches missed.">            if (col.isNotNull() || (!supportsNullUniqueColumn &amp;&amp; col.hasConstraint(Unique.class)))</span>
<span class="nc" id="L3917">                buf.append(&quot; NOT NULL&quot;);</span>
        }
<span class="nc bnc" id="L3919" title="All 2 branches missed.">        if (col.isAutoAssigned()) {</span>
<span class="nc bnc" id="L3920" title="All 2 branches missed.">            if (!supportsAutoAssign)</span>
<span class="nc" id="L3921">                log.warn(_loc.get(&quot;invalid-autoassign&quot;, platform, col));</span>
<span class="nc bnc" id="L3922" title="All 2 branches missed.">            else if (autoAssignClause != null)</span>
<span class="nc" id="L3923">                buf.append(&quot; &quot;).append(autoAssignClause);</span>
        }
<span class="nc" id="L3925">        return buf.toString();</span>
    }

    /**
     * Return the declaration SQL for the given primary key. This method is
     * used from within {@link #getCreateTableSQL} and
     * {@link #getAddPrimaryKeySQL}. Returns
     * &lt;code&gt;CONSTRAINT &amp;lt;pk name&amp;gt; PRIMARY KEY (&amp;lt;col list&amp;gt;)&lt;/code&gt;
     * by default.
     */
    protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {
        // if we have disabled the creation of primary keys, abort here
<span class="nc bnc" id="L3937" title="All 2 branches missed.">        if (!createPrimaryKeys)</span>
<span class="nc" id="L3938">            return null;</span>

<span class="nc" id="L3940">        String name = toDBName(pk.getIdentifier());</span>
<span class="nc bnc" id="L3941" title="All 4 branches missed.">        if (name != null &amp;&amp; reservedWordSet.contains(name.toUpperCase(Locale.ENGLISH)))</span>
<span class="nc" id="L3942">            name = null;</span>

<span class="nc" id="L3944">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L3945" title="All 4 branches missed.">        if (name != null &amp;&amp; CONS_NAME_BEFORE.equals(constraintNameMode))</span>
<span class="nc" id="L3946">            buf.append(&quot;CONSTRAINT &quot;).append(name).append(&quot; &quot;);</span>
<span class="nc" id="L3947">        buf.append(&quot;PRIMARY KEY &quot;);</span>
<span class="nc bnc" id="L3948" title="All 4 branches missed.">        if (name != null &amp;&amp; CONS_NAME_MID.equals(constraintNameMode))</span>
<span class="nc" id="L3949">            buf.append(name).append(&quot; &quot;);</span>
<span class="nc" id="L3950">        buf.append(&quot;(&quot;).append(namingUtil.appendColumns(pk.getColumns())).</span>
<span class="nc" id="L3951">            append(&quot;)&quot;);</span>
<span class="nc bnc" id="L3952" title="All 4 branches missed.">        if (name != null &amp;&amp; CONS_NAME_AFTER.equals(constraintNameMode))</span>
<span class="nc" id="L3953">            buf.append(&quot; CONSTRAINT &quot;).append(name);</span>
<span class="nc" id="L3954">        return buf.toString();</span>
    }

    /**
     * Return the declaration SQL for the given foreign key, or null if it is
     * not supported. This method is used from within
     * {@link #getCreateTableSQL} and {@link #getAddForeignKeySQL}. Returns
     * &lt;code&gt;CONSTRAINT &amp;lt;cons name&amp;gt; FOREIGN KEY (&amp;lt;col list&amp;gt;)
     * REFERENCES &amp;lt;foreign table&amp;gt; (&amp;lt;col list&amp;gt;)
     * [ON DELETE &amp;lt;action&amp;gt;] [ON UPDATE &amp;lt;action&amp;gt;]&lt;/code&gt; by default.
     */
    protected String getForeignKeyConstraintSQL(ForeignKey fk) {
<span class="nc bnc" id="L3966" title="All 2 branches missed.">        if (!supportsForeignKeys)</span>
<span class="nc" id="L3967">            return null;</span>
<span class="nc bnc" id="L3968" title="All 4 branches missed.">        if (fk.getColumns().length &gt; 0 &amp;&amp; !supportsForeignKeysComposite)</span>
<span class="nc" id="L3969">            return null;</span>
<span class="nc bnc" id="L3970" title="All 2 branches missed.">        if (fk.getDeleteAction() == ForeignKey.ACTION_NONE)</span>
<span class="nc" id="L3971">            return null;</span>
<span class="nc bnc" id="L3972" title="All 4 branches missed.">        if (fk.isDeferred() &amp;&amp; !supportsDeferredForeignKeyConstraints())</span>
<span class="nc" id="L3973">            return null;</span>
<span class="nc bnc" id="L3974" title="All 2 branches missed.">        if (!supportsDeleteAction(fk.getDeleteAction())</span>
<span class="nc bnc" id="L3975" title="All 2 branches missed.">            || !supportsUpdateAction(fk.getUpdateAction()))</span>
<span class="nc" id="L3976">            return null;</span>

<span class="nc" id="L3978">        Column[] locals = fk.getColumns();</span>
<span class="nc" id="L3979">        Column[] foreigns = fk.getPrimaryKeyColumns();</span>

<span class="nc" id="L3981">        int delActionId = fk.getDeleteAction();</span>
<span class="nc bnc" id="L3982" title="All 2 branches missed.">        if (delActionId == ForeignKey.ACTION_NULL) {</span>
<span class="nc bnc" id="L3983" title="All 2 branches missed.">            for (int i = 0; i &lt; locals.length; i++) {</span>
<span class="nc bnc" id="L3984" title="All 2 branches missed.">                if (locals[i].isNotNull())</span>
<span class="nc" id="L3985">                    delActionId = ForeignKey.ACTION_NONE;</span>
            }
        }

<span class="nc" id="L3989">        String delAction = getActionName(delActionId);</span>
<span class="nc" id="L3990">        String upAction = getActionName(fk.getUpdateAction());</span>

<span class="nc" id="L3992">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L3993" title="All 2 branches missed.">        if (!DBIdentifier.isNull(fk.getIdentifier())</span>
<span class="nc bnc" id="L3994" title="All 2 branches missed.">            &amp;&amp; CONS_NAME_BEFORE.equals(constraintNameMode))</span>
<span class="nc" id="L3995">            buf.append(&quot;CONSTRAINT &quot;).append(toDBName(fk.getIdentifier())).append(&quot; &quot;);</span>
<span class="nc" id="L3996">        buf.append(&quot;FOREIGN KEY &quot;);</span>
<span class="nc bnc" id="L3997" title="All 4 branches missed.">        if (!DBIdentifier.isNull(fk.getIdentifier()) &amp;&amp; CONS_NAME_MID.equals(constraintNameMode))</span>
<span class="nc" id="L3998">            buf.append(toDBName(fk.getIdentifier())).append(&quot; &quot;);</span>
<span class="nc" id="L3999">        buf.append(&quot;(&quot;).append(namingUtil.appendColumns(locals)).append(&quot;)&quot;);</span>
<span class="nc" id="L4000">        buf.append(&quot; REFERENCES &quot;);</span>
<span class="nc" id="L4001">        buf.append(getFullName(foreigns[0].getTable(), false));</span>
<span class="nc" id="L4002">        buf.append(&quot; (&quot;).append(namingUtil.appendColumns(foreigns)).append(&quot;)&quot;);</span>
<span class="nc bnc" id="L4003" title="All 2 branches missed.">        if (delAction != null)</span>
<span class="nc" id="L4004">            buf.append(&quot; ON DELETE &quot;).append(delAction);</span>
<span class="nc bnc" id="L4005" title="All 2 branches missed.">        if (upAction != null)</span>
<span class="nc" id="L4006">            buf.append(&quot; ON UPDATE &quot;).append(upAction);</span>
<span class="nc bnc" id="L4007" title="All 2 branches missed.">        if (fk.isDeferred())</span>
<span class="nc" id="L4008">            buf.append(&quot; INITIALLY DEFERRED&quot;);</span>
<span class="nc bnc" id="L4009" title="All 2 branches missed.">        if (supportsDeferredForeignKeyConstraints())</span>
<span class="nc" id="L4010">            buf.append(&quot; DEFERRABLE&quot;);</span>
<span class="nc bnc" id="L4011" title="All 2 branches missed.">        if (!DBIdentifier.isNull(fk.getIdentifier())</span>
<span class="nc bnc" id="L4012" title="All 2 branches missed.">            &amp;&amp; CONS_NAME_AFTER.equals(constraintNameMode))</span>
<span class="nc" id="L4013">            buf.append(&quot; CONSTRAINT &quot;).append(toDBName(fk.getIdentifier()));</span>
<span class="nc" id="L4014">        return buf.toString();</span>
    }

    /**
     * Whether or not this dictionary supports deferred foreign key constraints.
     * This implementation returns {@link #supportsUniqueConstraints}.
     *
     * @since 1.1.0
     */
    protected boolean supportsDeferredForeignKeyConstraints() {
<span class="nc" id="L4024">        return supportsDeferredConstraints;</span>
    }

    /**
     * Return the name of the given foreign key action.
     */
    private String getActionName(int action) {
<span class="nc bnc" id="L4031" title="All 4 branches missed.">        switch (action) {</span>
            case ForeignKey.ACTION_CASCADE:
<span class="nc" id="L4033">                return &quot;CASCADE&quot;;</span>
            case ForeignKey.ACTION_NULL:
<span class="nc" id="L4035">                return &quot;SET NULL&quot;;</span>
            case ForeignKey.ACTION_DEFAULT:
<span class="nc" id="L4037">                return &quot;SET DEFAULT&quot;;</span>
            default:
<span class="nc" id="L4039">                return null;</span>
        }
    }

    /**
     * Whether this database supports the given foreign key delete action.
     */
    public boolean supportsDeleteAction(int action) {
<span class="nc bnc" id="L4047" title="All 2 branches missed.">        if (action == ForeignKey.ACTION_NONE)</span>
<span class="nc" id="L4048">            return true;</span>
<span class="nc bnc" id="L4049" title="All 2 branches missed.">        if (!supportsForeignKeys)</span>
<span class="nc" id="L4050">            return false;</span>
<span class="nc bnc" id="L4051" title="All 5 branches missed.">        switch (action) {</span>
            case ForeignKey.ACTION_RESTRICT:
<span class="nc" id="L4053">                return supportsRestrictDeleteAction;</span>
            case ForeignKey.ACTION_CASCADE:
<span class="nc" id="L4055">                return supportsCascadeDeleteAction;</span>
            case ForeignKey.ACTION_NULL:
<span class="nc" id="L4057">                return supportsNullDeleteAction;</span>
            case ForeignKey.ACTION_DEFAULT:
<span class="nc" id="L4059">                return supportsDefaultDeleteAction;</span>
            default:
<span class="nc" id="L4061">                return false;</span>
        }
    }

    /**
     * Whether this database supports the given foreign key update action.
     */
    public boolean supportsUpdateAction(int action) {
<span class="nc bnc" id="L4069" title="All 2 branches missed.">        if (action == ForeignKey.ACTION_NONE)</span>
<span class="nc" id="L4070">            return true;</span>
<span class="nc bnc" id="L4071" title="All 2 branches missed.">        if (!supportsForeignKeys)</span>
<span class="nc" id="L4072">            return false;</span>
<span class="nc bnc" id="L4073" title="All 5 branches missed.">        switch (action) {</span>
            case ForeignKey.ACTION_RESTRICT:
<span class="nc" id="L4075">                return supportsRestrictUpdateAction;</span>
            case ForeignKey.ACTION_CASCADE:
<span class="nc" id="L4077">                return supportsCascadeUpdateAction;</span>
            case ForeignKey.ACTION_NULL:
<span class="nc" id="L4079">                return supportsNullUpdateAction;</span>
            case ForeignKey.ACTION_DEFAULT:
<span class="nc" id="L4081">                return supportsDefaultUpdateAction;</span>
            default:
<span class="nc" id="L4083">                return false;</span>
        }
    }

    /**
     * Return the declaration SQL for the given unique constraint. This
     * method is used from within {@link #getCreateTableSQL}.
     * Returns &lt;code&gt;CONSTRAINT &amp;lt;name&amp;gt; UNIQUE (&amp;lt;col list&amp;gt;)&lt;/code&gt;
     * by default.
     */
    protected String getUniqueConstraintSQL(Unique unq) {
<span class="nc bnc" id="L4094" title="All 2 branches missed.">        if (!supportsUniqueConstraints</span>
<span class="nc bnc" id="L4095" title="All 4 branches missed.">            || (unq.isDeferred() &amp;&amp; !supportsDeferredUniqueConstraints()))</span>
<span class="nc" id="L4096">            return null;</span>
<span class="nc" id="L4097">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L4098" title="All 2 branches missed.">        if (!DBIdentifier.isNull(unq.getIdentifier())</span>
<span class="nc bnc" id="L4099" title="All 2 branches missed.">            &amp;&amp; CONS_NAME_BEFORE.equals(constraintNameMode))</span>
<span class="nc" id="L4100">            buf.append(&quot;CONSTRAINT &quot;).append(checkNameLength(toDBName(unq.getIdentifier()),</span>
<span class="nc" id="L4101">                maxConstraintNameLength, &quot;long-constraint-name&quot;)).append(&quot; &quot;);</span>
<span class="nc" id="L4102">        buf.append(&quot;UNIQUE &quot;);</span>
<span class="nc bnc" id="L4103" title="All 4 branches missed.">        if (!DBIdentifier.isNull(unq.getIdentifier()) &amp;&amp; CONS_NAME_MID.equals(constraintNameMode))</span>
<span class="nc" id="L4104">            buf.append(toDBName(unq.getIdentifier())).append(&quot; &quot;);</span>
<span class="nc" id="L4105">        buf.append(&quot;(&quot;).append(namingUtil.appendColumns(unq.getColumns())).</span>
<span class="nc" id="L4106">            append(&quot;)&quot;);</span>
<span class="nc bnc" id="L4107" title="All 2 branches missed.">        if (unq.isDeferred())</span>
<span class="nc" id="L4108">            buf.append(&quot; INITIALLY DEFERRED&quot;);</span>
<span class="nc bnc" id="L4109" title="All 2 branches missed.">        if (supportsDeferredUniqueConstraints())</span>
<span class="nc" id="L4110">            buf.append(&quot; DEFERRABLE&quot;);</span>
<span class="nc bnc" id="L4111" title="All 2 branches missed.">        if (!DBIdentifier.isNull(unq.getIdentifier())</span>
<span class="nc bnc" id="L4112" title="All 2 branches missed.">            &amp;&amp; CONS_NAME_AFTER.equals(constraintNameMode))</span>
<span class="nc" id="L4113">            buf.append(&quot; CONSTRAINT &quot;).append(toDBName(unq.getIdentifier()));</span>
<span class="nc" id="L4114">        return buf.toString();</span>
    }

    /**
     * Whether or not this dictionary supports deferred unique constraints.
     * This implementation returns {@link #supportsUniqueConstraints}.
     *
     * @since 1.1.0
     */
    protected boolean supportsDeferredUniqueConstraints() {
<span class="nc" id="L4124">        return supportsDeferredConstraints;</span>
    }

    /////////////////////
    // Database metadata
    /////////////////////

    /**
     * This method is used to filter system tables from database metadata.
     * Return true if the given table name represents a system table that
     * should not appear in the schema definition. By default, returns
     * true only if the given table is in the internal list of system tables,
     * or if the given schema is in the list of system schemas and is not
     * the target schema.
     *
     * @param name the table name
     * @param schema the table schema; may be null
     * @param targetSchema if true, then the given schema was listed by
     * the user as one of his schemas
     * @deprecated
     */
    @Deprecated
    public boolean isSystemTable(String name, String schema,
        boolean targetSchema) {
<span class="nc" id="L4148">        return isSystemTable(DBIdentifier.newTable(name),</span>
<span class="nc" id="L4149">            DBIdentifier.newSchema(schema), targetSchema);</span>
    }

    /**
     * This method is used to filter system tables from database metadata.
     * Return true if the given table name represents a system table that
     * should not appear in the schema definition. By default, returns
     * true only if the given table is in the internal list of system tables,
     * or if the given schema is in the list of system schemas and is not
     * the target schema.
     *
     * @param name the table name
     * @param schema the table schema; may be null
     * @param targetSchema if true, then the given schema was listed by
     * the user as one of his schemas
     */
    public boolean isSystemTable(DBIdentifier name, DBIdentifier schema,
        boolean targetSchema) {
<span class="nc" id="L4167">        DBIdentifier sName = DBIdentifier.toUpper(name);</span>
<span class="nc bnc" id="L4168" title="All 2 branches missed.">        if (systemTableSet.contains(sName.getName()))</span>
<span class="nc" id="L4169">            return true;</span>
<span class="nc" id="L4170">        DBIdentifier schName = DBIdentifier.toUpper(schema);</span>
<span class="nc bnc" id="L4171" title="All 4 branches missed.">        return !targetSchema &amp;&amp; schema != null</span>
<span class="nc bnc" id="L4172" title="All 2 branches missed.">            &amp;&amp; systemSchemaSet.contains(schName.getName());</span>
    }

    /**
     * This method is used to filter system indexes from database metadata.
     * Return true if the given index name represents a system index that
     * should not appear in the schema definition. Returns false by default.
     *
     * @param name the index name
     * @param table the index table
     * @deprecated
     */
    @Deprecated
    public boolean isSystemIndex(String name, Table table) {
<span class="nc" id="L4186">        return false;</span>
    }

    /**
     * This method is used to filter system indexes from database metadata.
     * Return true if the given index name represents a system index that
     * should not appear in the schema definition. Returns false by default.
     *
     * @param name the index name
     * @param table the index table
     */
    public boolean isSystemIndex(DBIdentifier name, Table table) {
<span class="nc" id="L4198">        return false;</span>
    }

    /**
     * This method is used to filter system sequences from database metadata.
     * Return true if the given sequence represents a system sequence that
     * should not appear in the schema definition. Returns true if system
     * schema by default.
     *
     * @param name the table name
     * @param schema the table schema; may be null
     * @param targetSchema if true, then the given schema was listed by
     * the user as one of his schemas
     * @deprecated
     */
    @Deprecated
    public boolean isSystemSequence(String name, String schema,
        boolean targetSchema) {
<span class="nc" id="L4216">        return isSystemSequence(DBIdentifier.newSequence(name),</span>
<span class="nc" id="L4217">            DBIdentifier.newSchema(schema), targetSchema);</span>
    }

    /**
     * This method is used to filter system sequences from database metadata.
     * Return true if the given sequence represents a system sequence that
     * should not appear in the schema definition. Returns true if system
     * schema by default.
     *
     * @param name the table name
     * @param schema the table schema; may be null
     * @param targetSchema if true, then the given schema was listed by
     * the user as one of his schemas
     */
    public boolean isSystemSequence(DBIdentifier name, DBIdentifier schema,
        boolean targetSchema) {
<span class="nc bnc" id="L4233" title="All 4 branches missed.">        return !targetSchema &amp;&amp; !DBIdentifier.isNull(schema)</span>
<span class="nc bnc" id="L4234" title="All 2 branches missed.">            &amp;&amp; systemSchemaSet.contains(DBIdentifier.toUpper(schema).getName());</span>
    }

    /**
     * This method is used to filter system sequences from database metadata.
     * Return true if the given sequence represents a system sequence that
     * should not appear in the schema definition. Returns true if system
     * schema by default.
     *
     * @param name the table name
     * @param schema the table schema; may be null
     * @param targetSchema if true, then the given schema was listed by
     * the user as one of his schemas
     * @param conn connection to the database
     */
    public boolean isSystemSequence(DBIdentifier name, DBIdentifier schema,
        boolean targetSchema, Connection conn) {
<span class="nc" id="L4251">        return isSystemSequence(name, schema, targetSchema);</span>
    }

    /**
     * Reflect on the schema to find tables matching the given name pattern.
     * @deprecated not used by openjpa internally anymore
     * @see #getTables(DatabaseMetaData, DBIdentifier, DBIdentifier, DBIdentifier, Connection)
     */
    @Deprecated
    public Table[] getTables(DatabaseMetaData meta, String catalog,
        String schemaName, String tableName, Connection conn)
        throws SQLException {
<span class="nc" id="L4263">        return getTables(meta, DBIdentifier.newCatalog(catalog), DBIdentifier.newSchema(schemaName),</span>
<span class="nc" id="L4264">            DBIdentifier.newTable(tableName), conn);</span>
    }


    /**
     * Reflect on the schema to find tables matching the given name pattern.
     */
    public Table[] getTables(DatabaseMetaData meta, DBIdentifier sqlCatalog,
        DBIdentifier sqlSchemaName, DBIdentifier sqlTableName, Connection conn)
        throws SQLException {

<span class="nc bnc" id="L4275" title="All 2 branches missed.">        String schemaName = DBIdentifier.isNull(sqlSchemaName) ? null : sqlSchemaName.getName();</span>
<span class="nc bnc" id="L4276" title="All 2 branches missed.">        if (!supportsSchemaForGetTables)</span>
<span class="nc" id="L4277">            schemaName = null;</span>
        else {
<span class="nc" id="L4279">            schemaName = getSchemaNameForMetadata(sqlSchemaName);</span>
        }

<span class="nc" id="L4282">        String[] types = StringUtil.split(tableTypes, &quot;,&quot;, 0);</span>
<span class="nc bnc" id="L4283" title="All 2 branches missed.">        for (int i = 0; i &lt; types.length; i++)</span>
<span class="nc" id="L4284">            types[i] = types[i].trim();</span>

<span class="nc" id="L4286">        beforeMetadataOperation(conn);</span>
<span class="nc" id="L4287">        ResultSet tables = null;</span>
        try {
<span class="nc" id="L4289">            tables = meta.getTables(getCatalogNameForMetadata(sqlCatalog),</span>
<span class="nc" id="L4290">                schemaName, getTableNameForMetadata(sqlTableName), types);</span>
<span class="nc" id="L4291">            List&lt;Table&gt; tableList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L4292" title="All 4 branches missed.">            while (tables != null &amp;&amp; tables.next()) {</span>
<span class="nc" id="L4293">                tableList.add(newTable(tables));</span>
            }
<span class="nc" id="L4295">            return tableList.toArray(new Table[tableList.size()]);</span>
        } finally {
<span class="nc bnc" id="L4297" title="All 2 branches missed.">            if (tables != null) {</span>
                try {
<span class="nc" id="L4299">                    tables.close();</span>
                }
<span class="nc" id="L4301">                catch (Exception e) {</span>
<span class="nc" id="L4302">                }</span>
            }
        }
    }

    /**
     * Create a new table from the information in the schema metadata.
     */
    protected Table newTable(ResultSet tableMeta)
        throws SQLException {
<span class="nc" id="L4312">        Table t = new Table();</span>
<span class="nc" id="L4313">        t.setIdentifier(fromDBName(tableMeta.getString(&quot;TABLE_NAME&quot;), DBIdentifierType.TABLE));</span>
<span class="nc" id="L4314">        return t;</span>
    }

    /**
     * Reflect on the schema to find sequences matching the given name pattern.
     * Returns an empty array by default, as there is no standard way to
     * retrieve a list of sequences.
     * @deprecated
     */
    @Deprecated
    public Sequence[] getSequences(DatabaseMetaData meta, String catalog,
        String schemaName, String sequenceName, Connection conn)
        throws SQLException {
<span class="nc" id="L4327">        return getSequences(meta, DBIdentifier.newCatalog(catalog), DBIdentifier.newSchema(schemaName),</span>
<span class="nc" id="L4328">            DBIdentifier.newSequence(sequenceName), conn);</span>

    }

    public Sequence[] getSequences(DatabaseMetaData meta, DBIdentifier catalog,
        DBIdentifier schemaName, DBIdentifier sequenceName, Connection conn)
        throws SQLException {
<span class="nc" id="L4335">        String str = getSequencesSQL(schemaName, sequenceName);</span>
<span class="nc bnc" id="L4336" title="All 2 branches missed.">        if (str == null)</span>
<span class="nc" id="L4337">            return new Sequence[0];</span>

<span class="nc" id="L4339">        PreparedStatement stmnt = prepareStatement(conn, str);</span>
<span class="nc" id="L4340">        ResultSet rs = null;</span>
        try {
<span class="nc" id="L4342">            int idx = 1;</span>
<span class="nc bnc" id="L4343" title="All 2 branches missed.">            if (!DBIdentifier.isNull(schemaName))</span>
<span class="nc" id="L4344">                stmnt.setString(idx++, DBIdentifier.toUpper(schemaName).getName());</span>
<span class="nc bnc" id="L4345" title="All 2 branches missed.">            if (!DBIdentifier.isNull(sequenceName))</span>
<span class="nc" id="L4346">                stmnt.setString(idx++, sequenceName.getName());</span>
<span class="nc" id="L4347">            setQueryTimeout(stmnt, conf.getQueryTimeout());</span>
<span class="nc" id="L4348">            rs = executeQuery(conn, stmnt, str);</span>
<span class="nc" id="L4349">            return getSequence(rs);</span>
         } finally {
<span class="nc bnc" id="L4351" title="All 2 branches missed.">            if (rs != null)</span>
                try {
<span class="nc" id="L4353">                    rs.close();</span>
<span class="nc" id="L4354">                } catch (SQLException se) {</span>
<span class="nc" id="L4355">                }</span>
<span class="nc bnc" id="L4356" title="All 2 branches missed.">            if (stmnt != null)</span>
                try {
<span class="nc" id="L4358">                    stmnt.close();</span>
<span class="nc" id="L4359">                } catch (SQLException se) {</span>
<span class="nc" id="L4360">                }</span>
        }
    }

    /**
     * Create a new sequence from the information in the schema metadata.
     */
    protected Sequence newSequence(ResultSet sequenceMeta)
        throws SQLException {
<span class="nc" id="L4369">        Sequence seq = new Sequence();</span>
<span class="nc" id="L4370">        seq.setSchemaIdentifier(fromDBName(StringUtil.stripEnd(sequenceMeta.getString(&quot;SEQUENCE_SCHEMA&quot;), null),</span>
            DBIdentifierType.SCHEMA));
<span class="nc" id="L4372">        seq.setIdentifier(fromDBName(StringUtil.stripEnd(sequenceMeta.getString(&quot;SEQUENCE_NAME&quot;), null),</span>
            DBIdentifierType.SEQUENCE));
<span class="nc" id="L4374">        return seq;</span>
    }

    /**
     * Return the SQL needed to select the list of sequences.
     * @deprecated
     */
    @Deprecated
    protected String getSequencesSQL(String schemaName, String sequenceName) {
<span class="nc" id="L4383">        return null;</span>
    }

    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {
<span class="nc" id="L4387">        return null;</span>
    }

    /**
     * Reflect on the schema to find columns matching the given table and
     * column patterns.
     * @deprecated
     */
    @Deprecated
    public Column[] getColumns(DatabaseMetaData meta, String catalog,
        String schemaName, String tableName, String columnName, Connection conn)
        throws SQLException {
<span class="nc" id="L4399">        return getColumns(meta, DBIdentifier.newCatalog(catalog),</span>
<span class="nc" id="L4400">            DBIdentifier.newSchema(schemaName),</span>
<span class="nc" id="L4401">            DBIdentifier.newTable(tableName),</span>
<span class="nc" id="L4402">            DBIdentifier.newColumn(columnName),</span>
            conn);
    }

    /**
     * Reflect on the schema to find columns matching the given table and
     * column patterns.
     */
    public Column[] getColumns(DatabaseMetaData meta, DBIdentifier catalog,
        DBIdentifier schemaName, DBIdentifier tableName, DBIdentifier columnName, Connection conn)
        throws SQLException {
<span class="nc bnc" id="L4413" title="All 4 branches missed.">        if (DBIdentifier.isNull(tableName) &amp;&amp; !supportsNullTableForGetColumns)</span>
<span class="nc" id="L4414">            return null;</span>

<span class="nc" id="L4416">        String sqlSchemaName = null;</span>
<span class="nc bnc" id="L4417" title="All 2 branches missed.">        if (!DBIdentifier.isNull(schemaName)) {</span>
<span class="nc" id="L4418">            sqlSchemaName = schemaName.getName();</span>
        }
<span class="nc bnc" id="L4420" title="All 2 branches missed.">        if (!supportsSchemaForGetColumns)</span>
<span class="nc" id="L4421">            sqlSchemaName = null;</span>
        else
<span class="nc" id="L4423">            sqlSchemaName = getSchemaNameForMetadata(schemaName);</span>

<span class="nc" id="L4425">        beforeMetadataOperation(conn);</span>
<span class="nc" id="L4426">        ResultSet cols = null;</span>
        try {
<span class="nc" id="L4428">            cols = meta.getColumns(getCatalogNameForMetadata(catalog),</span>
<span class="nc" id="L4429">                sqlSchemaName, getTableNameForMetadata(tableName),</span>
<span class="nc" id="L4430">                getColumnNameForMetadata(columnName));</span>

<span class="nc" id="L4432">            List columnList = new ArrayList();</span>
<span class="nc bnc" id="L4433" title="All 4 branches missed.">            while (cols != null &amp;&amp; cols.next())</span>
<span class="nc" id="L4434">                columnList.add(newColumn(cols));</span>
<span class="nc" id="L4435">            return (Column[]) columnList.toArray</span>
<span class="nc" id="L4436">                (new Column[columnList.size()]);</span>
        } finally {
<span class="nc bnc" id="L4438" title="All 2 branches missed.">            if (cols != null)</span>
                try {
<span class="nc" id="L4440">                    cols.close();</span>
<span class="nc" id="L4441">                } catch (Exception e) {</span>
<span class="nc" id="L4442">                }</span>
        }
    }

    /**
     * Create a new column from the information in the schema metadata.
     */
    protected Column newColumn(ResultSet colMeta)
        throws SQLException {
<span class="nc" id="L4451">        Column c = new Column();</span>
<span class="nc" id="L4452">        c.setSchemaIdentifier(fromDBName(colMeta.getString(&quot;TABLE_SCHEM&quot;), DBIdentifierType.SCHEMA));</span>
<span class="nc" id="L4453">        c.setTableIdentifier(fromDBName(colMeta.getString(&quot;TABLE_NAME&quot;), DBIdentifierType.TABLE));</span>
<span class="nc" id="L4454">        c.setIdentifier(fromDBName(colMeta.getString(&quot;COLUMN_NAME&quot;), DBIdentifierType.COLUMN));</span>
<span class="nc" id="L4455">        c.setType(colMeta.getInt(&quot;DATA_TYPE&quot;));</span>
<span class="nc" id="L4456">        c.setTypeIdentifier(fromDBName(colMeta.getString(&quot;TYPE_NAME&quot;), DBIdentifierType.COLUMN_DEFINITION));</span>
<span class="nc" id="L4457">        c.setSize(colMeta.getInt(&quot;COLUMN_SIZE&quot;));</span>
<span class="nc" id="L4458">        c.setDecimalDigits(colMeta.getInt(&quot;DECIMAL_DIGITS&quot;));</span>
<span class="nc bnc" id="L4459" title="All 2 branches missed.">        c.setNotNull(colMeta.getInt(&quot;NULLABLE&quot;)</span>
            == DatabaseMetaData.columnNoNulls);

<span class="nc" id="L4462">        String def = colMeta.getString(&quot;COLUMN_DEF&quot;);</span>
<span class="nc bnc" id="L4463" title="All 4 branches missed.">        if (!StringUtil.isEmpty(def) &amp;&amp; !&quot;null&quot;.equalsIgnoreCase(def))</span>
<span class="nc" id="L4464">            c.setDefaultString(def);</span>
<span class="nc" id="L4465">        return c;</span>
    }

    /**
     * Reflect on the schema to find primary keys for the given table pattern.
     * @deprecated
     */
    @Deprecated
    public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta,
        String catalog, String schemaName, String tableName, Connection conn)
        throws SQLException {
<span class="nc" id="L4476">        return getPrimaryKeys(meta, DBIdentifier.newCatalog(catalog), DBIdentifier.newSchema(schemaName),</span>
<span class="nc" id="L4477">            DBIdentifier.newTable(tableName), conn);</span>
    }

    /**
     * Reflect on the schema to find primary keys for the given table pattern.
     */
    public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta,
        DBIdentifier catalog, DBIdentifier schemaName, DBIdentifier tableName, Connection conn)
        throws SQLException {
<span class="nc bnc" id="L4486" title="All 2 branches missed.">        if (useGetBestRowIdentifierForPrimaryKeys)</span>
<span class="nc" id="L4487">            return getPrimaryKeysFromBestRowIdentifier(meta, catalog,</span>
                schemaName, tableName, conn);
<span class="nc" id="L4489">        return getPrimaryKeysFromGetPrimaryKeys(meta, catalog,</span>
            schemaName, tableName, conn);
    }

    /**
     * Reflect on the schema to find primary keys for the given table pattern.
     * @deprecated
     */
    @Deprecated
    protected PrimaryKey[] getPrimaryKeysFromGetPrimaryKeys
        (DatabaseMetaData meta, String catalog, String schemaName,
            String tableName, Connection conn)
    throws SQLException {
<span class="nc" id="L4502">        return getPrimaryKeysFromGetPrimaryKeys(meta, DBIdentifier.newCatalog(catalog),</span>
<span class="nc" id="L4503">            DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName), conn);</span>
    }
    /**
     * Reflect on the schema to find primary keys for the given table pattern.
     */
    protected PrimaryKey[] getPrimaryKeysFromGetPrimaryKeys
        (DatabaseMetaData meta, DBIdentifier catalog, DBIdentifier schemaName,
            DBIdentifier tableName, Connection conn)
        throws SQLException {
<span class="nc bnc" id="L4512" title="All 4 branches missed.">        if (tableName == null &amp;&amp; !supportsNullTableForGetPrimaryKeys)</span>
<span class="nc" id="L4513">            return null;</span>

<span class="nc" id="L4515">        beforeMetadataOperation(conn);</span>
<span class="nc" id="L4516">        ResultSet pks = null;</span>
        try {
<span class="nc" id="L4518">            pks = meta.getPrimaryKeys(getCatalogNameForMetadata(catalog),</span>
<span class="nc" id="L4519">                getSchemaNameForMetadata(schemaName),</span>
<span class="nc" id="L4520">                getTableNameForMetadata(tableName));</span>

<span class="nc" id="L4522">            List pkList = new ArrayList();</span>
<span class="nc bnc" id="L4523" title="All 4 branches missed.">            while (pks != null &amp;&amp; pks.next())</span>
<span class="nc" id="L4524">                pkList.add(newPrimaryKey(pks));</span>
<span class="nc" id="L4525">            return (PrimaryKey[]) pkList.toArray</span>
<span class="nc" id="L4526">                (new PrimaryKey[pkList.size()]);</span>
        } finally {
<span class="nc bnc" id="L4528" title="All 2 branches missed.">            if (pks != null)</span>
                try {
<span class="nc" id="L4530">                    pks.close();</span>
<span class="nc" id="L4531">                } catch (Exception e) {</span>
<span class="nc" id="L4532">                }</span>
        }
    }

    /**
     * Create a new primary key from the information in the schema metadata.
     */
    protected PrimaryKey newPrimaryKey(ResultSet pkMeta)
        throws SQLException {
<span class="nc" id="L4541">        PrimaryKey pk = new PrimaryKey();</span>
<span class="nc" id="L4542">        pk.setSchemaIdentifier(fromDBName(pkMeta.getString(&quot;TABLE_SCHEM&quot;), DBIdentifierType.SCHEMA));</span>
<span class="nc" id="L4543">        pk.setTableIdentifier(fromDBName(pkMeta.getString(&quot;TABLE_NAME&quot;), DBIdentifierType.TABLE));</span>
<span class="nc" id="L4544">        pk.setColumnIdentifier(fromDBName(pkMeta.getString(&quot;COLUMN_NAME&quot;), DBIdentifierType.COLUMN));</span>
<span class="nc" id="L4545">        pk.setIdentifier(fromDBName(pkMeta.getString(&quot;PK_NAME&quot;), DBIdentifierType.CONSTRAINT));</span>
<span class="nc" id="L4546">        return pk;</span>
    }

    /**
     * Reflect on the schema to find primary keys for the given table pattern.
     * @deprecated
     */
    @Deprecated
    protected PrimaryKey[] getPrimaryKeysFromBestRowIdentifier
        (DatabaseMetaData meta, String catalog, String schemaName,
            String tableName, Connection conn) throws SQLException {
<span class="nc" id="L4557">        return getPrimaryKeysFromBestRowIdentifier(meta, DBIdentifier.newCatalog(catalog),</span>
<span class="nc" id="L4558">            DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName), conn);</span>
    }

    /**
     * Reflect on the schema to find primary keys for the given table pattern.
     */
    protected PrimaryKey[] getPrimaryKeysFromBestRowIdentifier
        (DatabaseMetaData meta, DBIdentifier catalog, DBIdentifier schemaName,
            DBIdentifier tableName, Connection conn)
        throws SQLException {
<span class="nc bnc" id="L4568" title="All 2 branches missed.">        if (tableName == null)</span>
<span class="nc" id="L4569">            return null;</span>

<span class="nc" id="L4571">        beforeMetadataOperation(conn);</span>
<span class="nc" id="L4572">        ResultSet pks = null;</span>
        try {
<span class="nc" id="L4574">            pks = meta.getBestRowIdentifier(toDBName(catalog), toDBName(schemaName),</span>
<span class="nc" id="L4575">                toDBName(tableName), 0, false);</span>

<span class="nc" id="L4577">            List pkList = new ArrayList();</span>
<span class="nc bnc" id="L4578" title="All 4 branches missed.">            while (pks != null &amp;&amp; pks.next()) {</span>
<span class="nc" id="L4579">                PrimaryKey pk = new PrimaryKey();</span>
<span class="nc" id="L4580">                pk.setSchemaIdentifier(schemaName);</span>
<span class="nc" id="L4581">                pk.setTableIdentifier(tableName);</span>
<span class="nc" id="L4582">                pk.setColumnIdentifier(fromDBName(pks.getString(&quot;COLUMN_NAME&quot;), DBIdentifierType.COLUMN));</span>
<span class="nc" id="L4583">                pkList.add(pk);</span>
<span class="nc" id="L4584">            }</span>
<span class="nc" id="L4585">            return (PrimaryKey[]) pkList.toArray</span>
<span class="nc" id="L4586">                (new PrimaryKey[pkList.size()]);</span>
        } finally {
<span class="nc bnc" id="L4588" title="All 2 branches missed.">            if (pks != null)</span>
                try {
<span class="nc" id="L4590">                    pks.close();</span>
<span class="nc" id="L4591">                } catch (Exception e) {</span>
<span class="nc" id="L4592">                }</span>
        }
    }

    /**
     * Reflect on the schema to find indexes matching the given table pattern.
     * @deprecated
     */
    @Deprecated
    public Index[] getIndexInfo(DatabaseMetaData meta, String catalog,
        String schemaName, String tableName, boolean unique,
        boolean approx, Connection conn)
        throws SQLException {
<span class="nc" id="L4605">        return getIndexInfo(meta, DBIdentifier.newCatalog(catalog),</span>
<span class="nc" id="L4606">            DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName), unique,</span>
            approx, conn);
    }

    /**
     * Reflect on the schema to find indexes matching the given table pattern.
     */
    public Index[] getIndexInfo(DatabaseMetaData meta, DBIdentifier catalog,
        DBIdentifier schemaName, DBIdentifier tableName, boolean unique,
        boolean approx, Connection conn)
        throws SQLException {
<span class="nc bnc" id="L4617" title="All 4 branches missed.">        if (tableName == null &amp;&amp; !supportsNullTableForGetIndexInfo)</span>
<span class="nc" id="L4618">            return null;</span>

<span class="nc" id="L4620">        beforeMetadataOperation(conn);</span>
<span class="nc" id="L4621">        ResultSet indexes = null;</span>
        try {
<span class="nc" id="L4623">            indexes = meta.getIndexInfo(getCatalogNameForMetadata(catalog),</span>
<span class="nc" id="L4624">                getSchemaNameForMetadata(schemaName),</span>
<span class="nc" id="L4625">                getTableNameForMetadata(tableName), unique, approx);</span>

<span class="nc" id="L4627">            List indexList = new ArrayList();</span>
<span class="nc bnc" id="L4628" title="All 4 branches missed.">            while (indexes != null &amp;&amp; indexes.next())</span>
<span class="nc" id="L4629">                indexList.add(newIndex(indexes));</span>
<span class="nc" id="L4630">            return (Index[]) indexList.toArray(new Index[indexList.size()]);</span>
        } finally {
<span class="nc bnc" id="L4632" title="All 2 branches missed.">            if (indexes != null)</span>
                try {
<span class="nc" id="L4634">                    indexes.close();</span>
<span class="nc" id="L4635">                } catch (Exception e) {</span>
<span class="nc" id="L4636">                }</span>
        }
    }

    /**
     * Create a new index from the information in the schema metadata.
     */
    protected Index newIndex(ResultSet idxMeta)
        throws SQLException {
<span class="nc" id="L4645">        Index idx = new Index();</span>
<span class="nc" id="L4646">        idx.setSchemaIdentifier(fromDBName(idxMeta.getString(&quot;TABLE_SCHEM&quot;), DBIdentifierType.SCHEMA));</span>
<span class="nc" id="L4647">        idx.setTableIdentifier(fromDBName(idxMeta.getString(&quot;TABLE_NAME&quot;), DBIdentifierType.TABLE));</span>
<span class="nc" id="L4648">        idx.setColumnIdentifier(fromDBName(idxMeta.getString(&quot;COLUMN_NAME&quot;), DBIdentifierType.COLUMN));</span>
<span class="nc" id="L4649">        idx.setIdentifier(fromDBName(idxMeta.getString(&quot;INDEX_NAME&quot;), DBIdentifierType.INDEX));</span>
<span class="nc bnc" id="L4650" title="All 2 branches missed.">        idx.setUnique(!idxMeta.getBoolean(&quot;NON_UNIQUE&quot;));</span>
<span class="nc" id="L4651">        return idx;</span>
    }

    /**
     * Reflect on the schema to return foreign keys imported by the given
     * table pattern.
     * @deprecated
     */
    @Deprecated
    public ForeignKey[] getImportedKeys(DatabaseMetaData meta, String catalog,
        String schemaName, String tableName, Connection conn)
        throws SQLException {
<span class="nc" id="L4663">        return getImportedKeys(meta, catalog, schemaName, tableName, conn, true);</span>
    }

    /**
     * Reflect on the schema to return foreign keys imported by the given
     * table pattern.
     */
    public ForeignKey[] getImportedKeys(DatabaseMetaData meta, DBIdentifier catalog,
        DBIdentifier schemaName, DBIdentifier tableName, Connection conn)
        throws SQLException {
<span class="nc" id="L4673">        return getImportedKeys(meta, catalog, schemaName, tableName, conn, true);</span>
    }

    /**
     * Reflect on the schema to return full foreign keys imported by the given
     * table pattern.
     * @deprecated
     */
    @Deprecated
    public ForeignKey[] getImportedKeys(DatabaseMetaData meta, String catalog,
        String schemaName, String tableName, Connection conn, boolean partialKeys)
        throws SQLException {
<span class="nc" id="L4685">        return getImportedKeys(meta, DBIdentifier.newCatalog(catalog),</span>
<span class="nc" id="L4686">            DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName), conn, partialKeys);</span>
    }

    /**
     * Reflect on the schema to return full foreign keys imported by the given
     * table pattern.
     */
    public ForeignKey[] getImportedKeys(DatabaseMetaData meta, DBIdentifier catalog,
        DBIdentifier schemaName, DBIdentifier tableName, Connection conn, boolean partialKeys)
        throws SQLException {
<span class="nc bnc" id="L4696" title="All 2 branches missed.">        if (!supportsForeignKeys)</span>
<span class="nc" id="L4697">            return null;</span>
<span class="nc bnc" id="L4698" title="All 4 branches missed.">        if (tableName == null &amp;&amp; !supportsNullTableForGetImportedKeys)</span>
<span class="nc" id="L4699">            return null;</span>

<span class="nc" id="L4701">        beforeMetadataOperation(conn);</span>
<span class="nc" id="L4702">        try (ResultSet keys = meta.getImportedKeys(getCatalogNameForMetadata(catalog),</span>
<span class="nc" id="L4703">                getSchemaNameForMetadata(schemaName),</span>
<span class="nc" id="L4704">                getTableNameForMetadata(tableName))) {</span>

<span class="nc" id="L4706">            List&lt;ForeignKey&gt; importedKeyList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L4707">            Map&lt;FKMapKey, ForeignKey&gt; fkMap = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L4709" title="All 4 branches missed.">            while (keys != null &amp;&amp; keys.next()) {</span>
<span class="nc" id="L4710">                ForeignKey nfk = newForeignKey(keys);</span>
<span class="nc bnc" id="L4711" title="All 2 branches missed.">                if (!partialKeys) {</span>
<span class="nc" id="L4712">                    ForeignKey fk = combineForeignKey(fkMap, nfk);</span>
                    // If the key returned != new key, fk col was combined
                    // with existing fk.
<span class="nc bnc" id="L4715" title="All 2 branches missed.">                    if (fk != nfk) {</span>
<span class="nc" id="L4716">                        continue;</span>
                    }
                }
<span class="nc" id="L4719">                importedKeyList.add(nfk);</span>
<span class="nc" id="L4720">            }</span>
<span class="nc" id="L4721">            return (ForeignKey[]) importedKeyList.toArray</span>
<span class="nc" id="L4722">                (new ForeignKey[importedKeyList.size()]);</span>
        }
    }

    /**
     * Combines partial foreign keys into singular key
     */
    protected ForeignKey combineForeignKey(Map&lt;FKMapKey, ForeignKey&gt; fkMap,
        ForeignKey fk) {

<span class="nc" id="L4732">        FKMapKey fkmk = new FKMapKey(fk);</span>
<span class="nc" id="L4733">        ForeignKey baseKey = fkMap.get(fkmk);</span>
        // Found the FK, add the additional column
<span class="nc bnc" id="L4735" title="All 2 branches missed.">        if (baseKey != null) {</span>
<span class="nc" id="L4736">            baseKey.addColumn(fk);</span>
<span class="nc" id="L4737">            return baseKey;</span>
        }
        // fkey is new
<span class="nc" id="L4740">        fkMap.put(fkmk, fk);</span>
<span class="nc" id="L4741">        return fk;</span>
    }

    /**
     * Create a new foreign key from the information in the schema metadata.
     */
    protected ForeignKey newForeignKey(ResultSet fkMeta)
        throws SQLException {
<span class="nc" id="L4749">        ForeignKey fk = new ForeignKey();</span>
<span class="nc" id="L4750">        fk.setSchemaIdentifier(fromDBName(fkMeta.getString(&quot;FKTABLE_SCHEM&quot;), DBIdentifierType.SCHEMA));</span>
<span class="nc" id="L4751">        fk.setTableIdentifier(fromDBName(fkMeta.getString(&quot;FKTABLE_NAME&quot;), DBIdentifierType.TABLE));</span>
<span class="nc" id="L4752">        fk.setColumnIdentifier(fromDBName(fkMeta.getString(&quot;FKCOLUMN_NAME&quot;), DBIdentifierType.COLUMN));</span>
<span class="nc" id="L4753">        fk.setIdentifier(fromDBName(fkMeta.getString(&quot;FK_NAME&quot;), DBIdentifierType.FOREIGN_KEY));</span>
<span class="nc" id="L4754">        fk.setPrimaryKeySchemaIdentifier(fromDBName(fkMeta.getString(&quot;PKTABLE_SCHEM&quot;), DBIdentifierType.SCHEMA));</span>
<span class="nc" id="L4755">        fk.setPrimaryKeyTableIdentifier(fromDBName(fkMeta.getString(&quot;PKTABLE_NAME&quot;), DBIdentifierType.TABLE));</span>
<span class="nc" id="L4756">        fk.setPrimaryKeyColumnIdentifier(fromDBName(fkMeta.getString(&quot;PKCOLUMN_NAME&quot;), DBIdentifierType.COLUMN));</span>
<span class="nc" id="L4757">        fk.setKeySequence(fkMeta.getShort(&quot;KEY_SEQ&quot;));</span>
<span class="nc bnc" id="L4758" title="All 2 branches missed.">        fk.setDeferred(fkMeta.getShort(&quot;DEFERRABILITY&quot;)</span>
            == DatabaseMetaData.importedKeyInitiallyDeferred);

<span class="nc" id="L4761">        int del = fkMeta.getShort(&quot;DELETE_RULE&quot;);</span>
<span class="nc bnc" id="L4762" title="All 4 branches missed.">        switch (del) {</span>
            case DatabaseMetaData.importedKeySetNull:
<span class="nc" id="L4764">                fk.setDeleteAction(ForeignKey.ACTION_NULL);</span>
<span class="nc" id="L4765">                break;</span>
            case DatabaseMetaData.importedKeySetDefault:
<span class="nc" id="L4767">                fk.setDeleteAction(ForeignKey.ACTION_DEFAULT);</span>
<span class="nc" id="L4768">                break;</span>
            case DatabaseMetaData.importedKeyCascade:
<span class="nc" id="L4770">                fk.setDeleteAction(ForeignKey.ACTION_CASCADE);</span>
<span class="nc" id="L4771">                break;</span>
            default:
<span class="nc" id="L4773">                fk.setDeleteAction(ForeignKey.ACTION_RESTRICT);</span>
                break;
        }
<span class="nc" id="L4776">        return fk;</span>
    }

    /**
     * Returns the table name that will be used for obtaining information
     * from {@link DatabaseMetaData}.
     */
    protected String getTableNameForMetadata(String tableName) {
<span class="nc" id="L4784">        return convertSchemaCase(DBIdentifier.newTable(tableName));</span>
    }

    /**
     * Returns the table name that will be used for obtaining information
     * from {@link DatabaseMetaData}.
     */
    protected String getTableNameForMetadata(DBIdentifier tableName) {
<span class="nc bnc" id="L4792" title="All 2 branches missed.">        if (tableName == null) {</span>
<span class="nc" id="L4793">            return null;</span>
        }
<span class="nc" id="L4795">        return convertSchemaCase(tableName.getUnqualifiedName());</span>
    }

    /**
     * Returns the schema name that will be used for obtaining information
     * from {@link DatabaseMetaData}.
     */
    protected String getSchemaNameForMetadata(String schemaName) {
<span class="nc bnc" id="L4803" title="All 2 branches missed.">        if (schemaName == null)</span>
<span class="nc" id="L4804">            schemaName = conf.getSchema();</span>
<span class="nc" id="L4805">        return convertSchemaCase(DBIdentifier.newSchema(schemaName));</span>
    }

    /**
     * Returns the schema name that will be used for obtaining information
     * from {@link DatabaseMetaData}.
     */
    protected String getSchemaNameForMetadata(DBIdentifier schemaName) {
<span class="nc bnc" id="L4813" title="All 2 branches missed.">        if (DBIdentifier.isNull(schemaName))</span>
<span class="nc" id="L4814">            schemaName = DBIdentifier.newSchema(conf.getSchema());</span>
<span class="nc" id="L4815">        return convertSchemaCase(schemaName);</span>
    }

    /**
     * Returns the catalog name that will be used for obtaining information
     * from {@link DatabaseMetaData}.
     */
    protected String getCatalogNameForMetadata(String catalogName) {
<span class="nc" id="L4823">        return convertSchemaCase(DBIdentifier.newCatalog(catalogName));</span>
    }

    /**
     * Returns the catalog name that will be used for obtaining information
     * from {@link DatabaseMetaData}.
     */
    protected String getCatalogNameForMetadata(DBIdentifier catalogName) {
<span class="nc" id="L4831">        return convertSchemaCase(catalogName);</span>
    }

    /**
     * Returns the column name that will be used for obtaining information
     * from {@link DatabaseMetaData}.
     */
    protected String getColumnNameForMetadata(String columnName) {
<span class="nc" id="L4839">        return convertSchemaCase(DBIdentifier.newColumn(columnName));</span>
    }

    /**
     * Returns the column name that will be used for obtaining information
     * from {@link DatabaseMetaData}.
     */
    protected String getColumnNameForMetadata(DBIdentifier columnName) {
<span class="nc" id="L4847">        return convertSchemaCase(columnName);</span>
    }

    /**
     * Convert the specified schema name to a name that the database will
     * be able to understand.
     */
    public String convertSchemaCase(String objectName) {
<span class="nc" id="L4855">        return convertSchemaCase(DBIdentifier.newIdentifier(objectName, DBIdentifierType.DEFAULT, false));</span>
    }

    /**
     * Convert the specified schema name to a name that the database will
     * be able to understand.
     */
    public String convertSchemaCase(DBIdentifier objectName) {
<span class="nc" id="L4863">        return toDBName(namingUtil.convertSchemaCase(objectName), false);</span>
    }

    /**
     * Return DB specific schemaCase
     */
    @Override
    public String getSchemaCase(){
<span class="nc" id="L4871">        return schemaCase;</span>
    }

    /**
     * Prepared the connection for metadata operations.
     */
    private void beforeMetadataOperation(Connection c) {
<span class="nc bnc" id="L4878" title="All 2 branches missed.">        if (requiresAutoCommitForMetaData) {</span>
            try {
<span class="nc" id="L4880">                c.rollback();</span>
<span class="nc" id="L4881">            } catch (SQLException sqle) {</span>
<span class="nc" id="L4882">            }</span>
            try {
<span class="nc bnc" id="L4884" title="All 2 branches missed.">                if (!c.getAutoCommit())</span>
<span class="nc" id="L4885">                    c.setAutoCommit(true);</span>
<span class="nc" id="L4886">            } catch (SQLException sqle) {</span>
<span class="nc" id="L4887">            }</span>
        }
<span class="nc" id="L4889">    }</span>

    /////////////////////////////
    // Sequences and Auto-Assign
    /////////////////////////////

    /**
     * Return the last generated value for the given column.
     * Throws an exception by default if {@link #lastGeneratedKeyQuery} is null.
     */
    public Object getGeneratedKey(Column col, Connection conn)
        throws SQLException {
<span class="nc bnc" id="L4901" title="All 2 branches missed.">        if (lastGeneratedKeyQuery == null)</span>
<span class="nc" id="L4902">            throw new StoreException(_loc.get(&quot;no-auto-assign&quot;));</span>

        // replace things like &quot;SELECT MAX({0}) FROM {1}&quot;
<span class="nc" id="L4905">        String query = lastGeneratedKeyQuery;</span>
<span class="nc bnc" id="L4906" title="All 2 branches missed.">        if (query.indexOf('{') != -1) // only if the token is in the string</span>
        {
<span class="nc" id="L4908">            query = getGenKeySeqName(query, col);</span>
        }

<span class="nc" id="L4911">        PreparedStatement stmnt = prepareStatement(conn, query);</span>
<span class="nc" id="L4912">        ResultSet rs = null;</span>
        try {
<span class="nc" id="L4914">            setQueryTimeout(stmnt, conf.getQueryTimeout());</span>
<span class="nc" id="L4915">            rs = executeQuery(conn, stmnt, query);</span>
<span class="nc" id="L4916">            return getKey(rs, col);</span>
        } finally {
<span class="nc bnc" id="L4918" title="All 2 branches missed.">            if (rs != null)</span>
<span class="nc" id="L4919">                try { rs.close(); } catch (SQLException se) {}</span>
<span class="nc bnc" id="L4920" title="All 2 branches missed.">            if (stmnt != null)</span>
<span class="nc" id="L4921">                try { stmnt.close(); } catch (SQLException se) {}</span>
        }
    }

    protected String getGenKeySeqName(String query, Column col) {
<span class="nc" id="L4926">        return MessageFormat.format(query, new Object[]{</span>
<span class="nc" id="L4927">                toDBName(col.getIdentifier()), getFullName(col.getTable(), false),</span>
<span class="nc" id="L4928">                getGeneratedKeySequenceName(col),</span>
            });
    }

    /**
     * Return the sequence name used by databases for the given autoassigned
     * column. This is only used by databases that require an explicit name
     * to be used for auto-assign support.
     */
    protected String getGeneratedKeySequenceName(Column col) {
<span class="nc" id="L4938">        return toDBName(namingUtil.getGeneratedKeySequenceName(col, maxAutoAssignNameLength));</span>
    }

<span class="nc" id="L4941">    protected Map&lt;String, StoredProcedure&gt; _procs = new TreeMap&lt;&gt;();</span>

    /**
     * Gets the metadata of the stored procedure by the given name either from the cached version or
     * by enquiring the database.
     * @param meta the database meta data
     * @param catalog the catalog name or null
     * @param schema the schema name or null
     * @param procedure the procedure name
     * @return metadata about the named procedure or null
     * @throws SQLException when metadata query goes wrong
     */
    public StoredProcedure getStoredProcedure(DatabaseMetaData meta, DBIdentifier catalog, DBIdentifier schema,
                                              String procedure) throws SQLException {
<span class="nc bnc" id="L4955" title="All 2 branches missed.">        if (_procs.containsKey(procedure)) {</span>
<span class="nc" id="L4956">            return _procs.get(procedure);</span>
        }
<span class="nc" id="L4958">        ResultSet rs = meta.getProcedureColumns(</span>
<span class="nc" id="L4959">                getCatalogNameForMetadata(catalog),</span>
<span class="nc" id="L4960">                getSchemaNameForMetadata(schema),</span>
                procedure,
                null);
<span class="nc" id="L4963">        StoredProcedure sp = null;</span>
<span class="nc bnc" id="L4964" title="All 2 branches missed.">        if (rs.next()) {</span>
<span class="nc" id="L4965">            sp = new StoredProcedure(rs);</span>
        } else {
<span class="nc" id="L4967">            ResultSet rsExist = meta.getProcedures(</span>
<span class="nc" id="L4968">                    getCatalogNameForMetadata(catalog),</span>
<span class="nc" id="L4969">                    getSchemaNameForMetadata(schema),</span>
                    procedure);
<span class="nc bnc" id="L4971" title="All 2 branches missed.">            if (rsExist.next()) {</span>
<span class="nc" id="L4972">                sp = new StoredProcedure((String) null);</span>
<span class="nc" id="L4973">                sp.setCatalog(catalog);</span>
<span class="nc" id="L4974">                sp.setSchema(schema);</span>
<span class="nc" id="L4975">                sp.setName(procedure);</span>
            }
        }
<span class="nc" id="L4978">        _procs.put(procedure, sp);</span>
<span class="nc" id="L4979">        return sp;</span>
    }

    ///////////////////////////////
    // Configurable implementation
    ///////////////////////////////

    @Override
    public void setConfiguration(Configuration conf) {
<span class="nc" id="L4988">        this.conf = (JDBCConfiguration) conf;</span>
<span class="nc" id="L4989">        this.log = this.conf.getLog(JDBCConfiguration.LOG_JDBC);</span>

        // Create the naming utility
<span class="nc" id="L4992">        namingUtil = this.conf.getIdentifierUtilInstance();</span>
<span class="nc" id="L4993">        namingUtil.setIdentifierConfiguration(this);</span>
<span class="nc" id="L4994">        configureNamingRules();</span>

        // warn about unsupported dicts
<span class="nc bnc" id="L4997" title="All 4 branches missed.">        if (log.isWarnEnabled() &amp;&amp; !isSupported())</span>
<span class="nc" id="L4998">            log.warn(_loc.get(&quot;dict-not-supported&quot;, getClass()));</span>
<span class="nc" id="L4999">    }</span>

    private boolean isSupported() {
        // if this is a custom dict, traverse to whatever openjpa dict it
        // extends
<span class="nc" id="L5004">        Class c = getClass();</span>
<span class="nc bnc" id="L5005" title="All 2 branches missed.">        while (!c.getName().startsWith(&quot;org.apache.openjpa.&quot;))</span>
<span class="nc" id="L5006">            c = c.getSuperclass();</span>

        // the generic dbdictionary is not considered a supported dict; all
        // other concrete dictionaries are
<span class="nc bnc" id="L5010" title="All 2 branches missed.">        if (c == DBDictionary.class)</span>
<span class="nc" id="L5011">            return false;</span>
<span class="nc" id="L5012">        return true;</span>
    }

    @Override
    public void startConfiguration() {
<span class="nc" id="L5017">    }</span>

    @Override
    public void endConfiguration() {
        // initialize the set of reserved SQL92 words from resource
<span class="nc" id="L5022">        InputStream in = DBDictionary.class.getResourceAsStream</span>
<span class="nc" id="L5023">            (&quot;sql-keywords.rsrc&quot;);</span>
        try {
<span class="nc" id="L5025">            String keywords = new BufferedReader(new InputStreamReader(in)).</span>
<span class="nc" id="L5026">                readLine();</span>
<span class="nc" id="L5027">            reservedWordSet.addAll(Arrays.asList(StringUtil.split</span>
<span class="nc" id="L5028">                (keywords, &quot;,&quot;, 0)));</span>
<span class="nc" id="L5029">        } catch (IOException ioe) {</span>
<span class="nc" id="L5030">            throw new GeneralException(ioe);</span>
        } finally {
<span class="nc" id="L5032">            try { in.close(); } catch (IOException e) {}</span>
        }

        // add additional reserved words set by user
<span class="nc bnc" id="L5036" title="All 2 branches missed.">        if (reservedWords != null)</span>
<span class="nc" id="L5037">            reservedWordSet.addAll(Arrays.asList(StringUtil.split(reservedWords.toUpperCase(Locale.ENGLISH), &quot;,&quot;, 0)));</span>

        // add system schemas set by user
<span class="nc bnc" id="L5040" title="All 2 branches missed.">        if (systemSchemas != null)</span>
<span class="nc" id="L5041">            systemSchemaSet.addAll(Arrays.asList(StringUtil.split(systemSchemas.toUpperCase(Locale.ENGLISH), &quot;,&quot;, 0)));</span>

        // add system tables set by user
<span class="nc bnc" id="L5044" title="All 2 branches missed.">        if (systemTables != null)</span>
<span class="nc" id="L5045">            systemTableSet.addAll(Arrays.asList(StringUtil.split(systemTables.toUpperCase(Locale.ENGLISH), &quot;,&quot;, 0)));</span>

        // add fixed size type names set by the user
<span class="nc bnc" id="L5048" title="All 2 branches missed.">        if (fixedSizeTypeNames != null)</span>
<span class="nc" id="L5049">            fixedSizeTypeNameSet.addAll(Arrays.asList(StringUtil.split(fixedSizeTypeNames.toUpperCase(Locale.ENGLISH), &quot;,&quot;, 0)));</span>

        // if user has unset sequence sql, null it out so we know sequences
        // aren't supported
<span class="nc" id="L5053">        nextSequenceQuery = StringUtil.trimToNull(nextSequenceQuery);</span>

<span class="nc bnc" id="L5055" title="All 2 branches missed.">        if (selectWords != null)</span>
<span class="nc" id="L5056">            selectWordSet.addAll(Arrays.asList(StringUtil.split(selectWords.toUpperCase(Locale.ENGLISH), &quot;,&quot;, 0)));</span>

        // initialize the error codes
<span class="nc" id="L5059">        SQLErrorCodeReader codeReader = new SQLErrorCodeReader();</span>
<span class="nc" id="L5060">        String rsrc = &quot;sql-error-state-codes.xml&quot;;</span>
        // We'll allow sub-classes to override the stream for custom err codes
        // @edu.umd.cs.findbugs.annotations.SuppressWarnings(value=&quot;UI_INHERITANCE_UNSAFE_GETRESOURCE&quot;)
<span class="nc" id="L5063">        InputStream stream = getClass().getResourceAsStream(rsrc);</span>
<span class="nc" id="L5064">        String dictionaryClassName = getClass().getName();</span>
<span class="nc bnc" id="L5065" title="All 2 branches missed.">        if (stream == null) { // User supplied dictionary but no error codes xml</span>
            // use default
<span class="nc" id="L5067">            stream = DBDictionary.class.getResourceAsStream(rsrc);</span>
<span class="nc" id="L5068">            dictionaryClassName = getClass().getSuperclass().getName();</span>
        }
<span class="nc" id="L5070">        codeReader.parse(stream, dictionaryClassName, this);</span>
<span class="nc" id="L5071">    }</span>

    public void addErrorCode(int errorType, String errorCode) {
<span class="nc bnc" id="L5074" title="All 4 branches missed.">        if (errorCode == null || errorCode.trim().length() == 0)</span>
<span class="nc" id="L5075">            return;</span>
<span class="nc" id="L5076">        Set&lt;String&gt; codes = sqlStateCodes.get(errorType);</span>
<span class="nc bnc" id="L5077" title="All 2 branches missed.">        if (codes == null) {</span>
<span class="nc" id="L5078">            codes = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5079">            codes.add(errorCode.trim());</span>
<span class="nc" id="L5080">            sqlStateCodes.put(errorType, codes);</span>
        } else {
<span class="nc" id="L5082">            codes.add(errorCode.trim());</span>
        }
<span class="nc" id="L5084">    }</span>

    /**
     * FIXME - OPENJPA-957 - lockTimeout is a server-side function and
     * shouldn't be using client-side setQueryTimeout for lock timeouts.
     *
     * This method is to provide override for non-JDBC or JDBC-like
     * implementation of setting query and lock timeouts.
     *
     * @param stmnt
     * @param fetch - optional lock and query timeouts in milliseconds
     * @param forUpdate - true if we should also try setting a lock timeout
     * @throws SQLException
     */
    public void setTimeouts(PreparedStatement stmnt,
        JDBCFetchConfiguration fetch, boolean forUpdate) throws SQLException {
<span class="nc bnc" id="L5100" title="All 2 branches missed.">        if (supportsQueryTimeout) {</span>
<span class="nc" id="L5101">            int timeout = fetch.getQueryTimeout();</span>
<span class="nc bnc" id="L5102" title="All 2 branches missed.">            if (forUpdate) {</span>
                // if this is a locking select and the lock timeout is greater
                // than the configured query timeout, use the lock timeout
<span class="nc" id="L5105">                timeout = Math.max(fetch.getQueryTimeout(),</span>
<span class="nc" id="L5106">                    fetch.getLockTimeout());</span>
            }
<span class="nc" id="L5108">            setQueryTimeout(stmnt, timeout);</span>
        }
<span class="nc" id="L5110">    }</span>

    /**
     * FIXME - OPENJPA-957 - lockTimeout is a server-side function and
     * shouldn't be using client-side setQueryTimeout for lock timeouts.
     *
     * This method is to provide override for non-JDBC or JDBC-like
     * implementation of setting query and lock timeouts.
     *
     * @param stmnt
     * @param conf - optional lock and query timeouts in milliseconds
     * @param forUpdate - true if we should also try setting a lock timeout
     * @throws SQLException
     */
    public void setTimeouts(PreparedStatement stmnt, JDBCConfiguration conf,
        boolean forUpdate) throws SQLException {
<span class="nc bnc" id="L5126" title="All 2 branches missed.">        if (supportsQueryTimeout) {</span>
<span class="nc" id="L5127">            int timeout = conf.getQueryTimeout();</span>
<span class="nc bnc" id="L5128" title="All 2 branches missed.">            if (forUpdate) {</span>
                // if this is a locking select and the lock timeout is greater
                // than the configured query timeout, use the lock timeout
<span class="nc" id="L5131">                timeout = Math.max(conf.getQueryTimeout(),</span>
<span class="nc" id="L5132">                    conf.getLockTimeout());</span>
            }
<span class="nc" id="L5134">            setQueryTimeout(stmnt, timeout);</span>
        }
<span class="nc" id="L5136">    }</span>

    /**
     * Provides the default validation handling of setting a query timeout.
     * @param stmnt
     * @param timeout in milliseconds
     * @throws SQLException
     */
    public void setQueryTimeout(PreparedStatement stmnt, int timeout)
        throws SQLException {
<span class="nc bnc" id="L5146" title="All 2 branches missed.">        if (supportsQueryTimeout) {</span>
<span class="nc bnc" id="L5147" title="All 2 branches missed.">            if (timeout == -1) {</span>
                // special OpenJPA allowed case denoting no timeout
<span class="nc" id="L5149">                timeout = 0;</span>
<span class="nc bnc" id="L5150" title="All 2 branches missed.">            } else if (timeout &lt; 0) {</span>
<span class="nc bnc" id="L5151" title="All 2 branches missed.">                if (log.isWarnEnabled())</span>
<span class="nc" id="L5152">                    log.warn(_loc.get(&quot;invalid-timeout&quot;, Integer.valueOf(timeout)));</span>
<span class="nc" id="L5153">                return;</span>
<span class="nc bnc" id="L5154" title="All 4 branches missed.">            } else if (timeout &gt; 0 &amp;&amp; timeout &lt; 1000) {</span>
                // round up to 1 sec
<span class="nc" id="L5156">                timeout = 1000;</span>
<span class="nc bnc" id="L5157" title="All 2 branches missed.">                if (log.isWarnEnabled())</span>
<span class="nc" id="L5158">                    log.warn(_loc.get(&quot;millis-query-timeout&quot;));</span>
            }
<span class="nc" id="L5160">            setStatementQueryTimeout(stmnt, timeout);</span>
        }
<span class="nc" id="L5162">    }</span>

    /**
     * Allow subclasses to provide DB unique override implementations of
     * setting query timeouts, while preserving the default timeout logic
     * in the public setQueryTimeout method.
     * @param stmnt
     * @param timeout in milliseconds
     * @throws SQLException
     */
    protected void setStatementQueryTimeout(PreparedStatement stmnt,
        int timeout) throws SQLException {
        // JDBC uses seconds, so we'll do a simple round-down conversion here
<span class="nc" id="L5175">        stmnt.setQueryTimeout(timeout / 1000);</span>
<span class="nc" id="L5176">    }</span>

    //////////////////////////////////////
    // ConnectionDecorator implementation
    //////////////////////////////////////

    /**
     * Decorate the given connection if needed. Some databases require special
     * handling for JDBC bugs. This implementation issues any
     * {@link #initializationSQL} that has been set for the dictionary but
     * does not decorate the connection.
     */
    @Override
    public Connection decorate(Connection conn)
        throws SQLException {
<span class="nc bnc" id="L5191" title="All 2 branches missed.">        if (!connected)</span>
<span class="nc" id="L5192">            connectedConfiguration(conn);</span>
<span class="nc bnc" id="L5193" title="All 2 branches missed.">        if (!StringUtil.isEmpty(initializationSQL)) {</span>
<span class="nc" id="L5194">            PreparedStatement stmnt = null;</span>
            try {
<span class="nc" id="L5196">                stmnt = conn.prepareStatement(initializationSQL);</span>
<span class="nc" id="L5197">                stmnt.execute();</span>
<span class="nc" id="L5198">            } catch (Exception e) {</span>
<span class="nc bnc" id="L5199" title="All 2 branches missed.">                if (log.isTraceEnabled())</span>
<span class="nc" id="L5200">                    log.trace(e.toString(), e);</span>
            } finally {
<span class="nc bnc" id="L5202" title="All 2 branches missed.">                if (stmnt != null)</span>
                    try {
<span class="nc" id="L5204">                        stmnt.close();</span>
<span class="nc" id="L5205">                    } catch (SQLException se) {</span>
<span class="nc" id="L5206">                    }</span>
            }
        }
<span class="nc" id="L5209">        return conn;</span>
    }

    /**
     * Implementation of the
     * {@link LoggingConnectionDecorator.SQLWarningHandler} interface
     * that allows customization of the actions to perform when a
     * {@link SQLWarning} occurs at any point on a {@link Connection},
     * {@link Statement}, or {@link ResultSet}. This method may
     * be used determine those warnings the application wants to
     * consider critical failures, and throw the warning in those
     * cases. By default, this method does nothing.
     *
     * @see LoggingConnectionDecorator#setWarningAction
     * @see LoggingConnectionDecorator#setWarningHandler
     */
    @Override
    public void handleWarning(SQLWarning warning)
        throws SQLException {
<span class="nc" id="L5228">    }</span>

    /**
     * Return a new exception that wraps &lt;code&gt;causes&lt;/code&gt;.
     * However, the details of exactly what type of exception is returned can
     * be determined by the implementation. This may take into account
     * DB-specific exception information in &lt;code&gt;causes&lt;/code&gt;.
     */
    public OpenJPAException newStoreException(String msg, SQLException[] causes, Object failed) {
<span class="nc bnc" id="L5237" title="All 4 branches missed.">        if (causes != null &amp;&amp; causes.length &gt; 0) {</span>
<span class="nc" id="L5238">            OpenJPAException ret = narrow(msg, causes[0], failed);</span>
<span class="nc" id="L5239">            ret.setFailedObject(failed).setNestedThrowables(causes);</span>
<span class="nc" id="L5240">            return ret;</span>
        }
<span class="nc" id="L5242">        return new StoreException(msg).setFailedObject(failed).</span>
<span class="nc" id="L5243">            setNestedThrowables(causes);</span>
    }

    /**
     * Gets the category of StoreException by matching the given SQLException's
     * error state code to the list of error codes supplied by the dictionary.
     *
     * @return a StoreException of {@link ExceptionInfo#GENERAL general} category
     * if the given SQL Exception can not be further categorized.
     *
     * @see #matchErrorState(Map, SQLException)
     */
    OpenJPAException narrow(String msg, SQLException ex, Object failed) {
<span class="nc" id="L5256">        int errorType = matchErrorState(sqlStateCodes, ex);</span>
        StoreException storeEx;
<span class="nc bnc" id="L5258" title="All 7 branches missed.">        switch (errorType) {</span>
        case StoreException.LOCK:
<span class="nc" id="L5260">            storeEx = new LockException(failed);</span>
<span class="nc" id="L5261">            break;</span>
        case StoreException.OBJECT_EXISTS:
<span class="nc" id="L5263">            storeEx = new ObjectExistsException(msg);</span>
<span class="nc" id="L5264">            break;</span>
        case StoreException.OBJECT_NOT_FOUND:
<span class="nc" id="L5266">            storeEx = new ObjectNotFoundException(failed);</span>
<span class="nc" id="L5267">            break;</span>
        case StoreException.OPTIMISTIC:
<span class="nc" id="L5269">            storeEx = new OptimisticException(failed);</span>
<span class="nc" id="L5270">            break;</span>
        case StoreException.REFERENTIAL_INTEGRITY:
<span class="nc" id="L5272">            storeEx = new ReferentialIntegrityException(msg);</span>
<span class="nc" id="L5273">            break;</span>
        case StoreException.QUERY:
<span class="nc" id="L5275">            storeEx = new QueryException(msg);</span>
<span class="nc" id="L5276">            break;</span>
        default:
<span class="nc" id="L5278">            storeEx = new StoreException(msg);</span>
        }
<span class="nc" id="L5280">        storeEx.setFatal(isFatalException(errorType, ex));</span>
<span class="nc" id="L5281">        return storeEx;</span>
    }

    /**
     * Determine the more appropriate type of store exception by matching the SQL Error State of the
     * the given SQLException to the given Error States categorized by error types.
     * Dictionary subclass can override this method and extract
     * SQLException data to figure out if the exception is recoverable.
     *
     * @param errorStates classification of SQL error states by their specific nature. The keys of the
     * map represent one of the constants defined in {@link StoreException}. The value corresponding to
     * a key represent the set of SQL Error States representing specific category of database error.
     * This supplied map is sourced from &lt;code&gt;sql-error-state-codes.xml&lt;/xml&gt; and filtered the
     * error states for the current database.
     *
     * @param ex original SQL Exception as raised by the database driver.
     *
     * @return A constant indicating the category of error as defined in {@link StoreException}.
     */
    protected int matchErrorState(Map&lt;Integer,Set&lt;String&gt;&gt; errorStates, SQLException ex) {
<span class="nc" id="L5301">        String errorState = ex.getSQLState();</span>
<span class="nc bnc" id="L5302" title="All 2 branches missed.">        for (Map.Entry&lt;Integer,Set&lt;String&gt;&gt; states : errorStates.entrySet()) {</span>
<span class="nc bnc" id="L5303" title="All 2 branches missed.">            if (states.getValue().contains(errorState))</span>
<span class="nc" id="L5304">                return states.getKey();</span>
<span class="nc" id="L5305">        }</span>
<span class="nc" id="L5306">        return ExceptionInfo.GENERAL;</span>
    }

    /**
     * Determine if the given SQL Exception is fatal or recoverable (such as a timeout).
     * This implementation always returns true (i.e. all exceptions are fatal).
     * The current dictionary implementation can overwrite this method to mark certain
     * exception conditions as recoverable error.

     * @param subtype A constant indicating the category of error as defined in {@link StoreException}.
     * @param ex original SQL Exception as raised by the database driver.
     *
     * @return false if the error is fatal.
     */
    public boolean isFatalException(int subtype, SQLException ex) {
<span class="nc" id="L5321">        return true;</span>
    }

    /**
     * Closes the specified {@link DataSource} and releases any
     * resources associated with it.
     *
     * @param dataSource the DataSource to close
     */
    public void closeDataSource(DataSource dataSource) {
<span class="nc" id="L5331">        DataSourceFactory.closeDataSource(dataSource);</span>
<span class="nc" id="L5332">    }</span>

    /**
     * Used by some mappings to represent data that has already been
     * serialized so that we don't have to serialize multiple times.
     */
    public static class SerializedData {

        public final byte[] bytes;

<span class="nc" id="L5342">        public SerializedData(byte[] bytes) {</span>
<span class="nc" id="L5343">            this.bytes = bytes;</span>
<span class="nc" id="L5344">        }</span>
    }

    /**
     * Return version column name
     * @param column
     * @param tableAlias : this is needed for platform specific version column
     */
    public String getVersionColumn(Column column, String tableAlias) {
<span class="nc" id="L5353">        return getVersionColumn(column, DBIdentifier.newTable(tableAlias)).toString();</span>
    }

    public DBIdentifier getVersionColumn(Column column, DBIdentifier tableAlias) {
<span class="nc" id="L5357">        return column.getIdentifier();</span>
    }

    public void insertBlobForStreamingLoad(Row row, Column col,
        JDBCStore store, Object ob, Select sel) throws SQLException {
<span class="nc bnc" id="L5362" title="All 2 branches missed.">        if (ob != null) {</span>
<span class="nc" id="L5363">            row.setBinaryStream(col,</span>
                new ByteArrayInputStream(new byte[0]), 0);
        } else {
<span class="nc" id="L5366">            row.setNull(col);</span>
        }
<span class="nc" id="L5368">    }</span>

    public void insertClobForStreamingLoad(Row row, Column col, Object ob)
    throws SQLException {
<span class="nc bnc" id="L5372" title="All 2 branches missed.">        if (ob != null) {</span>
<span class="nc" id="L5373">        row.setCharacterStream(col,</span>
                new CharArrayReader(new char[0]), 0);
        } else {
<span class="nc" id="L5376">            row.setNull(col);</span>
        }
<span class="nc" id="L5378">    }</span>

    public void updateBlob(Select sel, JDBCStore store, InputStream is)
        throws SQLException {
<span class="nc" id="L5382">        SQLBuffer sql = sel.toSelect(true, store.getFetchConfiguration());</span>
<span class="nc" id="L5383">        ResultSet res = null;</span>
<span class="nc" id="L5384">        Connection conn = store.getConnection();</span>
<span class="nc" id="L5385">        PreparedStatement stmnt = null;</span>
        try {
<span class="nc" id="L5387">            stmnt = sql.prepareStatement(conn, store.getFetchConfiguration(),</span>
                ResultSet.TYPE_SCROLL_SENSITIVE,
                ResultSet.CONCUR_UPDATABLE);
<span class="nc" id="L5390">            setTimeouts(stmnt, store.getFetchConfiguration(), true);</span>
<span class="nc" id="L5391">            res = stmnt.executeQuery();</span>
<span class="nc bnc" id="L5392" title="All 2 branches missed.">            if (!res.next()) {</span>
<span class="nc" id="L5393">                throw new InternalException(_loc.get(&quot;stream-exception&quot;));</span>
            }
<span class="nc" id="L5395">            Blob blob = res.getBlob(1);</span>
<span class="nc" id="L5396">            OutputStream os = blob.setBinaryStream(1);</span>
<span class="nc" id="L5397">            copy(is, os);</span>
<span class="nc" id="L5398">            os.close();</span>
<span class="nc" id="L5399">            res.updateBlob(1, blob);</span>
<span class="nc" id="L5400">            res.updateRow();</span>

<span class="nc" id="L5402">        } catch (IOException ioe) {</span>
<span class="nc" id="L5403">            throw new StoreException(ioe);</span>
        } finally {
<span class="nc bnc" id="L5405" title="All 2 branches missed.">            if (res != null)</span>
<span class="nc" id="L5406">                try { res.close (); } catch (SQLException e) {}</span>
<span class="nc bnc" id="L5407" title="All 2 branches missed.">            if (stmnt != null)</span>
<span class="nc" id="L5408">                try { stmnt.close (); } catch (SQLException e) {}</span>
<span class="nc bnc" id="L5409" title="All 2 branches missed.">            if (conn != null)</span>
<span class="nc" id="L5410">                try { conn.close (); } catch (SQLException e) {}</span>
        }
<span class="nc" id="L5412">    }</span>

    public void updateClob(Select sel, JDBCStore store, Reader reader)
        throws SQLException {
<span class="nc" id="L5416">        SQLBuffer sql = sel.toSelect(true, store.getFetchConfiguration());</span>
<span class="nc" id="L5417">        ResultSet res = null;</span>
<span class="nc" id="L5418">        Connection conn = store.getConnection();</span>
<span class="nc" id="L5419">        PreparedStatement stmnt = null;</span>
        try {
<span class="nc" id="L5421">            stmnt = sql.prepareStatement(conn, store.getFetchConfiguration(),</span>
                ResultSet.TYPE_SCROLL_SENSITIVE,
                ResultSet.CONCUR_UPDATABLE);
<span class="nc" id="L5424">            setTimeouts(stmnt, store.getFetchConfiguration(), true);</span>
<span class="nc" id="L5425">            res = stmnt.executeQuery();</span>
<span class="nc bnc" id="L5426" title="All 2 branches missed.">            if (!res.next()) {</span>
<span class="nc" id="L5427">                throw new InternalException(_loc.get(&quot;stream-exception&quot;));</span>
            }
<span class="nc" id="L5429">            Clob clob = res.getClob(1);</span>
<span class="nc bnc" id="L5430" title="All 2 branches missed.">            if (clob != null) {</span>
<span class="nc" id="L5431">                Writer writer = clob.setCharacterStream(1);</span>
<span class="nc" id="L5432">                copy(reader, writer);</span>
<span class="nc" id="L5433">                writer.close();</span>
<span class="nc" id="L5434">                res.updateClob(1, clob);</span>
<span class="nc" id="L5435">                res.updateRow();</span>
            }

<span class="nc" id="L5438">        } catch (IOException ioe) {</span>
<span class="nc" id="L5439">            throw new StoreException(ioe);</span>
        } finally {
<span class="nc bnc" id="L5441" title="All 2 branches missed.">            if (res != null)</span>
<span class="nc" id="L5442">                try { res.close (); } catch (SQLException e) {}</span>
<span class="nc bnc" id="L5443" title="All 2 branches missed.">            if (stmnt != null)</span>
<span class="nc" id="L5444">                try { stmnt.close (); } catch (SQLException e) {}</span>
<span class="nc bnc" id="L5445" title="All 2 branches missed.">            if (conn != null)</span>
<span class="nc" id="L5446">                try { conn.close (); } catch (SQLException e) {}</span>
        }
<span class="nc" id="L5448">    }</span>

    protected long copy(InputStream in, OutputStream out) throws IOException {
<span class="nc" id="L5451">        byte[] copyBuffer = new byte[blobBufferSize];</span>
<span class="nc" id="L5452">        long bytesCopied = 0;</span>
<span class="nc" id="L5453">        int read = -1;</span>

<span class="nc bnc" id="L5455" title="All 2 branches missed.">        while ((read = in.read(copyBuffer, 0, copyBuffer.length)) != -1) {</span>
<span class="nc" id="L5456">            out.write(copyBuffer, 0, read);</span>
<span class="nc" id="L5457">            bytesCopied += read;</span>
        }
<span class="nc" id="L5459">        return bytesCopied;</span>
    }

    protected long copy(Reader reader, Writer writer) throws IOException {
<span class="nc" id="L5463">        char[] copyBuffer = new char[clobBufferSize];</span>
<span class="nc" id="L5464">        long bytesCopied = 0;</span>
<span class="nc" id="L5465">        int read = -1;</span>

<span class="nc bnc" id="L5467" title="All 2 branches missed.">        while ((read = reader.read(copyBuffer, 0, copyBuffer.length)) != -1) {</span>
<span class="nc" id="L5468">            writer.write(copyBuffer, 0, read);</span>
<span class="nc" id="L5469">            bytesCopied += read;</span>
        }

<span class="nc" id="L5472">        return bytesCopied;</span>
    }

    /**
     * Attach CAST to the current function if necessary
     *
     * @param val operand value
     * @parma func the sql function statement
     * @return a String with the correct CAST function syntax
     */
    public String getCastFunction(Val val, String func) {
<span class="nc" id="L5483">        return func;</span>
    }

    /**
     * Return the correct CAST function syntax.  This should be overriden by subclasses
     * that need access to the Column information.
     *
     * @param val operand of cast
     * @param func original string
     * @param col database column
     * @return a String with the correct CAST function syntax
     */
    public String getCastFunction(Val val, String func, Column col) {
<span class="nc" id="L5496">        return getCastFunction (val, func);</span>
    }

    /**
     * Create an index if necessary for some database tables
     * @deprecated
     */
    @Deprecated
    public void createIndexIfNecessary(Schema schema, String table,
            Column pkColumn) {
<span class="nc" id="L5506">    }</span>

    public void createIndexIfNecessary(Schema schema, DBIdentifier table,
        Column pkColumn) {
<span class="nc" id="L5510">    }</span>

    /**
     * Return the batchLimit
     */
    public int getBatchLimit(){
<span class="nc" id="L5516">        return batchLimit;</span>
    }

    /**
     * Set the batchLimit value
     */
    public void setBatchLimit(int limit){
<span class="nc" id="L5523">        batchLimit = limit;</span>
<span class="nc" id="L5524">    }</span>

    /**
     * Validate the batch process. In some cases, we can't batch the statements
     * due to some restrictions. For example, if the GeneratedType=IDENTITY,
     * we have to disable the batch process because we need to get the ID value
     * right away for the in-memory entity to use.
     */
    public boolean validateBatchProcess(RowImpl row, Column[] autoAssign,
            OpenJPAStateManager  sm, ClassMapping cmd ) {
<span class="nc" id="L5534">        boolean disableBatch = false;</span>
<span class="nc bnc" id="L5535" title="All 2 branches missed.">        if (getBatchLimit()== 0) return false;</span>
<span class="nc bnc" id="L5536" title="All 4 branches missed.">        if (autoAssign != null &amp;&amp; sm != null) {</span>
<span class="nc" id="L5537">            FieldMetaData[] fmd = cmd.getPrimaryKeyFields();</span>
<span class="nc" id="L5538">            int i = 0;</span>
<span class="nc bnc" id="L5539" title="All 4 branches missed.">            while (!disableBatch &amp;&amp; i &lt; fmd.length) {</span>
<span class="nc bnc" id="L5540" title="All 2 branches missed.">                if (fmd[i].getValueStrategy() == ValueStrategies.AUTOASSIGN)</span>
<span class="nc" id="L5541">                    disableBatch = true;</span>
<span class="nc" id="L5542">                i++;</span>
            }
        }
        // go to each Dictionary to validate the batch capability
<span class="nc bnc" id="L5546" title="All 2 branches missed.">        if (!disableBatch)</span>
<span class="nc" id="L5547">            disableBatch = validateDBSpecificBatchProcess(disableBatch, row,</span>
                autoAssign, sm, cmd);
<span class="nc" id="L5549">        return disableBatch;</span>
    }

    /**
     * Allow each Dictionary to validate its own batch process.
     */
    public boolean validateDBSpecificBatchProcess (boolean disableBatch,
            RowImpl row, Column[] autoAssign,
            OpenJPAStateManager  sm, ClassMapping cmd ) {
<span class="nc" id="L5558">        return disableBatch;</span>
    }

    /**
     * This method is to provide override for non-JDBC or JDBC-like
     * implementation of executing query.
     */
    protected ResultSet executeQuery(Connection conn, PreparedStatement stmnt,
            String sql
        ) throws SQLException {
<span class="nc" id="L5568">        return stmnt.executeQuery();</span>
    }

    /**
     * This method is to provide override for non-JDBC or JDBC-like
     * implementation of preparing statement.
     */
    protected PreparedStatement prepareStatement(Connection conn, String sql)
        throws SQLException {
<span class="nc" id="L5577">        return conn.prepareStatement(sql);</span>
    }

    /**
     * This method is to provide override for non-JDBC or JDBC-like
     * implementation of getting sequence from the result set.
     */
    protected Sequence[] getSequence(ResultSet rs) throws SQLException {
<span class="nc" id="L5585">        List seqList = new ArrayList();</span>
<span class="nc bnc" id="L5586" title="All 4 branches missed.">        while (rs != null &amp;&amp; rs.next())</span>
<span class="nc" id="L5587">            seqList.add(newSequence(rs));</span>
<span class="nc" id="L5588">        return (Sequence[]) seqList.toArray(new Sequence[seqList.size()]);</span>
    }

    /**
     * This method is to provide override for non-JDBC or JDBC-like
     * implementation of getting key from the result set.
     */
    protected Object getKey (ResultSet rs, Column col) throws SQLException {
<span class="nc bnc" id="L5596" title="All 2 branches missed.">        if (!rs.next())</span>
<span class="nc" id="L5597">            throw new StoreException(_loc.get(&quot;no-genkey&quot;));</span>
<span class="nc" id="L5598">        Object key = rs.getObject(1);</span>
<span class="nc bnc" id="L5599" title="All 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L5600">            log.warn(_loc.get(&quot;invalid-genkey&quot;, col));</span>
<span class="nc" id="L5601">        return key;</span>
    }

    /**
     * This method is to provide override for non-JDBC or JDBC-like
     * implementation of calculating value.
     */
    protected void calculateValue(Val val, Select sel, ExpContext ctx,
        ExpState state, Path path, ExpState pathState) {
<span class="nc" id="L5610">        val.calculateValue(sel, ctx, state, (Val) path, pathState);</span>
<span class="nc" id="L5611">    }</span>

    /**
     * Determine whether the provided &lt;code&gt;sql&lt;/code&gt; may be treated as a
     * select statement on this database.
     *
     * @param sql   A sql statement.
     *
     * @return true if &lt;code&gt;sql&lt;/code&gt; represents a select statement.
     */
    public boolean isSelect(String sql) {
<span class="nc" id="L5622">        Iterator i = selectWordSet.iterator();</span>
        String cur;
<span class="nc bnc" id="L5624" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L5625">            cur = (String) i.next();</span>
<span class="nc bnc" id="L5626" title="All 2 branches missed.">            if (sql.length() &gt;= cur.length()</span>
<span class="nc bnc" id="L5627" title="All 2 branches missed.">                    &amp;&amp; sql.substring(0, cur.length()).equalsIgnoreCase(cur)) {</span>
<span class="nc" id="L5628">                return true;</span>
            }
        }
<span class="nc" id="L5631">        return false;</span>
    }

    public boolean needsToCreateIndex(Index idx, Table table, Unique[] uniques) {
<span class="nc" id="L5635">        return needsToCreateIndex(idx, table);</span>
    }

    public boolean needsToCreateIndex(Index idx, Table table) {
<span class="nc" id="L5639">        return true;</span>
    }

    /**
     * Return batched statements update success count
     * @param ps A PreparedStatement
     * @return return update count
     */
    public int getBatchUpdateCount(PreparedStatement ps) throws SQLException {
<span class="nc" id="L5648">        return 0;</span>
    }

    public boolean getTrimSchemaName() {
<span class="nc" id="L5652">        return trimSchemaName;</span>
    }

    public void setTrimSchemaName(boolean trimSchemaName) {
<span class="nc" id="L5656">        this.trimSchemaName = trimSchemaName;</span>
<span class="nc" id="L5657">    }</span>

    public void deleteStream(JDBCStore store, Select sel) throws SQLException {
        // Do nothing
<span class="nc" id="L5661">    }</span>

    /**
     * Validate that the given name is not longer than given maximum length.
     * If the given name is indeed longer then raises a UserException with the
     * given message key otherwise returns the same name.
     */
    final String checkNameLength(String name, int length, String msgKey) {
<span class="nc bnc" id="L5669" title="All 2 branches missed.">        if (name.length() &gt; length) {</span>
<span class="nc" id="L5670">            throw new UserException(_loc.get(msgKey, name, name.length(), length));</span>
        }
<span class="nc" id="L5672">        return name;</span>
    }

    /**
     * Validate that the given name is not longer than given maximum length. Uses the unqualified name
     * from the supplied {@link DBIdentifier} by default..
     *
     * @param identifier The database identifier to check.
     * @param length    Max length for this type of identifier
     * @param msgKey    message identifier for the exception.
     *
     * @throws {@link UserException} with the given message key if the given name is indeed longer.
     * @return the same name.
     */
    final String checkNameLength(DBIdentifier identifier, int length, String msgKey) {
<span class="nc" id="L5687">        return checkNameLength(identifier, length, msgKey, false);</span>
    }

    /**
     * Validate that the given name is not longer than given maximum length. Conditionally uses the unqualified name
     * from the supplied {@link DBIdentifier}.
     *
     * @param identifier The database identifier to check.
     * @param length    Max length for this type of identifier
     * @param msgKey    message identifier for the exception.
     * @param qualified If true the qualified name of the DBIdentifier will be used.
     *
     * @throws {@link UserException} with the given message key if the given name is indeed longer.
     * @return the same name.
     */
    final String checkNameLength(DBIdentifier identifier, int length, String msgKey, boolean qualified) {
        // always return the input name,
<span class="nc" id="L5704">        String name = toDBName(identifier);</span>
<span class="nc bnc" id="L5705" title="All 2 branches missed.">        String compareName = qualified ? name : toDBName(identifier.getUnqualifiedName());</span>

<span class="nc bnc" id="L5707" title="All 2 branches missed.">        if (compareName.length() &gt; length) {</span>
<span class="nc" id="L5708">            throw new UserException(_loc.get(msgKey, name, name.length(), length));</span>
        }
<span class="nc" id="L5710">        return name;</span>
    }

    protected void setDelimitedCase(DatabaseMetaData metaData) {
        try {
<span class="nc bnc" id="L5715" title="All 2 branches missed.">            if (metaData.storesMixedCaseQuotedIdentifiers()) {</span>
<span class="nc" id="L5716">                delimitedCase = SCHEMA_CASE_PRESERVE;</span>
            }
<span class="nc bnc" id="L5718" title="All 2 branches missed.">            else if (metaData.storesUpperCaseQuotedIdentifiers()) {</span>
<span class="nc" id="L5719">                delimitedCase = SCHEMA_CASE_UPPER;</span>
            }
<span class="nc bnc" id="L5721" title="All 2 branches missed.">            else if (metaData.storesLowerCaseQuotedIdentifiers()) {</span>
<span class="nc" id="L5722">                delimitedCase = SCHEMA_CASE_LOWER;</span>
            }
<span class="nc" id="L5724">        } catch (SQLException e) {</span>
<span class="nc" id="L5725">            getLog().warn(&quot;cannot-determine-identifier-case&quot;);</span>
<span class="nc bnc" id="L5726" title="All 2 branches missed.">            if (getLog().isTraceEnabled()) {</span>
<span class="nc" id="L5727">                getLog().trace(e.toString(), e);</span>
            }
<span class="nc" id="L5729">        }</span>
<span class="nc" id="L5730">    }</span>

    /**
     * @return the supportsDelimitedIds
     */
    @Override
    public boolean getSupportsDelimitedIdentifiers() {
<span class="nc bnc" id="L5737" title="All 2 branches missed.">        return (supportsDelimitedIdentifiers == null ? false : supportsDelimitedIdentifiers);</span>
    }

    /**
     * @param supportsDelimitedIds the supportsDelimitedIds to set
     */
    public void setSupportsDelimitedIdentifiers(boolean supportsDelimitedIds) {
<span class="nc" id="L5744">        supportsDelimitedIdentifiers = Boolean.valueOf(supportsDelimitedIds);</span>
<span class="nc" id="L5745">    }</span>

    /**
     * @param metaData the DatabaseMetaData to use to determine whether delimiters can be supported
     */
    private void setSupportsDelimitedIdentifiers(DatabaseMetaData metaData) {
        try {
<span class="nc" id="L5752">            supportsDelimitedIdentifiers = Boolean.valueOf(</span>
<span class="nc bnc" id="L5753" title="All 2 branches missed.">                metaData.supportsMixedCaseQuotedIdentifiers() ||</span>
<span class="nc bnc" id="L5754" title="All 2 branches missed.">                metaData.storesLowerCaseQuotedIdentifiers() ||</span>
<span class="nc bnc" id="L5755" title="All 2 branches missed.">                metaData.storesUpperCaseQuotedIdentifiers());</span>
<span class="nc" id="L5756">        } catch (SQLException e) {</span>
<span class="nc" id="L5757">            supportsDelimitedIdentifiers = Boolean.valueOf(false);</span>
<span class="nc" id="L5758">            getLog().warn(_loc.get(&quot;unknown-delim-support&quot;, e));</span>
<span class="nc" id="L5759">        }</span>
<span class="nc" id="L5760">    }</span>

    /**
     * @return the delimitIds
     */
    public boolean getDelimitIdentifiers() {
<span class="nc" id="L5766">        return delimitIdentifiers;</span>
    }

    /**
     * @param delimitIds the delimitIds to set
     */
    public void setDelimitIdentifiers(boolean delimitIds) {
<span class="nc" id="L5773">        delimitIdentifiers = delimitIds;</span>
<span class="nc" id="L5774">    }</span>

    /**
     * @return supportsXMLColumn
     */
    public boolean getSupportsXMLColumn() {
<span class="nc" id="L5780">        return supportsXMLColumn;</span>
    }

    /**
     * @param b boolean representing if XML columns are supported
     */
    public void setSupportsXMLColumn(boolean b) {
<span class="nc" id="L5787">        supportsXMLColumn = b;</span>
<span class="nc" id="L5788">    }</span>

    /**
     * @return xmlTypeEncoding
     */
    public String getXMLTypeEncoding() {
<span class="nc" id="L5794">        return xmlTypeEncoding;</span>
    }

    /**
     * @param encoding database required JAXB encoding for the XML value
     */
    public void setXMLTypeEncoding(String encoding) {
<span class="nc" id="L5801">        xmlTypeEncoding = encoding;</span>
<span class="nc" id="L5802">    }</span>

    public Log getLog() {
<span class="nc" id="L5805">        return log;</span>
    }

    @Override
    public boolean delimitAll() {
<span class="nc" id="L5810">        return delimitIdentifiers;</span>
    }

    @Override
    public String getLeadingDelimiter() {
<span class="nc" id="L5815">        return leadingDelimiter;</span>
    }

    public void setLeadingDelimiter(String delim) {
<span class="nc" id="L5819">        leadingDelimiter = delim;</span>
<span class="nc" id="L5820">    }</span>

    @Override
    public String getIdentifierDelimiter() {
<span class="nc" id="L5824">        return catalogSeparator;</span>
    }

    @Override
    public String getIdentifierConcatenator() {
<span class="nc" id="L5829">        return nameConcatenator;</span>
    }

    @Override
    public String getTrailingDelimiter() {
<span class="nc" id="L5834">        return trailingDelimiter;</span>
    }

    public void setTrailingDelimiter(String delim) {
<span class="nc" id="L5838">        trailingDelimiter = delim;</span>
<span class="nc" id="L5839">    }</span>

    @Override
    public IdentifierRule getDefaultIdentifierRule() {
<span class="nc bnc" id="L5843" title="All 2 branches missed.">        if (defaultNamingRule == null) {</span>
<span class="nc" id="L5844">            defaultNamingRule = namingRules.get(DBIdentifierType.DEFAULT.name());</span>
        }
<span class="nc" id="L5846">        return defaultNamingRule;</span>
    }

    @Override
    public &lt;T&gt; IdentifierRule getIdentifierRule(T t) {
<span class="nc bnc" id="L5851" title="All 2 branches missed.">        if (t.equals(DBIdentifierType.DEFAULT.name())) {</span>
<span class="nc" id="L5852">            return getDefaultIdentifierRule();</span>
        }
<span class="nc" id="L5854">        IdentifierRule nrule = namingRules.get(t);</span>
<span class="nc bnc" id="L5855" title="All 2 branches missed.">        if (nrule == null) {</span>
<span class="nc" id="L5856">            return getDefaultIdentifierRule();</span>
        }
<span class="nc" id="L5858">        return nrule;</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public Map&lt;String, IdentifierRule&gt; getIdentifierRules() {
<span class="nc" id="L5864">        return namingRules;</span>
    }

    /**
     * Returns the naming utility used by this dictionary instance
     */
    public DBIdentifierUtil getNamingUtil() {
<span class="nc" id="L5871">        return namingUtil;</span>
    }

    @Override
    public String getDelimitedCase() {
<span class="nc" id="L5876">        return delimitedCase;</span>
    }

    public String toDBName(DBIdentifier name) {
<span class="nc bnc" id="L5880" title="All 2 branches missed.">        if (!getSupportsDelimitedIdentifiers())</span>
<span class="nc" id="L5881">            return name.getName();</span>
        else
<span class="nc" id="L5883">            return getNamingUtil().toDBName(name);</span>
    }

    public String toDBName(DBIdentifier name, boolean delimit) {
<span class="nc bnc" id="L5887" title="All 2 branches missed.">        if (!getSupportsDelimitedIdentifiers())</span>
<span class="nc" id="L5888">            return name.getName();</span>
        else
<span class="nc" id="L5890">            return getNamingUtil().toDBName(name, delimit);</span>
    }

    public DBIdentifier fromDBName(String name, DBIdentifierType id) {
<span class="nc" id="L5894">        return getNamingUtil().fromDBName(name, id);</span>
    }

    public void setDefaultSchemaName(String defaultSchemaName) {
<span class="nc" id="L5898">        this.defaultSchemaName = defaultSchemaName;</span>
<span class="nc" id="L5899">    }</span>

    public String getDefaultSchemaName() {
<span class="nc" id="L5902">        return defaultSchemaName;</span>
    }

    @Override
    public String getConversionKey() {
<span class="nc bnc" id="L5907" title="All 2 branches missed.">        if (conversionKey == null) {</span>
<span class="nc" id="L5908">            conversionKey = getLeadingDelimiter() + getIdentifierDelimiter() +</span>
<span class="nc" id="L5909">            getTrailingDelimiter();</span>
        }
<span class="nc" id="L5911">        return conversionKey;</span>
    }

    /**
     * Return parameter marker for INSERT and UPDATE statements.
     * Usually it is &lt;code&gt;?&lt;/code&gt; but some database-specific types might require customization.
     *
     * @param col column definition
     * @param val value to be inserted/updated
     * @return parameter marker
     */
    public String getMarkerForInsertUpdate(Column col, Object val) {
<span class="nc" id="L5923">        return &quot;?&quot;;</span>
    }

    public String getIsNullSQL(String colAlias, int colType)  {
<span class="nc" id="L5927">        return String.format(&quot;%s IS NULL&quot;, colAlias);</span>
    }

    public String getIsNotNullSQL(String colAlias, int colType) {
<span class="nc" id="L5931">        return String.format(&quot;%s IS NOT NULL&quot;, colAlias);</span>
    }

    public String getIdentityColumnName() {
<span class="nc" id="L5935">        return null;</span>
    }

    /**
     * Default behavior is ROUND
     */
    public DateMillisecondBehaviors getMillisecondBehavior() {
        // If the user hasn't configured this property, fall back
        // to looking at the old property in the mean time till
        // we can get rid of it.
<span class="nc bnc" id="L5945" title="All 2 branches missed.">        if (dateMillisecondBehavior == null) {</span>
<span class="nc bnc" id="L5946" title="All 2 branches missed.">            if (roundTimeToMillisec) {</span>
<span class="nc" id="L5947">                dateMillisecondBehavior = DateMillisecondBehaviors.ROUND;</span>
            } else {
<span class="nc" id="L5949">                dateMillisecondBehavior = DateMillisecondBehaviors.DROP;</span>
            }
        }
<span class="nc" id="L5952">        return dateMillisecondBehavior;</span>
    }

    public void setDateMillisecondBehavior(String str) {
<span class="nc bnc" id="L5956" title="All 2 branches missed.">        if (str != null) {</span>
            // Tolerate different case
<span class="nc" id="L5958">            str = str.toUpperCase(Locale.ENGLISH);</span>
<span class="nc" id="L5959">            dateMillisecondBehavior = DateMillisecondBehaviors.valueOf(str);</span>
        } else {
<span class="nc" id="L5961">            dateMillisecondBehavior = null;</span>
        }
<span class="nc" id="L5963">    }</span>

    public BooleanRepresentation getBooleanRepresentation() {
<span class="nc" id="L5966">        return booleanRepresentation;</span>
    }

    public void setBooleanRepresentation(String booleanRepresentationKey) {
<span class="nc" id="L5970">        BooleanRepresentation evaluatedBooleanRepresentation = null;</span>
<span class="nc bnc" id="L5971" title="All 4 branches missed.">        if (booleanRepresentationKey != null &amp;&amp; booleanRepresentationKey.length() &gt; 0) {</span>
<span class="nc" id="L5972">            ClassLoader cl = conf.getUserClassLoader();</span>
<span class="nc" id="L5973">            evaluatedBooleanRepresentation = BooleanRepresentationFactory.valueOf(booleanRepresentationKey, cl);</span>
        }

<span class="nc bnc" id="L5976" title="All 2 branches missed.">        booleanRepresentation = evaluatedBooleanRepresentation != null</span>
<span class="nc" id="L5977">                                    ? evaluatedBooleanRepresentation</span>
<span class="nc" id="L5978">                                    : BooleanRepresentationFactory.INT_10;</span>
<span class="nc bnc" id="L5979" title="All 2 branches missed.">        if (log.isInfoEnabled()) {</span>
<span class="nc" id="L5980">            log.info(_loc.get(&quot;using-booleanRepresentation&quot;, booleanRepresentation));</span>
        }
<span class="nc" id="L5982">    }</span>

    protected boolean isUsingRange(long start, long end) {
<span class="nc bnc" id="L5985" title="All 4 branches missed.">		return isUsingOffset(start) || isUsingLimit(end);</span>
	}

	protected boolean isUsingOffset(long start) {
<span class="nc bnc" id="L5989" title="All 2 branches missed.">		return start != 0;</span>
	}

	protected boolean isUsingLimit(long end) {
<span class="nc bnc" id="L5993" title="All 2 branches missed.">		return end != Long.MAX_VALUE;</span>
	}

	protected boolean isUsingOrderBy(SQLBuffer sql) {
<span class="nc bnc" id="L5997" title="All 4 branches missed.">		return sql != null &amp;&amp; !sql.isEmpty();</span>
	}

	protected boolean versionEqualOrLaterThan(int maj, int min) {
<span class="nc bnc" id="L6001" title="All 6 branches missed.">    	return (major &gt; maj) || (major == maj &amp;&amp; minor &gt;= min);</span>
    }

	protected boolean versionEqualOrEarlierThan(int maj, int min) {
<span class="nc bnc" id="L6005" title="All 6 branches missed.">    	return (major &lt; maj) || (major == maj &amp;&amp; minor &lt;= min);</span>
    }

	protected boolean versionLaterThan(int maj) {
<span class="nc bnc" id="L6009" title="All 2 branches missed.">    	return (major &gt; maj);</span>
    }

	/**
	 * Gets major version of the database server.
	 */
	public final int getMajorVersion() {
<span class="nc" id="L6016">		return major;</span>
	}

	/**
	 * Sets major version of the database server.
	 */
	public void setMajorVersion(int maj) {
<span class="nc" id="L6023">		major = maj;</span>
<span class="nc" id="L6024">	}</span>

	/**
	 * Gets minor version of the database server.
	 */
	public final int getMinorVersion() {
<span class="nc" id="L6030">		return minor;</span>
	}

	/**
	 * Sets minor version of the database server.
	 */
	public void setMinorVersion(int min) {
<span class="nc" id="L6037">		minor = min;</span>
<span class="nc" id="L6038">	}</span>

    String nullSafe(String s) {
<span class="nc bnc" id="L6041" title="All 2 branches missed.">        return s == null ? &quot;&quot; : s;</span>
    }

	public int applyRange(Select select, int count) {
<span class="nc" id="L6045">		return count;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>