<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Configurations.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-lib</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.lib.conf</a> &gt; <span class="el_source">Configurations.java</span></div><h1>Configurations.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.lib.conf;

import java.io.File;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Properties;
import java.util.TreeSet;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;
import org.apache.openjpa.lib.log.Log;
import org.apache.openjpa.lib.util.ClassUtil;
import org.apache.openjpa.lib.util.J2DoPrivHelper;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.Options;
import org.apache.openjpa.lib.util.ParseException;
import org.apache.openjpa.lib.util.StringDistance;
import org.apache.openjpa.lib.util.StringUtil;
import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;


/**
 * Utility methods dealing with configuration.
 *
 * @author Abe White
 */
<span class="nc" id="L55">public class Configurations {</span>

<span class="nc" id="L57">    private static final Localizer _loc = Localizer.forPackage(Configurations.class);</span>

<span class="nc" id="L59">    private static final ConcurrentReferenceHashMap _loaders = new</span>
        ConcurrentReferenceHashMap(ReferenceStrength.WEAK, ReferenceStrength.HARD);

<span class="nc" id="L62">    private static final Object NULL_LOADER = &quot;null-loader&quot;;</span>

    public static final String CONFIG_RESOURCE_PATH = &quot;configResourcePath&quot;;
    public static final String CONFIG_RESOURCE_ANCHOR = &quot;configResourceAnchor&quot;;

    /**
     * Return the class name from the given plugin string, or null if none.
     */
    public static String getClassName(String plugin) {
<span class="nc" id="L71">        return getPluginComponent(plugin, true);</span>
    }

    /**
     * Return the properties part of the given plugin string, or null if none.
     */
    public static String getProperties(String plugin) {
<span class="nc" id="L78">        return getPluginComponent(plugin, false);</span>
    }

    /**
     * Return either the class name or properties string from a plugin string.
     */
    private static String getPluginComponent(String plugin, boolean clsName) {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (plugin != null)</span>
<span class="nc" id="L86">            plugin = plugin.trim();</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (StringUtil.isEmpty(plugin))</span>
<span class="nc" id="L88">            return null;</span>

<span class="nc" id="L90">        int openParen = -1;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (plugin.charAt(plugin.length() - 1) == ')')</span>
<span class="nc" id="L92">            openParen = plugin.indexOf('(');</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (openParen == -1) {</span>
<span class="nc" id="L94">            int eq = plugin.indexOf('=');</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (eq == -1)</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                return (clsName) ? plugin : null;</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            return (clsName) ? null : plugin;</span>
        }

        // clsName(props) form
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (clsName)</span>
<span class="nc" id="L102">            return plugin.substring(0, openParen).trim();</span>
<span class="nc" id="L103">        String prop = plugin.substring(openParen + 1,</span>
<span class="nc" id="L104">            plugin.length() - 1).trim();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        return (prop.length() == 0) ? null : prop;</span>
    }

    /**
     * Combine the given class name and properties into a plugin string.
     */
    public static String getPlugin(String clsName, String props) {
<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (StringUtil.isEmpty(clsName))</span>
<span class="nc" id="L113">            return props;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (StringUtil.isEmpty(props))</span>
<span class="nc" id="L115">            return clsName;</span>
<span class="nc" id="L116">        return clsName + &quot;(&quot; + props + &quot;)&quot;;</span>
    }

    /**
     * Return a plugin string that combines the properties of the given plugin
     * strings, where properties of &lt;code&gt;override&lt;/code&gt; will override the
     * same properties of &lt;code&gt;orig&lt;/code&gt;.
     */
    public static String combinePlugins(String orig, String override) {
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (StringUtil.isEmpty(orig))</span>
<span class="nc" id="L126">            return override;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (StringUtil.isEmpty(override))</span>
<span class="nc" id="L128">            return orig;</span>

<span class="nc" id="L130">        String origCls = getClassName(orig);</span>
<span class="nc" id="L131">        String overrideCls = getClassName(override);</span>
        String cls;
<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (StringUtil.isEmpty(origCls))</span>
<span class="nc" id="L134">            cls = overrideCls;</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        else if (StringUtil.isEmpty(overrideCls))</span>
<span class="nc" id="L136">            cls = origCls;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        else if (!origCls.equals(overrideCls))</span>
<span class="nc" id="L138">            return override; // completely different plugin</span>
        else
<span class="nc" id="L140">            cls = origCls;</span>

<span class="nc" id="L142">        String origProps = getProperties(orig);</span>
<span class="nc" id="L143">        String overrideProps = getProperties(override);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (StringUtil.isEmpty(origProps))</span>
<span class="nc" id="L145">            return getPlugin(cls, overrideProps);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (StringUtil.isEmpty(overrideProps))</span>
<span class="nc" id="L147">            return getPlugin(cls, origProps);</span>

<span class="nc" id="L149">        Properties props = parseProperties(origProps);</span>
<span class="nc" id="L150">        props.putAll(parseProperties(overrideProps));</span>
<span class="nc" id="L151">        return getPlugin(cls, serializeProperties(props));</span>
    }

    /**
     * Create the instance with the given class name, using the given
     * class loader. No configuration of the instance is performed by
     * this method.
     */
    public static Object newInstance(String clsName, ClassLoader loader) {
<span class="nc" id="L160">        return newInstance(clsName, null, null, loader, true);</span>
    }

    /**
     * Create and configure an instance with the given class name and
     * properties as a String.
     */
    public static Object newInstance(String clsName, Configuration conf,
        String props, ClassLoader loader) {
<span class="nc" id="L169">        Object obj = newInstance(clsName, null, conf, loader, true);</span>
<span class="nc" id="L170">        configureInstance(obj, conf, props);</span>
<span class="nc" id="L171">        return obj;</span>
    }

    /**
     * Create and configure an instance with the given class name and
     * properties.
     */
    public static Object newInstance(String clsName, Configuration conf,
        Properties props, ClassLoader loader) {
<span class="nc" id="L180">        Object obj = newInstance(clsName, null, conf, loader, true);</span>
<span class="nc" id="L181">        configureInstance(obj, conf, props);</span>
<span class="nc" id="L182">        return obj;</span>
    }

    /**
     * Loads the given class name by the given loader.
     * For efficiency, a cache per class loader is maintained of classes already loader.
     * @param clsName
     * @param loader
     */
    static Class&lt;?&gt; loadClass(String clsName, ClassLoader loader) {
<span class="nc" id="L192">        Class&lt;?&gt; cls = null;</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        Object key = loader == null ? NULL_LOADER : loader;</span>
<span class="nc" id="L194">        Map&lt;String,Class&lt;?&gt;&gt; loaderCache = (Map&lt;String,Class&lt;?&gt;&gt;) _loaders.get(key);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (loaderCache == null) { // We don't have a cache for this loader.</span>
            //OPENJPA-2636: Changed to HARD/WEAK to avoid Classloader leak:
<span class="nc" id="L197">            loaderCache = new ConcurrentReferenceHashMap(ReferenceStrength.HARD,</span>
                ReferenceStrength.WEAK);
<span class="nc" id="L199">            _loaders.put(key, loaderCache);</span>
        } else {  // We have a cache for this loader.
<span class="nc" id="L201">            cls = (Class&lt;?&gt;) loaderCache.get(clsName);</span>
        }
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (cls == null) {</span>
            try {
<span class="nc" id="L205">                cls = ClassUtil.toClass(clsName, loader);</span>
<span class="nc" id="L206">                loaderCache.put(clsName, cls);</span>
<span class="nc" id="L207">            } catch (RuntimeException re) {</span>
                // TODO, empty block is never good
<span class="nc" id="L209">            }</span>
        }
<span class="nc" id="L211">        return cls;</span>
    }

    /**
     * Helper method used by members of this package to instantiate plugin
     * values.
     */
    static Object newInstance(String clsName, Value val, Configuration conf,
        ClassLoader loader, boolean fatal) {
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (StringUtil.isEmpty(clsName))</span>
<span class="nc" id="L221">            return null;</span>

<span class="nc" id="L223">        Class&lt;?&gt; cls = loadClass(clsName, findDerivedLoader(conf, loader));</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (cls == null) {</span>
<span class="nc" id="L225">        	cls = loadClass(clsName, findDerivedLoader(conf, null));</span>
        }
<span class="nc bnc" id="L227" title="All 4 branches missed.">        if (cls == null &amp;&amp; conf.getUserClassLoader() != null) {</span>
<span class="nc" id="L228">        	cls = loadClass(clsName, conf.getUserClassLoader());</span>
        }

<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (cls == null) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (fatal)</span>
<span class="nc" id="L233">              throw getCreateException(clsName, val, new ClassNotFoundException(clsName));</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            Log log = (conf == null) ? null : conf.getConfigurationLog();</span>
<span class="nc bnc" id="L235" title="All 4 branches missed.">	        if (log != null &amp;&amp; log.isErrorEnabled())</span>
<span class="nc" id="L236">	            log.error(_loc.get(&quot;plugin-creation-exception&quot;, val));</span>
<span class="nc" id="L237">	        return null;</span>
       }

        try {
<span class="nc" id="L241">            return AccessController.doPrivileged(J2DoPrivHelper.newInstanceAction(cls));</span>
<span class="nc" id="L242">        } catch (Exception e) {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (e instanceof PrivilegedActionException) {</span>
<span class="nc" id="L244">                e = ((PrivilegedActionException) e).getException();</span>
            }
<span class="nc" id="L246">            RuntimeException re = new RuntimeException(_loc.get(&quot;obj-create&quot;, cls).getMessage(), e);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (fatal)</span>
<span class="nc" id="L248">                throw re;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            Log log = (conf == null) ? null : conf.getConfigurationLog();</span>
<span class="nc bnc" id="L250" title="All 4 branches missed.">            if (log != null &amp;&amp; log.isErrorEnabled())</span>
<span class="nc" id="L251">                log.error(_loc.get(&quot;plugin-creation-exception&quot;, val), re);</span>
<span class="nc" id="L252">            return null;</span>
        }
    }

    /**
     * Attempt to find a derived loader that delegates to our target loader.
     * This allows application loaders that delegate appropriately for known
     * classes first crack at class names.
     */
    private static ClassLoader findDerivedLoader(Configuration conf, ClassLoader loader) {
        // we always prefer the thread loader, because it's the only thing we
        // can access that isn't bound to the OpenJPA classloader, unless
        // the conf object is of a custom class
<span class="nc" id="L265">        ClassLoader ctxLoader = AccessController.doPrivileged(J2DoPrivHelper.getContextClassLoaderAction());</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (loader == null) {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (ctxLoader != null) {</span>
<span class="nc" id="L268">                return ctxLoader;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            } else if (conf != null) {</span>
<span class="nc" id="L270">                return classLoaderOf(conf.getClass());</span>
            } else {
<span class="nc" id="L272">            	return classLoaderOf(Configurations.class);</span>
            }
        }

<span class="nc bnc" id="L276" title="All 2 branches missed.">        for (ClassLoader parent = ctxLoader; parent != null; parent = parentClassLoaderOf(parent)) {</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (parent == loader)</span>
<span class="nc" id="L278">                return ctxLoader;</span>
        }
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (conf != null) {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            for (ClassLoader parent = classLoaderOf(conf.getClass()); parent != null;</span>
<span class="nc" id="L282">                    parent = parentClassLoaderOf(parent)) {</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                if (parent == loader)</span>
<span class="nc" id="L284">                    return classLoaderOf(conf.getClass());</span>
            }
        }
<span class="nc" id="L287">        return loader;</span>
    }

    static ClassLoader classLoaderOf(Class&lt;?&gt; cls) {
<span class="nc" id="L291">    	return AccessController.doPrivileged(J2DoPrivHelper.getClassLoaderAction(cls));</span>
    }

    static ClassLoader parentClassLoaderOf(ClassLoader loader) {
<span class="nc" id="L295">    	return AccessController.doPrivileged(J2DoPrivHelper.getParentAction(loader));</span>
    }

    /**
     * Return a List&lt;String&gt; of all the fully-qualified anchors specified in the
     * properties location listed in &lt;code&gt;opts&lt;/code&gt;. If no properties
     * location is listed in &lt;code&gt;opts&lt;/code&gt;, this returns whatever the
     * product derivations can find in their default configurations.
     * If the properties location specified in &lt;code&gt;opts&lt;/code&gt; already
     * contains an anchor spec, this returns that anchor. Note that in this
     * fully-qualified-input case, the logic involving product derivations
     * and resource parsing is short-circuited, so this method
     * should not be used as a means to test that a particular anchor is
     * defined in a given location by invoking with a fully-qualified anchor.
     *
     * This does not mutate &lt;code&gt;opts&lt;/code&gt;.
     *
     * @since 1.1.0
     */
    public static List&lt;String&gt; getFullyQualifiedAnchorsInPropertiesLocation(
        Options opts) {
<span class="nc" id="L316">        String props = opts.getProperty(&quot;properties&quot;, &quot;p&quot;, null);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (props != null) {</span>
<span class="nc" id="L318">            int anchorPosition = props.indexOf(&quot;#&quot;);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (anchorPosition &gt; -1)</span>
<span class="nc" id="L320">                return Arrays.asList(new String[] { props });</span>
        }

<span class="nc" id="L323">        return ProductDerivations.getFullyQualifiedAnchorsInPropertiesLocation(</span>
            props);
    }

    /**
     * Set the given {@link Configuration} instance from the command line
     * options provided. All property names of the given configuration are
     * recognized; additionally, if a &lt;code&gt;properties&lt;/code&gt; or
     * &lt;code&gt;p&lt;/code&gt; argument exists, the resource it
     * points to will be loaded and set into the given configuration instance.
     * It can point to either a file or a resource name.
     */
    public static void populateConfiguration(Configuration conf, Options opts) {
<span class="nc" id="L336">        String props = opts.removeProperty(&quot;properties&quot;, &quot;p&quot;, null);</span>
        ConfigurationProvider provider;
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (!StringUtil.isEmpty(props)) {</span>
<span class="nc" id="L339">            Map&lt;String, String&gt; result = parseConfigResource(props);</span>
<span class="nc" id="L340">            String path = result.get(CONFIG_RESOURCE_PATH);</span>
<span class="nc" id="L341">            String anchor = result.get(CONFIG_RESOURCE_ANCHOR);</span>

<span class="nc" id="L343">            File file = new File(path);</span>
<span class="nc" id="L344">            if ((AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                .isFileAction(file))).booleanValue())</span>
<span class="nc" id="L346">                provider = ProductDerivations.load(file, anchor, null);</span>
            else {
<span class="nc" id="L348">                file = new File(&quot;META-INF&quot; + File.separatorChar + path);</span>
<span class="nc" id="L349">                if ((AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                    .isFileAction(file))).booleanValue())</span>
<span class="nc" id="L351">                    provider = ProductDerivations.load(file, anchor, null);</span>
                else
<span class="nc" id="L353">                    provider = ProductDerivations.load(path, anchor, null);</span>
            }
<span class="nc bnc" id="L355" title="All 2 branches missed.">            if (provider != null)</span>
<span class="nc" id="L356">                provider.setInto(conf);</span>
            else
<span class="nc" id="L358">                throw new MissingResourceException(_loc.get(&quot;no-provider&quot;,</span>
<span class="nc" id="L359">                    props).getMessage(), Configurations.class.getName(),</span>
                    props);
<span class="nc" id="L361">        } else {</span>
<span class="nc" id="L362">            provider = ProductDerivations.loadDefaults(null);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (provider != null)</span>
<span class="nc" id="L364">                provider.setInto(conf);</span>
        }
<span class="nc" id="L366">        opts.setInto(conf);</span>
<span class="nc" id="L367">    }</span>

    public static Map&lt;String, String&gt; parseConfigResource(String props) {
<span class="nc" id="L370">        String path = props;</span>
<span class="nc" id="L371">        String anchor = null;</span>
<span class="nc" id="L372">        int idx = path.lastIndexOf('#');</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (idx != -1) {</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (idx &lt; path.length() - 1)</span>
<span class="nc" id="L375">                anchor = path.substring(idx + 1);</span>
<span class="nc" id="L376">            path = path.substring(0, idx);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (path.length() == 0)</span>
<span class="nc" id="L378">                throw new MissingResourceException(_loc.get(&quot;anchor-only&quot;,</span>
<span class="nc" id="L379">                    props).getMessage(), Configurations.class.getName(),</span>
                    props);
        }
<span class="nc" id="L382">        Map &lt;String, String&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc" id="L383">        result.put(CONFIG_RESOURCE_PATH, path);</span>
<span class="nc" id="L384">        result.put(CONFIG_RESOURCE_ANCHOR, anchor);</span>
<span class="nc" id="L385">        return result;</span>
    }

    /**
     * Helper method to throw an informative description on instantiation error.
     */
    private static RuntimeException getCreateException(String clsName, Value val, Exception e) {
        // re-throw the exception with some better information
        final String msg;
        final Object[] params;

<span class="nc" id="L396">        String alias = val.alias(clsName);</span>
<span class="nc" id="L397">        String[] aliases = val.getAliases();</span>
        String[] keys;
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (aliases.length == 0)</span>
<span class="nc" id="L400">            keys = aliases;</span>
        else {
<span class="nc" id="L402">            keys = new String[aliases.length / 2];</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            for (int i = 0; i &lt; aliases.length; i += 2)</span>
<span class="nc" id="L404">                keys[i / 2] = aliases[i];</span>
        }

        String closest;
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (keys.length == 0) {</span>
<span class="nc" id="L409">            msg = &quot;invalid-plugin&quot;;</span>
<span class="nc" id="L410">            params = new Object[]{ val.getProperty(), alias, e.toString(), };</span>
<span class="nc" id="L411">        } else if ((closest = StringDistance.getClosestLevenshteinDistance</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            (alias, keys, 0.5f)) == null) {</span>
<span class="nc" id="L413">            msg = &quot;invalid-plugin-aliases&quot;;</span>
<span class="nc" id="L414">            params = new Object[]{</span>
<span class="nc" id="L415">                val.getProperty(), alias, e.toString(),</span>
<span class="nc" id="L416">                new TreeSet&lt;&gt;(Arrays.asList(keys)), };</span>
        } else {
<span class="nc" id="L418">            msg = &quot;invalid-plugin-aliases-hint&quot;;</span>
<span class="nc" id="L419">            params = new Object[]{</span>
<span class="nc" id="L420">                val.getProperty(), alias, e.toString(),</span>
<span class="nc" id="L421">                new TreeSet&lt;&gt;(Arrays.asList(keys)), closest, };</span>
        }
<span class="nc" id="L423">        return new ParseException(_loc.get(msg, params), e);</span>
    }

    /**
     * Configures the given object with the given properties by
     * matching the properties string to the object's setter
     * methods. The properties string should be in the form
     * &quot;prop1=val1, prop2=val2 ...&quot;. Does not validate that setter
     * methods exist for the properties.
     *
     * @throws RuntimeException on configuration error
     */
    public static void configureInstance(Object obj, Configuration conf,
        String properties) {
<span class="nc" id="L437">        configureInstance(obj, conf, properties, null);</span>
<span class="nc" id="L438">    }</span>

    /**
     * Configures the given object with the given properties by
     * matching the properties string to the object's setter
     * methods. The properties string should be in the form
     * &quot;prop1=val1, prop2=val2 ...&quot;. Validates that setter methods
     * exist for the properties.
     *
     * @throws RuntimeException on configuration error
     */
    public static void configureInstance(Object obj, Configuration conf,
        String properties, String configurationName) {
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L452">            return;</span>

<span class="nc" id="L454">        Properties props = null;</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (!StringUtil.isEmpty(properties))</span>
<span class="nc" id="L456">            props = parseProperties(properties);</span>
<span class="nc" id="L457">        configureInstance(obj, conf, props, configurationName);</span>
<span class="nc" id="L458">    }</span>

    /**
     * Configures the given object with the given properties by
     * matching the properties string to the object's setter
     * methods. Does not validate that setter methods exist for the properties.
     *
     * @throws RuntimeException on configuration error
     */
    public static void configureInstance(Object obj, Configuration conf,
        Properties properties) {
<span class="nc" id="L469">        configureInstance(obj, conf, properties, null);</span>
<span class="nc" id="L470">    }</span>

    /**
     * Configures the given object with the given properties by
     * matching the properties string to the object's setter
     * methods. If &lt;code&gt;configurationName&lt;/code&gt; is
     * non-&lt;code&gt;null&lt;/code&gt;, validates that setter methods exist for
     * the properties.
     *
     * @throws RuntimeException on configuration error
     */
    public static void configureInstance(Object obj, Configuration conf,
        Properties properties, String configurationName) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L484">            return;</span>

        Options opts;
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (properties instanceof Options)</span>
<span class="nc" id="L488">            opts = (Options) properties;</span>
        else {
<span class="nc" id="L490">            opts = new Options();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (properties != null)</span>
<span class="nc" id="L492">                opts.putAll(properties);</span>
        }

<span class="nc" id="L495">        Configurable configurable = null;</span>
<span class="nc bnc" id="L496" title="All 4 branches missed.">        if (conf != null &amp;&amp; obj instanceof Configurable)</span>
<span class="nc" id="L497">            configurable = (Configurable) obj;</span>

<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (configurable != null) {</span>
<span class="nc" id="L500">            configurable.setConfiguration(conf);</span>
<span class="nc" id="L501">            configurable.startConfiguration();</span>
        }
<span class="nc" id="L503">        Options invalidEntries = opts.setInto(obj);</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (obj instanceof GenericConfigurable)</span>
<span class="nc" id="L505">            ((GenericConfigurable) obj).setInto(invalidEntries);</span>

<span class="nc bnc" id="L507" title="All 4 branches missed.">		if (!invalidEntries.isEmpty() &amp;&amp; configurationName != null) {</span>
<span class="nc" id="L508">			Localizer.Message msg = null;</span>
<span class="nc" id="L509">            String first = (String) invalidEntries.keySet().iterator().next();</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">			if (invalidEntries.keySet().size() == 1 &amp;&amp;</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">				first.indexOf('.') == -1) {</span>
                // if there's just one misspelling and this is not a
				// path traversal, check for near misses.
<span class="nc" id="L514">                Collection&lt;String&gt; options = findOptionsFor(obj.getClass());</span>
<span class="nc" id="L515">                String close = StringDistance.getClosestLevenshteinDistance</span>
<span class="nc" id="L516">					(first, options, 0.75f);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">				if (close != null)</span>
<span class="nc" id="L518">                    msg = _loc.get(&quot;invalid-config-param-hint&quot;, new Object[]{</span>
<span class="nc" id="L519">                            configurationName, obj.getClass(), first, close,</span>
						    options, });
			}

<span class="nc bnc" id="L523" title="All 2 branches missed.">            if (msg == null) {</span>
<span class="nc" id="L524">                msg = _loc.get(&quot;invalid-config-params&quot;, new String[]{</span>
<span class="nc" id="L525">                    configurationName, obj.getClass().getName(),</span>
<span class="nc" id="L526">                    invalidEntries.keySet().toString(),</span>
<span class="nc" id="L527">                    findOptionsFor(obj.getClass()).toString(), });</span>
            }
<span class="nc" id="L529">            throw new ParseException(msg);</span>
        }
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (configurable != null)</span>
<span class="nc" id="L532">            configurable.endConfiguration();</span>
<span class="nc" id="L533">    }</span>

    private static Collection&lt;String&gt; findOptionsFor(Class&lt;?&gt; cls) {
<span class="nc" id="L536">        Collection&lt;String&gt; c = Options.findOptionsFor(cls);</span>

        // remove Configurable.setConfiguration() and
        // GenericConfigurable.setInto() from the set, if applicable.
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (Configurable.class.isAssignableFrom(cls))</span>
<span class="nc" id="L541">            c.remove(&quot;Configuration&quot;);</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (GenericConfigurable.class.isAssignableFrom(cls))</span>
<span class="nc" id="L543">            c.remove(&quot;Into&quot;);</span>

<span class="nc" id="L545">        return c;</span>
    }

    /**
     * Turn a set of properties into a comma-separated string.
     */
    public static String serializeProperties(Map map) {
<span class="nc bnc" id="L552" title="All 4 branches missed.">        if (map == null || map.isEmpty())</span>
<span class="nc" id="L553">            return null;</span>

<span class="nc" id="L555">        StringBuilder buf = new StringBuilder();</span>
        Map.Entry entry;
        String val;
<span class="nc bnc" id="L558" title="All 2 branches missed.">        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {</span>
<span class="nc" id="L559">            entry = (Map.Entry) itr.next();</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (buf.length() &gt; 0)</span>
<span class="nc" id="L561">                buf.append(&quot;, &quot;);</span>
<span class="nc" id="L562">            buf.append(entry.getKey()).append('=');</span>
<span class="nc" id="L563">            val = String.valueOf(entry.getValue());</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">            if (val.indexOf(',') != -1)</span>
<span class="nc" id="L565">                buf.append('&quot;').append(val).append('&quot;');</span>
            else
<span class="nc" id="L567">                buf.append(val);</span>
        }
<span class="nc" id="L569">        return buf.toString();</span>
    }

    /**
     * Parse a set of properties from a comma-separated string.
     */
    public static Options parseProperties(String properties) {
<span class="nc" id="L576">        Options opts = new Options();</span>
<span class="nc" id="L577">        properties = StringUtil.trimToNull(properties);</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        if (properties == null)</span>
<span class="nc" id="L579">            return opts;</span>

        try {
<span class="nc" id="L582">            String[] props = StringUtil.split(properties, &quot;,&quot;, 0);</span>
            int idx;
            char quote;
            String prop;
            String val;
<span class="nc bnc" id="L587" title="All 2 branches missed.">            for (int i = 0; i &lt; props.length; i++) {</span>
<span class="nc" id="L588">                idx = props[i].indexOf('=');</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                if (idx == -1) {</span>
                    // if the key is not assigned to any value, set the
                    // value to the same thing as the key, and continue.
                    // This permits GenericConfigurable instances to
                    // behave meaningfully. We might consider setting the
                    // value to some well-known &quot;value was not set, but
                    // key is present&quot; string so that instances getting
                    // values injected can differentiate between a mentioned
                    // property and one set to a particular value.
<span class="nc" id="L598">                    prop = props[i];</span>
<span class="nc" id="L599">                    val = prop;</span>
                } else {
<span class="nc" id="L601">                    prop = props[i].substring(0, idx).trim();</span>
<span class="nc" id="L602">                    val = props[i].substring(idx + 1).trim();</span>
                }

                // if the value is quoted, read until the end quote
<span class="nc bnc" id="L606" title="All 4 branches missed.">                if (((val.startsWith(&quot;\&quot;&quot;) &amp;&amp; val.endsWith(&quot;\&quot;&quot;))</span>
<span class="nc bnc" id="L607" title="All 4 branches missed.">                    || (val.startsWith(&quot;'&quot;) &amp;&amp; val.endsWith(&quot;'&quot;)))</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">                    &amp;&amp; val.length() &gt; 1)</span>
<span class="nc" id="L609">                    val = val.substring(1, val.length() - 1);</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">                else if (val.startsWith(&quot;\&quot;&quot;) || val.startsWith(&quot;'&quot;)) {</span>
<span class="nc" id="L611">                    quote = val.charAt(0);</span>
<span class="nc" id="L612">                    StringBuilder buf = new StringBuilder(val.substring(1));</span>
                    int quotIdx;
<span class="nc bnc" id="L614" title="All 2 branches missed.">                    while (++i &lt; props.length) {</span>
<span class="nc" id="L615">                        buf.append(&quot;,&quot;);</span>

<span class="nc" id="L617">                        quotIdx = props[i].indexOf(quote);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                        if (quotIdx != -1) {</span>
<span class="nc" id="L619">                            buf.append(props[i].substring(0, quotIdx));</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                            if (quotIdx + 1 &lt; props[i].length())</span>
<span class="nc" id="L621">                                buf.append(props[i].substring(quotIdx + 1));</span>
                            break;
                        } else
<span class="nc" id="L624">                            buf.append(props[i]);</span>
                    }
<span class="nc" id="L626">                    val = buf.toString();</span>
                }
<span class="nc" id="L628">                opts.put(prop, val);</span>
            }
<span class="nc" id="L630">            return opts;</span>
<span class="nc" id="L631">        } catch (RuntimeException re) {</span>
<span class="nc" id="L632">            throw new ParseException(_loc.get(&quot;prop-parse&quot;, properties), re);</span>
        }
    }

    /**
     * Looks up the given name in JNDI. If the name is null, null is returned.
     */
    public static Object lookup(String name, String userKey, Log log) {
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (StringUtil.isEmpty(name))</span>
<span class="nc" id="L641">            return null;</span>

<span class="nc" id="L643">        Context ctx = null;</span>
        try {
<span class="nc" id="L645">            ctx = new InitialContext();</span>
<span class="nc" id="L646">            Object result = ctx.lookup(name);</span>
<span class="nc bnc" id="L647" title="All 6 branches missed.">            if (result == null &amp;&amp; log != null &amp;&amp; log.isWarnEnabled())</span>
<span class="nc" id="L648">            	log.warn(_loc.get(&quot;jndi-lookup-failed&quot;, userKey, name));</span>
<span class="nc" id="L649">            return result;</span>
<span class="nc" id="L650">        } catch (NamingException ne) {</span>
<span class="nc" id="L651">            throw new RuntimeException(</span>
<span class="nc" id="L652">                _loc.get(&quot;naming-err&quot;, name).getMessage(), ne);</span>
        } finally {
<span class="nc bnc" id="L654" title="All 2 branches missed.">            if (ctx != null) {</span>
                try {
<span class="nc" id="L656">                    ctx.close();</span>
<span class="nc" id="L657">                } catch (NamingException ne) {</span>
                    // ignore
<span class="nc" id="L659">                }</span>
            }
        }
    }

    /**
     * Test whether the map contains the given partial key, prefixed with any
     * possible configuration prefix.
     */
    public static boolean containsProperty(Value value, Map props) {
<span class="nc bnc" id="L669" title="All 6 branches missed.">        if (value == null || props == null || props.isEmpty())</span>
<span class="nc" id="L670">            return false;</span>
<span class="nc" id="L671">        List&lt;String&gt; partialKeys = value.getPropertyKeys();</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        for (String partialKey : partialKeys) {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">            if (props.containsKey(</span>
<span class="nc" id="L674">                ProductDerivations.getConfigurationKey(partialKey, props)))</span>
<span class="nc" id="L675">                return true;</span>
<span class="nc" id="L676">        }</span>
<span class="nc" id="L677">        return false;</span>
    }

    /**
     * Test whether the map contains the given partial key, prefixed with any
     * possible configuration prefix.
     */
    public static boolean containsProperty(String partialKey, Map props) {
<span class="nc bnc" id="L685" title="All 6 branches missed.">        if (partialKey == null || props == null || props.isEmpty())</span>
<span class="nc" id="L686">            return false;</span>
        else
<span class="nc" id="L688">            return props.containsKey(</span>
<span class="nc" id="L689">                ProductDerivations.getConfigurationKey(partialKey, props));</span>
    }

    /**
     * Get the property under the given partial key, prefixed with any possible
     * configuration prefix.
     */
    public static Object getProperty(String partialKey, Map m) {
<span class="nc bnc" id="L697" title="All 6 branches missed.">        if (partialKey == null || m == null || m.isEmpty())</span>
<span class="nc" id="L698">            return null;</span>
        else
<span class="nc" id="L700">            return m.get(ProductDerivations.getConfigurationKey(partialKey, m));</span>
    }

    /**
     * Remove the property under the given partial key, prefixed with any
     * possible configuration prefix.
     */
    public static Object removeProperty(String partialKey, Map props) {
<span class="nc bnc" id="L708" title="All 6 branches missed.">        if (partialKey == null || props == null || props.isEmpty())</span>
<span class="nc" id="L709">            return null;</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (containsProperty(partialKey, props))</span>
<span class="nc" id="L711">            return props.remove(ProductDerivations.getConfigurationKey(partialKey, props));</span>
        else
<span class="nc" id="L713">            return null;</span>
    }

    public static void removeProperty(String partialKey, Map&lt;?,?&gt; remaining, Map&lt;?,?&gt; props) {
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (removeProperty(partialKey, remaining) != null) {</span>
<span class="nc" id="L718">            removeProperty(partialKey, props);</span>
        }
<span class="nc" id="L720">    }</span>

    /**
     * Runs &lt;code&gt;runnable&lt;/code&gt; against all the anchors in the configuration
     * pointed to by &lt;code&gt;opts&lt;/code&gt;. Each invocation gets a fresh clone of
     * &lt;code&gt;opts&lt;/code&gt; with the &lt;code&gt;properties&lt;/code&gt; option set
     * appropriately.
     *
     * @since 1.1.0
     */
    public static boolean runAgainstAllAnchors(Options opts,
        Configurations.Runnable runnable) {
<span class="nc bnc" id="L732" title="All 4 branches missed.">        if (opts.containsKey(&quot;help&quot;) || opts.containsKey(&quot;-help&quot;)) {</span>
<span class="nc" id="L733">            return false;</span>
        }
<span class="nc" id="L735">        List&lt;String&gt; anchors =</span>
<span class="nc" id="L736">            Configurations.getFullyQualifiedAnchorsInPropertiesLocation(opts);</span>

        // We use 'properties' below; get rid of 'p' to avoid conflicts. This
        // relies on knowing what getFullyQualifiedAnchorsInPropertiesLocation
        // looks for.
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (opts.containsKey(&quot;p&quot;))</span>
<span class="nc" id="L742">            opts.remove(&quot;p&quot;);</span>

<span class="nc" id="L744">        boolean ret = true;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (anchors.size() == 0) {</span>
<span class="nc" id="L746">            ret = launchRunnable(opts, runnable);</span>
        } else {
<span class="nc bnc" id="L748" title="All 2 branches missed.">            for(String s : anchors ) {</span>
<span class="nc" id="L749">                Options clonedOptions = (Options) opts.clone();</span>
<span class="nc" id="L750">                clonedOptions.setProperty(&quot;properties&quot;, s);</span>
<span class="nc" id="L751">                ret &amp;= launchRunnable(clonedOptions, runnable);</span>
<span class="nc" id="L752">            }</span>
        }
<span class="nc" id="L754">        return ret;</span>
    }

    private static boolean launchRunnable(Options opts,
        Configurations.Runnable runnable) {
<span class="nc" id="L759">        boolean ret = true;</span>
        try {
<span class="nc" id="L761">            ret = runnable.run(opts);</span>
<span class="nc" id="L762">        } catch (Exception e) {</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            if (!(e instanceof RuntimeException))</span>
<span class="nc" id="L764">                throw new RuntimeException(e);</span>
            else
<span class="nc" id="L766">                throw (RuntimeException) e;</span>
<span class="nc" id="L767">        }</span>
<span class="nc" id="L768">        return ret;</span>
    }

    public interface Runnable {
        boolean run(Options opts) throws Exception;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>